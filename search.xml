<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LearnAI</title>
    <url>/2023/01/19/LearnAI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Chapter-1-引言"><a href="#Chapter-1-引言" class="headerlink" title="Chapter 1 引言"></a>Chapter 1 引言</h2><p>是时候系统学习一下人工智能了,希望什么时候可以补充一下引言吧</p>
<ul>
<li>设备环境：Linux-Ubuntu20.04</li>
<li>编译环境：miniconda</li>
</ul>
<h2 id="Chapter-2-预备知识"><a href="#Chapter-2-预备知识" class="headerlink" title="Chapter 2 预备知识"></a>Chapter 2 预备知识</h2><h3 id="2-1-数据处理"><a href="#2-1-数据处理" class="headerlink" title="2.1 数据处理"></a>2.1 数据处理</h3><h4 id="2-1-1-创建张量"><a href="#2-1-1-创建张量" class="headerlink" title="2.1.1 创建张量"></a>2.1.1 创建张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p><strong>此处为torch,<del>虽然包叫pytorch</del></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
</code></pre><p>张量：数组，但里面的内容都是数值，维度不限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([12])
</code></pre><p>通过<code>shape</code>可以查询张量的形状;[]代表维度为1，12代表这一维度的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.numel()</span><br></pre></td></tr></table></figure>
<pre><code>12
</code></pre><p><code>numel()</code>可以访问张量中元素的总数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
</code></pre><p>通过<code>reshape(c,r)</code>,可以将张量重新排列成多维形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x.reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[6], line 1
----&gt; 1 y = x.reshape(4, 4)
      2 y


RuntimeError: shape &#39;[4, 4]&#39; is invalid for input of size 12
</code></pre><p>但重组时，col与row的乘积必须等于元素总数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">o = torch.ones((<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(z, <span class="string">&#x27;\n&#x27;</span> ,o)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],

        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]]) 
 tensor([[[1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.]]])
</code></pre><p>使用<code>zeros()</code>构造全0矩阵，同理<code>ones()</code>, <del>没有除了1和0之外的数</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]])
</code></pre><p>使用<code>tensor()</code>手动构造变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.2559,  0.4066,  0.4201, -1.1634],
        [-2.0670,  0.6678,  0.9912,  0.2923],
        [ 0.2710,  1.9265, -1.6423, -0.9642]])
</code></pre><p>生成随机数张量，元素平均数为0，标准差为1的正态分布中随机采样</p>
<h4 id="2-1-2-张量运算"><a href="#2-1-2-张量运算" class="headerlink" title="2.1.2 张量运算"></a>2.1.2 张量运算</h4><h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>,<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>,  <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">x+y,x-y,x*y,x/y,x**y,x%y</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([ 3.,  5.,  8., 13.]),
 tensor([-1., -1.,  0.,  3.]),
 tensor([ 2.,  6., 16., 40.]),
 tensor([0.5000, 0.6667, 1.0000, 1.6000]),
 tensor([1.0000e+00, 8.0000e+00, 2.5600e+02, 3.2768e+04]),
 tensor([1., 2., 0., 3.]))
</code></pre><p>对于相同形状的张量，可以通过(+,-,*,/,%)作运算，具体来说：$I+J \rightarrow I_i+J_i$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">x = torch.tensor([numpy.e,numpy.log(<span class="number">2</span>),<span class="number">1</span>,torch.e])</span><br><span class="line">torch.exp(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([15.1543,  2.0000,  2.7183, 15.1543], dtype=torch.float64)
</code></pre><p><code>exp()</code>求解e的x次方：$y_i=e^{x_i}$</p>
<h5 id="张量拼接"><a href="#张量拼接" class="headerlink" title="张量拼接"></a>张量拼接</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">torch.cat((x,y),dim=<span class="number">0</span>), torch.cat((x,y),dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11],
         [ 2,  1,  4,  3],
         [ 1,  2,  3,  4],
         [ 4,  3,  2,  1]]),
 tensor([[ 0,  1,  2,  3,  2,  1,  4,  3],
         [ 4,  5,  6,  7,  1,  2,  3,  4],
         [ 8,  9, 10, 11,  4,  3,  2,  1]]))
</code></pre><p>通过<code>cat()</code>可以实现拼接，<code>dim=0</code>按照行，<code>dim=1</code>按列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]])</span><br><span class="line">torch.cat((x,y),dim=<span class="number">0</span>), torch.cat((x,y),dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[13], line 3
      1 x = torch.arange(12).reshape((3,4))
      2 y = torch.tensor([[2,1,4],[1,2,3],[4,3,2]])
----&gt; 3 torch.cat((x,y),dim=0), torch.cat((x,y),dim=1)


RuntimeError: Sizes of tensors must match except in dimension 0. Expected size 4 but got size 3 for tensor number 1 in the list.
</code></pre><p>若尺寸不对应则会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">x == y</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[False,  True, False,  True],
        [False, False, False, False],
        [False, False, False, False]])
</code></pre><p>近似于求位与运算</p>
<h5 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">torch.<span class="built_in">sum</span>(x), x.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>(tensor(66), tensor(66))
</code></pre><h5 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0, 1],
        [1, 2],
        [2, 3]])
</code></pre><p>试试多维，有点废脑子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([ [ [<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>] ] ,[[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>] ] ])</span><br><span class="line">y = torch.tensor([ [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] ])</span><br><span class="line">x,y,x+y</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[[1],
          [1],
          [1]],

         [[2],
          [3],
          [4]]]),
 tensor([[[1, 2, 3]]]),
 tensor([[[2, 3, 4],
          [2, 3, 4],
          [2, 3, 4]],

         [[3, 4, 5],
          [4, 5, 6],
          [5, 6, 7]]]))
</code></pre><h5 id="张量切片"><a href="#张量切片" class="headerlink" title="张量切片"></a>张量切片</h5><p>按行切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">x,x[-<span class="number">1</span>],x[<span class="number">2</span>],x[<span class="number">0</span>:<span class="number">2</span>],x[<span class="number">0</span>:<span class="number">3</span>],x[<span class="number">0</span>:-<span class="number">1</span>],x[:-<span class="number">1</span>],x[:],x[:<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]),
 tensor([ 8,  9, 10, 11]),
 tensor([ 8,  9, 10, 11]),
 tensor([[0, 1, 2, 3],
         [4, 5, 6, 7]]),
 tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]),
 tensor([[0, 1, 2, 3],
         [4, 5, 6, 7]]),
 tensor([[0, 1, 2, 3],
         [4, 5, 6, 7]]),
 tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]),
 tensor([], size=(0, 4), dtype=torch.int64))
</code></pre><p>自定义切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">x[:,<span class="number">1</span>] , x[<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:] , x[<span class="number">0</span>::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>], x[<span class="number">0</span>::<span class="number">2</span>,<span class="number">0</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([1, 5, 9]),
 tensor([[ 5,  6,  7],
         [ 9, 10, 11]]),
 tensor([[ 1,  3],
         [ 9, 11]]),
 tensor([[ 0,  2],
         [ 8, 10]]))
</code></pre><p><code>a:b:c</code>,在区间[a,b)中取数，step=c,a,c默认为0，b默认最后一位</p>
<h5 id="暴力写入"><a href="#暴力写入" class="headerlink" title="暴力写入"></a>暴力写入</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0,  1,  2,  3],
        [ 4,  5,  9,  7],
        [ 8,  9, 10, 11]])
</code></pre><h5 id="内存节省"><a href="#内存节省" class="headerlink" title="内存节省"></a>内存节省</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">4</span>)</span><br><span class="line">before = <span class="built_in">id</span>(y)</span><br><span class="line">y = y + x</span><br><span class="line"><span class="built_in">id</span>(y) == before</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p>在处理变量中，一般操作会导致新建内存，如果矩阵数据特别大，容易消耗内存,可以使用原地存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">4</span>)</span><br><span class="line">before = <span class="built_in">id</span>(y)</span><br><span class="line">y += x</span><br><span class="line"><span class="built_in">id</span>(y) == before</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[22], line 3
      1 y = torch.arange(4)
      2 before = id(y)
----&gt; 3 y += x
      4 id(y) == before


RuntimeError: output with shape [4] doesn&#39;t match the broadcast shape [3, 4]
</code></pre><h5 id="类型互换"><a href="#类型互换" class="headerlink" title="类型互换"></a>类型互换</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">4</span>)</span><br><span class="line">x = torch.arange(<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line">z = torch.zeros_like(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(z):&#x27;</span>,<span class="built_in">id</span>(z))</span><br><span class="line">z[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(z):&#x27;</span>,<span class="built_in">id</span>(z))</span><br></pre></td></tr></table></figure>
<pre><code>id(z): 140157950377472
id(z): 140157950377472
</code></pre><p>Pytorch与Numpy的互换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = x.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">type</span>(A),<span class="built_in">type</span>(B)</span><br></pre></td></tr></table></figure>
<pre><code>(numpy.ndarray, torch.Tensor)
</code></pre><p>将大小为1的张量转化为python标量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a,a.item(),<span class="built_in">float</span>(a),<span class="built_in">int</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([3.5000]), 3.5, 3.5, 3)
</code></pre><h3 id="2-2数据预处理"><a href="#2-2数据预处理" class="headerlink" title="2.2数据预处理"></a>2.2数据预处理</h3><h4 id="2-2-1-生成数据集文件"><a href="#2-2-1-生成数据集文件" class="headerlink" title="2.2.1 生成数据集文件"></a>2.2.1 生成数据集文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>创建CSV文件：房价数据-房间数量/巷子类型/价格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<pre><code>   NumRooms Alley   Price
0       NaN  Pave  127500
1       2.0   NaN  106000
2       4.0   NaN  178100
3       NaN   NaN  140000
</code></pre><p>运用pandas库读取csv</p>
<h4 id="2-2-2-补充丢失数据"><a href="#2-2-2-补充丢失数据" class="headerlink" title="2.2.2 补充丢失数据"></a>2.2.2 补充丢失数据</h4><p>补充丢失数据的典型方法是插值法和删除法</p>
<ul>
<li>插值法：用一个数字替代缺失位</li>
<li>删除法：直接忽略缺少的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:,<span class="number">0</span>:<span class="number">2</span>], data.iloc[:, <span class="number">2</span>]</span><br><span class="line">inputs = inputs.fillna(inputs.mean())</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<pre><code>   NumRooms Alley
0       3.0  Pave
1       2.0   NaN
2       4.0   NaN
3       3.0   NaN
</code></pre><p>在补充房间数，使用插值法，通过插入已知数的平均值补充未知数，<code>input.mean()</code>读取数据平均数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs,dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<pre><code>   NumRooms  Alley_Pave  Alley_nan
0       3.0           1          0
1       2.0           0          1
2       4.0           0          1
3       3.0           0          1
</code></pre><p>在补充巷子时，看成是有Pave为1，无为0的矩阵形式</p>
<h4 id="2-2-3-转化为张量形式"><a href="#2-2-3-转化为张量形式" class="headerlink" title="2.2.3 转化为张量形式"></a>2.2.3 转化为张量形式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor(inputs.values)</span><br><span class="line">y = torch.tensor(outputs.values)</span><br><span class="line"></span><br><span class="line">x,y</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[3., 1., 0.],
         [2., 0., 1.],
         [4., 0., 1.],
         [3., 0., 1.]], dtype=torch.float64),
 tensor([127500, 106000, 178100, 140000]))
</code></pre><p>利用<code>tensor()</code>构造张量</p>
<h4 id="实例：删除空数据最多的一列"><a href="#实例：删除空数据最多的一列" class="headerlink" title="实例：删除空数据最多的一列"></a>实例：删除空数据最多的一列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">count_max = <span class="number">0</span></span><br><span class="line">labels = [<span class="string">&#x27;NumRooms&#x27;</span>,<span class="string">&#x27;Alley&#x27;</span>,<span class="string">&#x27;Price&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> labels:</span><br><span class="line">    count = data[label].isna().<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">if</span> count &gt; count_max:</span><br><span class="line">        count_max = count</span><br><span class="line">        flag = label</span><br><span class="line">data_new = data.drop(flag,axis=<span class="number">1</span>)</span><br><span class="line">data_new</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>NumRooms</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NaN</td>
<td>127500</td>
</tr>
<tr>
<td>1</td>
<td>2.0</td>
<td>106000</td>
</tr>
<tr>
<td>2</td>
<td>4.0</td>
<td>178100</td>
</tr>
<tr>
<td>3</td>
<td>NaN</td>
<td>140000</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-线性代数"><a href="#2-3-线性代数" class="headerlink" title="2.3 线性代数"></a>2.3 线性代数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-标量"><a href="#2-3-1-标量" class="headerlink" title="2.3.1 标量"></a>2.3.1 标量</h4><p>虽然直接声明常量更为常见，但是<code>torch</code>也支持创建标量，即长度为1的一维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor(<span class="number">3.0</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-向量"><a href="#2-3-2-向量" class="headerlink" title="2.3.2 向量"></a>2.3.2 向量</h4><h5 id="向量的声明"><a href="#向量的声明" class="headerlink" title="向量的声明"></a>向量的声明</h5><p>向量的声明通常就是一维张量，即<code>tensor([x,y,z,...])</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>,dtype=torch.float32)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 1., 2., 3.])
</code></pre><h5 id="向量的形状"><a href="#向量的形状" class="headerlink" title="向量的形状"></a>向量的形状</h5><p>shape可以查看向量的维度，是一个元素组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">12</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">y, y.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[[ 0,  1],
          [ 2,  3],
          [ 4,  5]],

         [[ 6,  7],
          [ 8,  9],
          [10, 11]]]),
 torch.Size([2, 3, 2]))
</code></pre><h4 id="2-3-3-矩阵"><a href="#2-3-3-矩阵" class="headerlink" title="2.3.3 矩阵"></a>2.3.3 矩阵</h4><h5 id="声明矩阵"><a href="#声明矩阵" class="headerlink" title="声明矩阵"></a>声明矩阵</h5><p>一个二维张量,$R^{(M·N)}$ 对应A(m,n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.],
        [ 8.,  9., 10., 11.],
        [12., 13., 14., 15.],
        [16., 17., 18., 19.]])
</code></pre><h5 id="矩阵转制"><a href="#矩阵转制" class="headerlink" title="矩阵转制"></a>矩阵转制</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.,  4.,  8., 12., 16.],
        [ 1.,  5.,  9., 13., 17.],
        [ 2.,  6., 10., 14., 18.],
        [ 3.,  7., 11., 15., 19.]])
</code></pre><h5 id="按元素相乘-Hadamard-Product"><a href="#按元素相乘-Hadamard-Product" class="headerlink" title="按元素相乘 Hadamard Product"></a>按元素相乘 Hadamard Product</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = A.clone()</span><br><span class="line">A * B</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[  0.,   1.,   4.,   9.],
        [ 16.,  25.,  36.,  49.],
        [ 64.,  81., 100., 121.],
        [144., 169., 196., 225.],
        [256., 289., 324., 361.]])
</code></pre><h5 id="矩阵降维"><a href="#矩阵降维" class="headerlink" title="矩阵降维"></a>矩阵降维</h5><ol>
<li>矩阵的按列降维和按行降维</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis1 = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(A_sum_axis0, A_sum_axis0.shape)</span><br><span class="line"><span class="built_in">print</span>(A_sum_axis1, A_sum_axis1.shape)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([40., 45., 50., 55.]) torch.Size([4])
tensor([ 6., 22., 38., 54., 70.]) torch.Size([5])
</code></pre><ol>
<li>求平均值，按平均值降维，矩阵数据必须是<code>dtype=torch.float32</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.mean(), A.mean(axis=<span class="number">0</span>), A.mean(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor(9.5000),
 tensor([ 8.,  9., 10., 11.]),
 tensor([ 1.5000,  5.5000,  9.5000, 13.5000, 17.5000]))
</code></pre><ol>
<li>非均值降维</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>,keepdim=<span class="literal">True</span>)</span><br><span class="line">A, sum_A, A/sum_A</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
 tensor([[ 6.],
         [22.],
         [38.],
         [54.],
         [70.]]),
 tensor([[0.0000, 0.1667, 0.3333, 0.5000],
         [0.1818, 0.2273, 0.2727, 0.3182],
         [0.2105, 0.2368, 0.2632, 0.2895],
         [0.2222, 0.2407, 0.2593, 0.2778],
         [0.2286, 0.2429, 0.2571, 0.2714]]))
</code></pre><h5 id="矩阵处理"><a href="#矩阵处理" class="headerlink" title="矩阵处理"></a>矩阵处理</h5><p>按列、行累加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A, A.cumsum(axis=<span class="number">0</span>), A.cumsum(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
 tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  6.,  8., 10.],
         [12., 15., 18., 21.],
         [24., 28., 32., 36.],
         [40., 45., 50., 55.]]),
 tensor([[ 0.,  1.,  3.,  6.],
         [ 4.,  9., 15., 22.],
         [ 8., 17., 27., 38.],
         [12., 25., 39., 54.],
         [16., 33., 51., 70.]]))
</code></pre><h4 id="2-3-4-点乘与乘法"><a href="#2-3-4-点乘与乘法" class="headerlink" title="2.3.4 点乘与乘法"></a>2.3.4 点乘与乘法</h4><h5 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h5><p>点乘等价于每个元素相乘并求和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.ones(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line"><span class="built_in">print</span>(torch.dot(x, y))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">sum</span>(x * y))</span><br></pre></td></tr></table></figure>
<pre><code>tensor(6.)
tensor(6.)
</code></pre><h5 id="矩阵-向量乘法"><a href="#矩阵-向量乘法" class="headerlink" title="矩阵-向量乘法"></a>矩阵-向量乘法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.mv(A, x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 14.,  38.,  62.,  86., 110.])
</code></pre><h5 id="矩阵-矩阵乘法"><a href="#矩阵-矩阵乘法" class="headerlink" title="矩阵-矩阵乘法"></a>矩阵-矩阵乘法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = torch.ones(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">torch.mm(A, B)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 6.,  6.,  6.],
        [22., 22., 22.],
        [38., 38., 38.],
        [54., 54., 54.],
        [70., 70., 70.]])
</code></pre><h4 id="2-3-5-范数"><a href="#2-3-5-范数" class="headerlink" title="2.3.5 范数"></a>2.3.5 范数</h4><h5 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h5><script type="math/tex; mode=display">
||x||_1 = \sum_{i=1}^{n}{|x_i|}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = torch.tensor([<span class="number">3.</span>, <span class="number">4.</span>, <span class="number">12.</span>])</span><br><span class="line">torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>tensor(19.)
</code></pre><h5 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h5><script type="math/tex; mode=display">
norm = ||x||_2 = \sqrt{\sum_{i=1}^{n}{x_i^2}}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.norm(u)</span><br></pre></td></tr></table></figure>
<pre><code>tensor(13.)
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>数学</tag>
        <tag>RoboMaster</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题解[模拟]P1065作业调度方案题解[NOIP2006提高组]</title>
    <url>/2023/05/20/P1065/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。</p>
<p>每个工件的每个工序称为一个操作，我们用记号 <code>j-k</code> 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 <code>2-4</code> 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。</p>
<p>例如，当 $n=3,m=2$ 时，<code>1-1,1-2,2-1,3-1,3-2,2-2</code> 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。</p>
<p>一方面，每个操作的安排都要满足以下的两个约束条件。</p>
<ol>
<li><p>对同一个工件，每道工序必须在它前面的工序完成后才能开始；</p>
</li>
<li><p>同一时刻每一台机器至多只能加工一个工件。</p>
</li>
</ol>
<p>另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。</p>
<p>由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 <code>1 1 2 3 3 2</code>。</p>
<p>还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。</p>
<p>例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>工件号　</th>
<th>工序$1$　　</th>
<th>工序$2$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td>$1/3$</td>
<td>$2/2$</td>
</tr>
<tr>
<td>$2$</td>
<td>$1/2$</td>
<td>$2/5$</td>
</tr>
<tr>
<td>$3$</td>
<td>$2/2$</td>
<td>$1/4$</td>
</tr>
</tbody>
</table>
</div>
<p>则对于安排顺序 <code>1 1 2 3 3 2</code>，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0pmzuibb.png" alt="">
　</p>
<p>当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件（$1$）（$2$）的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件（$1$）（$2$）的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。</p>
<p>显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行为两个正整数 $m$, $n$，用一个空格隔开，<br>（其中 $m(&lt;20)$ 表示机器数，$n(&lt;20)$ 表示工件数）</p>
<p>第 $2$ 行：$m \times n$ 个用空格隔开的数，为给定的安排顺序。</p>
<p>接下来的 $2n$ 行，每行都是用空格隔开的 $m$ 个正整数，每个数不超过 $20$。</p>
<p>其中前 $n$ 行依次表示每个工件的每个工序所使用的机器号，第 $1$ 个数为第 $1$ 个工序的机器号，第 $2$ 个数为第 $2$ 个工序机器号，等等。</p>
<p>后 $n$ 行依次表示每个工件的每个工序的加工时间。</p>
<p>可以保证，以上各数据都是正确的，不必检验。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 个正整数，为最少的加工时间。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 2 3 3 2</span><br><span class="line">1 2 </span><br><span class="line">1 2 </span><br><span class="line">2 1</span><br><span class="line">3 2 </span><br><span class="line">2 5 </span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>一道非常经典的模拟题，相当有阅读量与理解量。但是只要根据题目约束安排任务即可：</p>
<p>题目中有三个重要的约束：</p>
<ul>
<li>按照输入顺序依次安排任务</li>
<li>第i+1道工序的开始时间必须在第i道工序之后</li>
<li>如果某一间隔可以塞下这一工序，则直接放入，越早越好</li>
</ul>
<p>在数据上，我们需要得到在何时插入这个工序，定义为 <code>insert_time</code></p>
<p>那么大体上来说，代码结构为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = []; <span class="comment">// 工序数组</span></span><br><span class="line">    <span class="keyword">for</span> ...&#123; </span><br><span class="line">        cin ...</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若干预处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        insert_time = 第(i<span class="number">-1</span>)道工序结束的时间;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 遍历每一个区间并寻找到合适区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 数据的更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量设计"><a href="#变量设计" class="headerlink" title="变量设计"></a>变量设计</h3><p>根据题目的三个约束，这里定义两个数组：</p>
<ol>
<li><p>每个零件的最新进度：<code>work_time[]</code><br> 此数组的检索为零件序号，内容为这一零件的最新工序的结束时间。对于零件i，即有：</p>
<script type="math/tex; mode=display">insert\_time >= work\_time[i]</script></li>
<li><p>对于每个机器，定义其时间轴数组为: <code>time_line[a][b]</code><br> 此数组的检索a为机器型号，检索b为时间点，如果在机器a在第b秒需要为零件c工作，则记为：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">time_line[a][b] = c;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于输入的工序流程，需要知道的数据包括：这一步是为了哪个零件、这一步需要哪个机器以及这一步的用时是多少，所以对于每一个步骤这里都将整合在一个结构体中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">step</span>&#123;</span><br><span class="line">	<span class="type">int</span> t, id_m, id_i;	</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, step&gt; q;</span><br></pre></td></tr></table></figure>
<h3 id="关键步骤：找区间"><a href="#关键步骤：找区间" class="headerlink" title="关键步骤：找区间"></a>关键步骤：找区间</h3><p>附上本人代码边看边解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = insert_time;</span><br><span class="line"><span class="comment">// 定义区间初始位置</span></span><br><span class="line"><span class="type">int</span> have_work_point = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 定义工作位置标识 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="type">bool</span> isOk = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=s;j&lt;(s+q[i].t);j++)&#123;</span><br><span class="line">        <span class="comment">// 从空闲开头遍历这一工序需要的每一个时间</span></span><br><span class="line">   	    <span class="keyword">if</span>(time_line[q[i].id_m][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 时间轴上出现被占用的情况，不符合</span></span><br><span class="line">   		    have_work_point = j;</span><br><span class="line">            <span class="comment">// 标记在工作的时间，方便找到下一个空闲区间</span></span><br><span class="line">   		    isOk = <span class="literal">false</span>;</span><br><span class="line">   		    <span class="keyword">break</span>;</span><br><span class="line">   	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isOk)&#123;</span><br><span class="line">   	    insert_time = s;</span><br><span class="line">        <span class="comment">// 找到目标，就在空闲区间开始的位置插入新工序</span></span><br><span class="line">   	    <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   	    <span class="keyword">while</span>(time_line[q[i].id_m][have_work_point]!=<span class="number">0</span>)</span><br><span class="line">   		    have_work_point ++;</span><br><span class="line">   	    s = have_work_point;</span><br><span class="line">        <span class="comment">// 寻找下一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">step</span>&#123;</span><br><span class="line">	<span class="type">int</span> t, id_m, id_i;	</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, step&gt; q;</span><br><span class="line"><span class="type">int</span> time_line[<span class="number">25</span>][<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> work_time[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(m*n);i++)&#123;</span><br><span class="line">		cin &gt;&gt; q[i].id_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> machine_id[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			cin &gt;&gt; machine_id[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(m*n);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[j].id_i == i)&#123;</span><br><span class="line">				q[j].id_m = machine_id[flag];</span><br><span class="line">				flag ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> time_set[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			cin &gt;&gt; time_set[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(m*n);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[j].id_i == i)&#123;</span><br><span class="line">				q[j].t = time_set[flag];</span><br><span class="line">				flag ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//初始化，制作每一个步骤的结构体</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q.<span class="built_in">size</span>();i++)&#123; </span><br><span class="line">		<span class="type">int</span> insert_time = work_time[q[i].id_i];</span><br><span class="line">		<span class="type">int</span> s = insert_time;</span><br><span class="line">		<span class="type">int</span> have_work_point = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="type">bool</span> isOk = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=s;j&lt;(s+q[i].t);j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(time_line[q[i].id_m][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">					have_work_point = j;</span><br><span class="line">					isOk = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isOk)&#123;</span><br><span class="line">				insert_time = s;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(time_line[q[i].id_m][have_work_point]!=<span class="number">0</span>)&#123;</span><br><span class="line">					have_work_point ++;</span><br><span class="line">				&#125;</span><br><span class="line">				s = have_work_point;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=insert_time;j&lt;insert_time + q[i].t;j++)&#123;</span><br><span class="line">			time_line[q[i].id_m][j] = q[i].id_i;</span><br><span class="line">		&#125;</span><br><span class="line">		work_time[q[i].id_i] = insert_time + q[i].t; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(work_time[i] &gt; res) res = work_time[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试文件</category>
      </categories>
  </entry>
  <entry>
    <title>对2022的年度总结（二次元篇）</title>
    <url>/2022/12/31/final2022/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="我与二次元"><a href="#我与二次元" class="headerlink" title="我与二次元"></a>我与二次元</h2><p>因为疫情，很多二次元的展子都没了，很多平时暑假的例行活动都没了，希望明年还是可以去吧。</p>
<h3 id="二次元巡礼"><a href="#二次元巡礼" class="headerlink" title="二次元巡礼"></a>二次元巡礼</h3><h4 id="洛天依展"><a href="#洛天依展" class="headerlink" title="洛天依展"></a>洛天依展</h4><hr>
<ul>
<li>坐标：上海大悦城</li>
<li>时间：2022-07-19</li>
</ul>
<hr>
<p>算是第一次了解中国的虚拟歌姬洛天依了，虽然在很多场合还是带着一股“社会主义”，不过在国内的创作环境下也是难免的。不如说是很多平凡的国内小P主将洛天依的形式立体化，令人欣慰。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1851672472555_.pic.jpg" alt="洛天依开天神话"></p>
<p>从会场里把洛天依的手办买回来咯，就叫小傻吧。（图中左一）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1881672472695_.pic.jpg" alt=""></p>
<h4 id="动漫星城"><a href="#动漫星城" class="headerlink" title="动漫星城"></a>动漫星城</h4><hr>
<ul>
<li>坐标：广州 No.1, Jixiang Road</li>
<li>时间：2022-08-07</li>
</ul>
<hr>
<p>和群友去广州的目的地之一，广州动漫星城。（天气不太好，不过室内的地方为什么要在意天气呢）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1981672473491_.pic_hd.jpg" alt="动漫星城"></p>
<p>先看看群友最爱的米库女士吧</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1891672473290_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1961672473290_.pic.jpg" alt=""></p>
<p>Animate的看板娘涩谷香音</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1901672473290_.pic.jpg" alt=""></p>
<p>令人感慨，自己当时还看星团。现在是彻底裂啦——（开香槟咯）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1911672473290_.pic.jpg" alt=""></p>
<p>主播甚至买了几个诈骗货<br>（唐可可，没有你我怎么活——）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1951672473290_.pic.jpg" alt=""></p>
<p>买的时候掌柜还放着基本杂志，随便拿了一本发现东西还不少</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1941672473290_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1931672473290_.pic.jpg" alt=""></p>
<p>草……（怎么不见彩啊）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1921672473290_.pic.jpg" alt=""></p>
<p>总体来说成分很多，革命尚未成功…就当是小漫展来逛了吧！什么时候上海也能整一个大二次元集市啥的。</p>
<h4 id="邦多利咖啡厅"><a href="#邦多利咖啡厅" class="headerlink" title="邦多利咖啡厅"></a>邦多利咖啡厅</h4><hr>
<ul>
<li>坐标：上海市黄浦区思南公馆</li>
<li>时间：2022-09-05</li>
</ul>
<hr>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1991672474331_.pic.jpg" alt=""></p>
<p>想不到是在常去的思南公馆里面，本来以为只有一个思南书局，想不到里面的咖啡馆也值得一去。就是…感觉邦要倒了，可能是时间不对，进去了基本就没什么人。</p>
<p>山吹面包房（误）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2001672474331_.pic.jpg" alt=""></p>
<p>进了店还是一个屏幕几排座位，上面显然是社死打歌的。本来还是有点兴趣去搓一把的，发现上面是手机还没有防滑垫就不太想弄了。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2051672474331_.pic.jpg" alt=""></p>
<p>看看菜单，警惕消费陷阱</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2021672474331_.pic.jpg" alt=""></p>
<p>其实饮料还不错</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2041672474331_.pic.jpg" alt=""></p>
<p>冰淇淋嘛多少就有点抽象</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2071672474331_.pic.jpg" alt=""></p>
<p>好像拿走这个沙绫——</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2031672474331_.pic.jpg" alt=""></p>
<p>还是看看白葱吧</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2081672474434_.pic.jpg" alt=""></p>
<p>临走的时候从楼梯口下去的，看到橱窗是真不错。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2011672474331_.pic.jpg" alt=""></p>
<h4 id="社团招募的二次元"><a href="#社团招募的二次元" class="headerlink" title="社团招募的二次元"></a>社团招募的二次元</h4><hr>
<ul>
<li>坐标：UNNC</li>
<li>时间：2022-09-17</li>
</ul>
<hr>
<p>一些现视研的摊子</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2091672476493_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2111672476493_.pic.jpg" alt=""></p>
<p>捕捉野生自闭fu</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2101672476493_.pic.jpg" alt=""></p>
<p>看看术力口群的群HOMO吧</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2121672476493_.pic.jpg" alt=""></p>
<p>拉近一下镜头，先辈Suki！</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2131672477175_.pic.jpg" alt=""></p>
<h4 id="魔法未来十周年"><a href="#魔法未来十周年" class="headerlink" title="魔法未来十周年"></a>魔法未来十周年</h4><hr>
<ul>
<li>坐标：UNNC图书馆</li>
<li>时间：2022-10-23</li>
</ul>
<hr>
<p>魔法未来十周年观影会，术力口群组织策划</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2141672481700_.pic.jpg" alt=""></p>
<p>看看南小二的米库女士</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2161672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2151672481700_.pic.jpg" alt=""></p>
<p>被撅珍贵影像</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2201672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2191672481700_.pic.jpg" alt=""></p>
<p>专心致志的崇明前辈，十分甚至九分满意</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2171672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2181672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2231672481717_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2211672481700_.pic.jpg" alt=""></p>
<p>我看我自己</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2251672481717_.pic.jpg" alt=""></p>
<p>还有一张术力口群合影</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2221672481700_.pic.jpg" alt=""></p>
<h3 id="番剧动漫"><a href="#番剧动漫" class="headerlink" title="番剧动漫"></a>番剧动漫</h3><h4 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h4><p>上半年一直处于备考阶段，现在能回想起来比较深刻的应该是《罪恶王冠》、《白色相簿1》、《86-不存在的战区》、《鬼灭之刃游郭篇》、《夏日幻魂》、《Lovelive：Superstar》、《Lovelive：虹咲学园偶像》、《派对浪客诸葛孔明》</p>
<p>上半年冬天看的几部番可以说质量非常高，本人也是非常的看重。第一部要谈的就是《白色相簿1》</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/v2-69af0443fdb28d5336d42169419e2147_r.jpg" alt=""></p>
<blockquote>
<p>冬天的相簿总是如此洁白，让人心中不适。</p>
<p>冬日的街道，寒冷的风中，传来的歌声使人停住了脚步。</p>
<p>屏幕中，她在那头唱着歌。我在这头静静地看着。</p>
<p>冬季里的风，在我回大学的路上，一直吹着。</p>
<p>对我来说，这样的风，一直都是普通的。</p>
<p>至少，到现在为止，她过着她特别的生活，我过着我普通的生活。</p>
<p>我们没有一起被卷进什么事件中，自己过着自己的日子。</p>
</blockquote>
<p>白色相簿1讲述的是一个平凡的，无力的男主，在都市中，被一个个女神所围绕的故事。他没有做错什么，他只是一个无力的青年，试图去回应每一个人的期待，试图去进入另一个不属于他的世界。</p>
<p>动漫中对人物的刻画淋漓尽致，把人物在那个时代，用电话维持着交流，拿起听筒的不安与期待，每一封书信的寄出，却不知道是否能将心意传达的。</p>
<p>故事中，每个人的爱都是自私的，也是最真实的。每个人都在寻找着自己生活的寄托，而这也伤害了身边的人，人的成长更多的是找到自己所爱与被爱之间的平衡。这部动漫通过语言，画面和心理描写让人用心体会到角色中感受到那份难以割舍的感情与那个社会带来的无力感之间的矛盾。</p>
<p>接下来想说的是《罪恶王冠》吧。看完只有一个感觉，男主真帅，女主真好看，音乐真不错，ryo是神，很过瘾。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/18d8bc3eb13533fa9d3f2f32afd3fd1f41345b24.jpg" alt=""></p>
<p>这部番没有上一部那么严肃，但是谁不爱看中二少年拥有王之力后为了妹子奉献自我拯救世界呢。</p>
<p>很多人说这个烂尾了，但是在我心里就是最屌最帅的。</p>
<p>毕竟，那可是最中二的王之力啊。</p>
<h4 id="暑期档"><a href="#暑期档" class="headerlink" title="暑期档"></a>暑期档</h4><p>2022年暑假，也没有怎么看太多的番，现在能回忆起来的，多少是几部新番：《处刑少女的生存之道》、《夏日重现》、《辉夜大小姐第三季》、《朋友游戏》、《JOJO奇妙冒险：石之海》、《邪神与中二厨》、《少女歌剧剧场版》、《穿越时空的少女》</p>
<p>其实这里面没有哪一部真正想说的。虽然说夏日重现评分很高，但是前期过度的拉扯，后期的奇幻结局反而没有了石头门所达到的轮回系的高度。《辉夜三》很不错，真的能感受到制作组的用心，是一部非常优质的番（还是那句话，赤坂我杀你一千遍）。《JOJO》一如既往的高质量智斗，不过也就那样吧，吹完了前几部这个也依旧精彩。《邪神》夹心酱，非常用心的拍，非常用心的恰米，由于是众筹的，非常不容易，以高完成度为观众带来笑容，非常推荐。</p>
<h4 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h4><p>出圈的《莉可莉丝》以为下半年基本都没怎么看B站了。印象最深的还是隔离时候看的《心理测试者》。</p>
<p>（果然神番都离不开EGOIST）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1280px-Psycho_Pass_10th_Anniversary.jpg" alt=""></p>
<p>&gt;</p>
<blockquote>
<p>你看得到我们的颜色吗，西比拉系统？</p>
</blockquote>
<p>又是一部在乌托邦中思考正义与邪恶的故事，就像女主人公一样，“我痛斥这样的系统，可是我在生活中接受它的意义。”究竟该把正义交给一个数值，还是交给常规伦理自我意识的判断，是人类科技发展中无法绕开的问题。</p>
<blockquote>
<p>“是的，我不想无谓的死去，也承认现今社会很多人依赖Sibyl系统。但是，你们知道对本该神圣的法律，最不敬的做法是什么吗？那就是，创造并运行根本不值得保护的法律。不要太小看人类了。我们无时无刻都在努力创造更好的社会。终有一天会有人来到这个房间，拔出电源。我们一定会发现新的道路。Sibyl系统，你们没有未来！”</p>
</blockquote>
<h3 id="动漫音乐"><a href="#动漫音乐" class="headerlink" title="动漫音乐"></a>动漫音乐</h3><p>快和米库女士一周年了，列出今年最喜欢的几首动漫&amp;术力口吧。</p>
<ol>
<li>アンノウン・マザーグース 不为人知的鹅妈妈童谣</li>
<li>Grievous Lady(-nothing is but what is not-)</li>
<li>だれかの心臓になれたなら 如果能成为谁的心脏的话</li>
<li>Paper Bouquet 《处刑少女的生存之道》片头曲</li>
<li>祝福のメシアとアイの塔 祝福的救世主与爱之塔</li>
<li>ローリンガール 翻滚少女</li>
<li>ロミオとシンデレラ 罗密欧与灰姑娘</li>
<li>限りなく灰色へ 无尽的灰色</li>
<li>The Everlasting Guilty Crown</li>
<li>フユノ 冬野</li>
<li>Halcyon</li>
<li>I’m still alive today</li>
<li>冬之花</li>
<li>PRAGMATISM</li>
<li>名前のない怪物 无名怪物</li>
</ol>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2271672491609_.pic.jpg" alt=""></p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>二次元</tag>
        <tag>动漫</tag>
        <tag>初音未来</tag>
      </tags>
  </entry>
  <entry>
    <title>日式麻将个人技巧[持续更新中...]</title>
    <url>/2022/08/28/mahjong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<font color=FF7F50 size=6 >人，一定要有梦想

——献给每一个尝试国士无双的雀士们</font>


</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>说到日式麻将最大的特色，就是”役”的存在，役越多，和牌分数越高。日麻和牌简单，但是做大牌就需要一定的技巧以及耐心。我们在此不妨把一局分成两个阶段：做牌与防守。</p>
<h3 id="做牌"><a href="#做牌" class="headerlink" title="做牌"></a>做牌</h3><blockquote>
<p>不吃不碰才有大成长！</p>
<p>——作者本人</p>
</blockquote>
<p>做牌，就是做大牌，前提就是玩家要知道各种牌型，这里作者就介绍几种作者常用的牌型</p>
<h4 id="常见牌型"><a href="#常见牌型" class="headerlink" title="常见牌型"></a>常见牌型</h4><p>以下是作者推荐的比较容易记住的基本牌型</p>
<ul>
<li>断幺九[一番]：和牌时牌中不含有数字一九和东南西北白中发 <span class="heimu" title="你知道的太多了">新手雀士最爱</span></li>
<li>役牌[一番]：凑成刻子(三连)或杠子，可以碰；点数可叠加<ul>
<li>场风：即本场的风向（如东N局，南N局）</li>
<li>自风：玩家面前的风向</li>
<li>三元牌：白、中、发</li>
<li><span class="heimu" title="你知道的太多了">三元牌对越多越好，甚至能误打误撞做成小三元</li>
</ul>
</li>
<li>一杯口：一组相同的顺子<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/一杯口.png" alt=""></li>
<li>平和：和牌时只有顺子，雀头不能是自风或场风或三元牌</li>
<li>对对和[二番]:全是刻子、杠子<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/对对和.png" alt=""></li>
<li>七对子[二番]:七副对子(只能门前清)<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/七对子.png" alt=""></li>
<li>混一色[不吃不碰三番/二番]:同花色的牌+字牌</li>
<li>清一色[不吃不碰六番/五番]</li>
</ul>
<h4 id="立直"><a href="#立直" class="headerlink" title="立直"></a>立直</h4><p>如果牌太散无法凑出牌型，这里建议全程不吃不碰争取<strong>立直</strong>，即门前淸时，支付1000点宣告听牌，立直后只能暗杠与和牌。</p>
<h4 id="其他役"><a href="#其他役" class="headerlink" title="其他役"></a>其他役</h4><p>还有一些常见的役如:</p>
<ul>
<li>一发：立直后，在一巡内完成和牌。并且，期间不能有人的吃、碰、杠、拔北</li>
<li>岭上开花：杠后摸岭上牌补牌时自摸</li>
<li>海底捞月：自摸最后一张牌</li>
<li>河底摸鱼：和最后一张打出的牌</li>
</ul>
<p>都是麻将中的被动役，运气到了自然水到渠成，无需特意准备</p>
<h4 id="做牌心得"><a href="#做牌心得" class="headerlink" title="做牌心得"></a>做牌心得</h4><ol>
<li><p>发牌之后<br>快速理清自己不需要什么牌，如非场风非自风牌，不成对子的白中发，一和九（三麻中的万字）在换好牌后，重新审视自己的牌并确定方向</p>
</li>
<li><p>争取立直</p>
<p>在做牌中，如果追求只胜利和牌，在做牌中推荐：</p>
<blockquote>
<p>碰役牌&gt;断幺九/立直&gt;其他牌型</p>
</blockquote>
<p>如果追求大牌，由于立直可以和很多牌型配合，还是建议在听牌前不吃不碰</p>
</li>
<li><p>敢于想象</p>
<p>这一条适用于在做混一色或者七对子时，在做牌时如果手牌上是顺子，因为对于七对子来说对子就是完成任务，对于听顺子34，来牌无非就是2，3，4，5有效，而来了2或5顺子完成了，来了3或4对子就完成了，实际上凑对子的概率和顺子是相同的，为什么不走掉顺子换对子呢？</p>
<p> <span class="heimu" title="你知道的太多了">七对子甚至可以转对对和</p>
<p>在混一色中，如果其他色牌不需要，还是要耐心等待换牌，在途中可以吃碰，一心瞄准这一个目标。最坏就是一心防守分数不涨。</p>
</li>
</ol>
<h3 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h3><p>由于结算机制，我们可以发现，不和牌不可怕，可怕的是自己被和牌，只要不扣分，基本可以苟到第二，很多时候，优秀的防守比进攻更加重要</p>
<h4 id="立直防守"><a href="#立直防守" class="headerlink" title="立直防守"></a>立直防守</h4><p>上面作者非常支持大家去立直，但是如果场上已经有人立直的情况下，如果剩牌较少，可以碰碰运气，但剩余较多便不建议立直，毕竟立直意味着挂机，容易给别人和牌的同时被人防守，相对来讲，越早立直越好<span class="heimu" title="你知道的太多了">就像越早听牌越好一样这不是废话吗</p>
<h4 id="观察弃牌"><a href="#观察弃牌" class="headerlink" title="观察弃牌"></a>观察弃牌</h4><ol>
<li><p>由于任何玩家都不能和已经和过的牌，且在出牌过程中其他玩家也面临着这样的选择，要根据此记录对面不和什么牌</p>
</li>
<li><p>纵使可以从弃牌堆里看出对面大概不要什么类型的牌，也不能因此打出这一类的牌，要记住，100%的确定性永远比赌来的重要，如果已经到轮牌中后期（剩40%左右）哪怕拆开自己的牌型，为了防守也是值得的</p>
</li>
</ol>
<h4 id="中期换牌"><a href="#中期换牌" class="headerlink" title="中期换牌"></a>中期换牌</h4><p>在中期开始做牌时，如果发到已经打过较多的字牌（东南西北白中发）不妨留一手，这些牌在后期是较为保险不易被和的，借此甩掉一些用处不大的牌</p>
<h4 id="末期阶段"><a href="#末期阶段" class="headerlink" title="末期阶段"></a>末期阶段</h4><p>如果到了仅剩15张时还没有听牌，不妨放弃原有的思路，哪怕是振听也要将自己听牌，以免无人和牌后结算时被罚分</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>游戏毕竟是分数结算，所以不扣分其实就变成了胜利的关键。运气好就做大牌，运气不好不扣分，是计分游戏上分的关键。</p>
<p>祝愿大家早日国士无双！</p>
<p><br><br><br><br><br></p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>[1] 本文部分图文摘自日麻中文维基百科<a href="https://wiki.lingshangkaihua.com/mediawiki/index.php/役種表">https://wiki.lingshangkaihua.com/mediawiki/index.php/役種表</a></p>
]]></content>
      <categories>
        <category>个人心得</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>日式麻将</tag>
      </tags>
  </entry>
  <entry>
    <title>世界计划 COLORFUL LIVE 2nd - Will -</title>
    <url>/2023/01/10/PJSK2023Live/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<blockquote>
<font color=#39C5BB size=6 > 你的下一个MM，何必是MM </font>

</blockquote>
</blockquote>
<hr>
<h3 id="开场-成员介绍"><a href="#开场-成员介绍" class="headerlink" title="开场+成员介绍"></a>开场+成员介绍</h3><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LN:IN.png" alt="LN"></p>
<p>你游葱葱单推人来咯——</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MMJ:IN.png" alt="MMJ"></p>
<p>&gt;</p>
<blockquote>
<p>もっともっとたくさんの歌を！</p>
<p>もっともっとたくさんの元気を！</p>
<p>もっともっとたくさんの希望を！</p>
<p>もっともっとも～っとたくさんの人達に届けられるように！</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VBS:IN.png" alt="VBS"></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WS:IN.png" alt="WS"></p>
<blockquote>
<font color=#ff9900> 这是，为了「笑颜」而登上舞台的少年少女的故事—— </font>


</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/25时:IN.png" alt="25时"></p>
<p>真的是自闭4人组</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Miku:IN.png" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VL:IN.png" alt=""></p>
<hr>
<h3 id="上半场"><a href="#上半场" class="headerlink" title="上半场"></a>上半场</h3><h4 id="Leo-Need"><a href="#Leo-Need" class="headerlink" title="Leo/Need"></a>Leo/Need</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LN-1.png" alt=""></p>
<p>原创曲: Stage of sekai</p>
<p>翻唱曲: Calc</p>
<h4 id="More-More-Jump"><a href="#More-More-Jump" class="headerlink" title="More!More!Jump!"></a>More!More!Jump!</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MMJ-1.png" alt=""></p>
<p>原创曲: モア！ジャンプ！モア！</p>
<p>翻唱曲: 吸血鬼</p>
<h4 id="Vivid-BAD-SQUAD"><a href="#Vivid-BAD-SQUAD" class="headerlink" title="Vivid BAD SQUAD"></a>Vivid BAD SQUAD</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VBS-1.png" alt=""></p>
<p>原创曲: シネマ/电影</p>
<p>翻唱曲: echo</p>
<h4 id="Wonderlands×Showtime"><a href="#Wonderlands×Showtime" class="headerlink" title="Wonderlands×Showtime"></a>Wonderlands×Showtime</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WS-1.png" alt=""></p>
<p>原创曲: 不可思议的wonder</p>
<p>翻唱曲: 踊れオーケストラ</p>
<h4 id="25时，在Nightcord"><a href="#25时，在Nightcord" class="headerlink" title="25时，在Nightcord"></a>25时，在Nightcord</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/25时-1.png" alt=""></p>
<p>原创曲: 写作悔恨的未来</p>
<p>翻唱曲: フォニイ/phony</p>
<hr>
<h3 id="中场：千本樱"><a href="#中场：千本樱" class="headerlink" title="中场：千本樱"></a>中场：千本樱</h3><p><del>千本樱虽好，但SEGA能不能来点新的</del></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/V-1.png" alt=""></p>
<hr>
<h3 id="下半场"><a href="#下半场" class="headerlink" title="下半场"></a>下半场</h3><h4 id="Wonderlands×Showtime-1"><a href="#Wonderlands×Showtime-1" class="headerlink" title="Wonderlands×Showtime"></a>Wonderlands×Showtime</h4><p>翻唱曲：Telecaster B-Boy</p>
<p>原创曲：微笑调查队</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WS-2.png" alt=""></p>
<h4 id="More-More-Jump-1"><a href="#More-More-Jump-1" class="headerlink" title="More!More!Jump!"></a>More!More!Jump!</h4><p>原创曲：天使のクローバー</p>
<p>翻唱曲：心予報</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MMJ-2.png" alt=""></p>
<h4 id="Vivid-BAD-SQUAD-1"><a href="#Vivid-BAD-SQUAD-1" class="headerlink" title="Vivid BAD SQUAD"></a>Vivid BAD SQUAD</h4><p>原创曲：街</p>
<p>翻唱曲：黎明前线</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VBS-2.png" alt=""></p>
<h4 id="25时，在Nightcord-1"><a href="#25时，在Nightcord-1" class="headerlink" title="25时，在Nightcord"></a>25时，在Nightcord</h4><p>原创曲：Lower</p>
<p>翻唱曲：苦巧克力装饰</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/25时-2.png" alt=""></p>
<h4 id="Leo-Need-1"><a href="#Leo-Need-1" class="headerlink" title="Leo/Need"></a>Leo/Need</h4><p>翻唱曲：火花</p>
<p>原创曲：Stella</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LN-2.png" alt=""></p>
<hr>
<h3 id="返场"><a href="#返场" class="headerlink" title="返场"></a>返场</h3><h4 id="V家合唱：群青赞歌"><a href="#V家合唱：群青赞歌" class="headerlink" title="V家合唱：群青赞歌"></a>V家合唱：群青赞歌</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/V-2.png" alt=""></p>
<h4 id="队长曲：Journey"><a href="#队长曲：Journey" class="headerlink" title="队长曲：Journey"></a>队长曲：Journey</h4><p>撅撅撅撅你——</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/队长团-2.png" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/队长团-1.png" alt=""></p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>初音未来</tag>
        <tag>世界计划</tag>
        <tag>25时在夜电台</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的大学生活：初来UNNC</title>
    <url>/2022/09/13/nbndh/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="初来宁波"><a href="#初来宁波" class="headerlink" title="初来宁波"></a>初来宁波</h3><blockquote>
<p>宁波，取自“海定则波宁”，简称“甬”，早在周朝已有此称。“甬”字是古代大钟的一个象形字，在鄞、奉两县的县境上，山的峰峦很像古代的覆钟，故叫甬山，这条江就叫甬江，这一带地方就称为“甬”地。</p>
</blockquote>
<p>从上海前往宁波，若不是绕行杭州一带，直接走杭州湾跨海大桥，也就2小时左右。这一绕路，正逢中秋盛时天文大潮，虽没有到奔腾汹涌之势，一行白浪宛如千里雪骑，逆流而上，亦有浪遏飞舟之意。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2485.png" style="zoom:10%;" /></p>
<p>宁波分成老的市中心和东部新城，UNNC算是在南部的机场附近了。抵达宁波最大的感受是整个城市繁华却又不失人文的情怀。放眼城市，并不像上海一般高楼丛生，错中复杂，中间的老城区只能唉声叹气，等待着时代的淘汰，流离失所。宁波有展现其雄姿的高楼大厦，也有如欧洲小镇般的别墅街道，每走几个街道，就会有一个像样的公园点缀着生活。不得不说，宁波的城市干净，整洁，老建筑与新建筑融为一体，显得融洽。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2501.png" style="zoom:10%;" /></p>
<blockquote>
<p>宁波老外滩，坐落于浙江省宁波市江北区三江口（甬江、奉化江和余姚江的三江汇流之地）的北岸江北区，是进入宁波古城的门户。 在唐朝为中国四大港口之一，并成为鉴真东渡的起点；在南宋为中国三大港口之一，并设立市舶司专门负责管理对外贸易；当《南京条约》签订后，宁波便成为“五口通商”口岸之一，并于1844年正式开埠。</p>
</blockquote>
<p>正逢中秋，晚间来到了宁波的老外滩，据当地的同学说，这里难得有这么多人，岸边坐满了赏月拍照的人，无论哪里，无论城市与乡村，观赏天空永远能给予人们慰藉。宁波的外滩中，小巷里的酒吧永远是最热闹的，在江边吹着风，与友人喝上一杯，岂不美哉。再附上两张月亮的照片吧！</p>
<center class="half">
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2687.JPG" width="40%" />
    &emsp;
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2685.JPG" width="40%" />
</center>

<hr>
<h3 id="进入UNNC"><a href="#进入UNNC" class="headerlink" title="进入UNNC"></a>进入UNNC</h3><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2569.png" style="zoom:15%;" /></p>
<p>好吧，人很多，但是寝室楼真的很好看，进来了之后简单整理了一下</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_D288D71429C4-1.jpeg" style="zoom:30%;" /></p>
<p>太美丽了！感觉达到UNNC最高层。之后品鉴一下食堂，有空出一份食堂品鉴文章。</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>诺丁汉</tag>
      </tags>
  </entry>
  <entry>
    <title>主播降临原神必胜客餐厅</title>
    <url>/2022/09/01/opcomment/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>主播不是原p,主播不是原p,主播不是原p</p>
<h3 id="先来看看原P们的丑态"><a href="#先来看看原P们的丑态" class="headerlink" title="先来看看原P们的丑态"></a>先来看看原P们<span class="heimu" title="你知道的太多了">的丑态</span></h3><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2245.JPG" alt=""></p>
<blockquote>
<p>环球港必胜客餐厅</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/原1.png" alt=""></p>
<blockquote>
<p>瑞红坊必胜客餐厅</p>
</blockquote>
<h4 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h4><p>主播原来不是原P，在经友人推荐后<span class="heimu" title="你知道的太多了">强迫</span>前往了最新最潮的原神餐厅，当时是12点左右到的，餐厅门前已经挤满了人。在排队的过程中主播了解到很多人都是在10点前早早前往拿号。</p>
<p>在12点30左右，店家开始叫号（就是那种从01开始的那种）。主播看着自己手上的77号感觉有点崩溃</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/原2.png" alt=""></p>
<p>大概在1点半左右，主播做出重大决定，前往KFC先垫点吃的</p>
<blockquote>
<p>到达原P聚集处——必胜客</p>
<p>太美丽了吧必胜客</p>
<p>诶哟这不是KFC吗</p>
<p>还是看看手上的原味鸡吧</p>
</blockquote>
<p><span class="heimu" title="你知道的太多了"><del>必胜客你就是歌姬吧</del></span></p>
<p><span class="heimu" title="你知道的太多了">群友的攻击性好强</span></p>
<p>到了下午三点半，人越来越少，主播上前询问服务员：</p>
<blockquote>
<p>主播：您好，您看我这号还有机会吗</p>
<p>工作人员：您这个就像是一个癌症晚期患者说的话一样。他都已经这样了，你为什么不顺从他呢?你总要给人最后一段时间一个好的回忆吧，最后的时光里。因为60这个号很尴尬，50再往下一点，三十四十，可能说，欸，有点实力，能操作一下。80往上，九十一百，啊，人家是纯属混个号的，因为太遥远了，自己也知道自己没什么竞争力。但77，上不去下不来的这个号</p>
</blockquote>
<p><span class="heimu" title="你知道的太多了">原文：今天已经结束了，您肯定拍不到了，把号退了吧</span></p>
<p>然后主播就只能退号了</p>
<h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>主播写文章时，看到了很多网友们也是花了4个多小时等到了座位，体验了一番，其中有一句话令主播很是认可</p>
<blockquote>
<p>如果不是原，我真的不知道自己身边有必胜客</p>
</blockquote>
<p>在带动消费上，二次元市场在近年的表现可以说让人又爱又恨，“二次元真好骗”，利用ip似乎已经成为了许多抬高物价的脱罪例证。</p>
<p>这样的现象并不罕见，因为这就是漫展等一系列ip化活动的核心，但是这样的活动对于二次元来说，它的价值却也十分丰富。对于二次元来说，当一群同好相聚在一起的氛围，才是最难得可贵的。</p>
<p>实际上漫展本来的作用就是这个。就漫展里的那些东西，跟核心二次元几乎是八竿子打不着，几乎是毫无创意可言，平均质量还不如去淘宝周边店定制。为啥呢？因为会在漫展买东西的人，每年最关心二次元的那天可能就是来漫展的这一天，约上几个志同道好的朋友们，去漫展上品鉴着各式各样的IP，分享着当初看番的记忆，再象征性的砸一点钱，享受拿着痛包手办和一群二次元挤地铁的快乐。</p>
<hr>
<p><br></p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>如何看待必胜客中国将与游戏《原神》进行联动？ 作者：bow-car 链接：<a href="https://www.zhihu.com/question/539734598/answer/2650929206">https://www.zhihu.com/question/539734598/answer/2650929206</a> 来源：知乎</p>
]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>原神</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈PnP的算法原理与实践</title>
    <url>/2023/01/14/solvePnP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="PnP问题概述"><a href="#PnP问题概述" class="headerlink" title="PnP问题概述"></a>PnP问题概述</h3><p><strong>PnP (Perspective-n-Point)</strong> 是求解3D到2D点对运动的方法，目的是<strong>求解相机坐标系相对世界坐标系的位姿</strong>。已知n个3D点的坐标 (相对世界坐标系) 以及这些点的像素坐标时，如何估计相机的位姿(即求解世界坐标系到相机坐标系的旋转矩阵 $R$ 和平移向量 $t$ )</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义</th>
<th>表达符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>相对世界坐标</td>
<td>$P^W= \begin{bmatrix}X^W&amp;Y^W&amp;Z^W\end{bmatrix}^T$</td>
</tr>
<tr>
<td>相对相机坐标</td>
<td>$P^C= \begin{bmatrix}X&amp;Y&amp;Z\end{bmatrix}^T$</td>
</tr>
<tr>
<td>像素坐标（齐次化）</td>
<td>$P^{u,v}= \begin{bmatrix}u&amp;v&amp;1\end{bmatrix}^T$</td>
</tr>
<tr>
<td>归一化坐标</td>
<td>$P’= \begin{bmatrix}X\over{Z}&amp;Y\over{Z}&amp;1\end{bmatrix}^T$</td>
</tr>
<tr>
<td>相机内参</td>
<td>$K=\begin{pmatrix}f_x&amp;0&amp;c_x\\0&amp;f_y&amp;c_y\\0&amp;0&amp;1\end{pmatrix}$</td>
</tr>
<tr>
<td>深度信息</td>
<td>$ω = Z^C $</td>
</tr>
</tbody>
</table>
</div>
<p><strong>已知</strong>：n个点在<strong>世界坐标系</strong>下的坐标$P_1^W,P_2^W,…,P_n^W$，这些点相应在<strong>像素坐标系</strong>下的坐标$p_1^{u,v},p_2^{u,v},…,p_n^{u,v}$，相机<strong>内参</strong>矩阵 $K$。<strong>求解</strong>：<strong>相机坐标系相对于世界坐标系的位姿</strong>，即$P^C=R_{CW}×P_W+t_{WC}$中的$R_{CW}$和$t_{CW}$，或记作$T = \begin{bmatrix}R|T\end{bmatrix}$ </p>
<h3 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h3><h4 id="基本法则"><a href="#基本法则" class="headerlink" title="基本法则"></a>基本法则</h4><p>通过针孔相机模型，有以下公式：</p>
<script type="math/tex; mode=display">
\omega P^{u,v}=Z\begin{pmatrix}u\\v\\1\end{pmatrix}=\begin{pmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{pmatrix}\begin{pmatrix}X\\Y\\Z\end{pmatrix}=KP_C=KTP_W</script><p>对于$T=\begin{pmatrix}R|t\end{pmatrix}=\begin{pmatrix}t_1&amp;t_2&amp;t_3&amp;t_4\\t_5&amp;t_6&amp;t_7&amp;t_8\\t_9&amp;t_{10}&amp;t_{11}&amp;t_{12}\end{pmatrix}$ ，共有12个未知数，则至少需要6个点对来求解方程</p>
<h4 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h4><p>将物体的坐标减少一维处理：</p>
<script type="math/tex; mode=display">
P^C=\omega P'</script><script type="math/tex; mode=display">
P^C=(RP^W+t)=\begin{bmatrix}X&Y&Z\end{bmatrix}^T \rightarrow P'=\begin{bmatrix}X\over{Z}&Y\over{Z}&1\end{bmatrix}^T \overset{def}{=} \begin{bmatrix}u'&v'&1\end{bmatrix}^T</script><p>可以看作把点转化为$Z=1$这一平面上</p>
<h3 id="DLT方法（Direct-Linear-Transform）"><a href="#DLT方法（Direct-Linear-Transform）" class="headerlink" title="DLT方法（Direct Linear Transform）"></a>DLT方法（Direct Linear Transform）</h3><p>DLT是最直接求解PnP问题的方法，通过对线性等式进行化简，转化为线性方程组的形式求解变换矩阵</p>
<h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><ol>
<li><p>对等式进行化简：</p>
<script type="math/tex; mode=display">
\omega P^{u,v}=K\begin{bmatrix}R|t\end{bmatrix}P^W</script><script type="math/tex; mode=display">
\omega K^{-1}P^{u,v}=TP^W</script><script type="math/tex; mode=display">
\because wP^{u,v}=KP^C \therefore \omega K^{-1}P^{u,v} = P_C</script><script type="math/tex; mode=display">
P^C = TP^W</script></li>
<li><p>归一化处理：</p>
<script type="math/tex; mode=display">
P^C=\omega P'=TP^W \\
\omega \begin{pmatrix}u'\\v'\\1\end{pmatrix} = \begin{pmatrix}t_1&t_2&t_3&t_4\\t_5&t_6&t_7&t_8\\t_9&t_{10}&t_{11}&t_{12}\end{pmatrix} \begin{pmatrix}X^W\\Y^W\\Z^W\\1\end{pmatrix}</script><p>观察$u’和v’$ ，可以得到</p>
<script type="math/tex; mode=display">
\begin{cases}
u'=\frac{t_1X+t_2Y+t_3Z+t_4}{t_9X+t_{10}Y+t_{11}Z+t_{12}} \\
v'=\frac{t_5X+t_6Y+t_7Z+t_8}{t_9X+t_{10}Y+t_{11}Z+t_{12}}
\end{cases}</script><p>将转换矩阵$T$的行向量重新写为</p>
<script type="math/tex; mode=display">
t_{r1}=\begin{bmatrix}t_1\\t_2\\t_3\\t_4\end{bmatrix}\
t_{r1}=\begin{bmatrix}t_5\\t_6\\t_7\\t_8\end{bmatrix}\
t_{r1}=\begin{bmatrix}t_9\\t_{10}\\t_{11}\\t_{12}\end{bmatrix}</script><p>把上述方程组看作是向量点乘并且移项，化简；再写作为矩阵形式，由于$t_{r1},t_{r2},t_{r3}$为未知量，写成$At=0$</p>
<script type="math/tex; mode=display">
\begin{cases}
t_{r1}^T\ P^W - t_{r3}^T\ P^W\ u' = 0 \\
t_{r2}^T\ P^W - t_{r3}^T\ P^W\ v' = 0
\end{cases}
\iff
\begin{pmatrix}
P^{W\ T} & 0 & -u'^T\ P^W \\
0& P^{W\ T} & -v'^T\ P^W
\end{pmatrix}
\begin{pmatrix}
t_{r1} \\ t_{r2} \\ t_{r3}
\end{pmatrix}
=0</script></li>
<li><p>构造方程组</p>
<p>将n个点对代入上式，可以得到：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
P_1^{W\ T} & 0 & -u_1'^T\ P_1^W \\
0& P_1^{W\ T} & -v_1'^T\ P_1^W \\
\vdots & \vdots & \vdots \\
P_N^{W\ T} & 0 & -u_N'^T\ P_N^W \\
0& P_N^{W\ T} & -v_N'^{T}\ P_N^W 
\end{pmatrix}
\begin{pmatrix}
t_{r1} \\ t_{r2} \\ t_{r3}
\end{pmatrix}
=0</script><p>通过消元求解即可</p>
</li>
</ol>
<h4 id="多个点优化处理"><a href="#多个点优化处理" class="headerlink" title="多个点优化处理"></a>多个点优化处理</h4><p>$ t $一共有12维，最少通过6对匹配点即可实现增广矩阵$T=[R|t]$的线性求解。当匹配点的数量大于6对时，可以使用SVD等方法求超定方程的最小二乘解。针对SVD求超定方程的最小二乘解，说明如下：当匹配点数量大于6对时，可以获得一个在$|t|=1$约束下的最小二乘解$t^∗=argmint||At||$。具体的，令$A=UDV^T$，则最小二乘解$t^∗$为$V$的最后一列$t^v$，再利用SVD确定最优旋转矩阵近似以及相应的尺度，便可以确定最终的相机姿态</p>
<h3 id="实践：检测二维码与相机的相对位置"><a href="#实践：检测二维码与相机的相对位置" class="headerlink" title="实践：检测二维码与相机的相对位置"></a>实践：检测二维码与相机的相对位置</h3><p>在PnP问题中，如果把物体看作是世界坐标的原点，那么求解相机相对于世界坐标原点的位姿就等价于求解了相机与物体的相对位置。对于一个典型的PnP问题，可以利用<code>opencv4</code>中自带的<code>solvePnP()</code>函数实现，在实践中，需要获得物体的像素坐标，并且以物体为中心，建立世界坐标系。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/graph.png" alt=""></p>
<p>作者在实践中是在ROS系统中获取了Realsense D455摄像头的<code>topic</code>来获取的摄像头画面。以下代码都需要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br></pre></td></tr></table></figure>
<p>完整代码请见：<a href="https://github.com/Phoenizard/SolvePnP">https://github.com/Phoenizard/SolvePnP</a></p>
<h4 id="获取角点坐标"><a href="#获取角点坐标" class="headerlink" title="获取角点坐标"></a>获取角点坐标</h4><p>使用二维码的目的是为了更简便的获取二维码的角点数据（最小正接旋转矩形的四个顶点），利用<code>opencv4</code>中的<code>QRCodeDetector</code>内置对象，构造了一个二维码检测器，返回值为<code>vector&lt;cv::Point2f&gt;</code>类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Point2f&gt; <span class="title">get2DPoint</span><span class="params">(Mat rawImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRCodeDetector qrDecoder = <span class="built_in">QRCodeDetector</span>();</span><br><span class="line">    <span class="comment">// 构造二维码检测器</span></span><br><span class="line">    vector&lt;Point2f&gt; bbox;</span><br><span class="line">    qrDecoder.<span class="built_in">detect</span>(rawImage,bbox);</span><br><span class="line">    <span class="comment">// detect(src, output array) </span></span><br><span class="line">    <span class="comment">// output array可以为vector和Mat</span></span><br><span class="line">    <span class="keyword">if</span>(!bbox.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        string tag[<span class="number">4</span>] = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">line</span>(rawImage, bbox[i], bbox[(i+<span class="number">1</span>)%<span class="number">4</span>], <span class="built_in">Scalar</span>(<span class="number">124</span>,<span class="number">252</span>,<span class="number">0</span>),<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">            <span class="comment">// 绘制轮廓</span></span><br><span class="line">            <span class="built_in">putText</span>(rawImage, tag[i],bbox[i],FONT_HERSHEY_DUPLEX,<span class="number">2</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bbox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下，可以看到二维码被框出，系统输出四个角点坐标：</p>
<p><strong>注意是从左上顺指针输出角点坐标</strong></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/getPoint.jpeg" alt="getPoint" style="zoom:30%;" /></p>
<h4 id="构造世界坐标系"><a href="#构造世界坐标系" class="headerlink" title="构造世界坐标系"></a>构造世界坐标系</h4><p>由于二维码是2D的，以正方形的中心，二维码平面为$xy$平面建系，构造三维点集，用<code>vector&lt;cv::Point3f&gt;</code>存储，需要与得到的2d点一一对应。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_LENGTH 65</span></span><br><span class="line"><span class="comment">// 定义二维码边长的一边</span></span><br><span class="line"><span class="comment">// 注意：单位为毫米mm</span></span><br><span class="line">vector&lt;Point3f&gt; point_in_3d = vector&lt;Point3f&gt;&#123;</span><br><span class="line">            <span class="built_in">Point3f</span>(-HALF_LENGTH, HALF_LENGTH, <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">Point3f</span>(HALF_LENGTH, HALF_LENGTH, <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">Point3f</span>(HALF_LENGTH, -HALF_LENGTH, <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">Point3f</span>(-HALF_LENGTH, -HALF_LENGTH, <span class="number">0</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="调用solvePnP-函数"><a href="#调用solvePnP-函数" class="headerlink" title="调用solvePnP()函数"></a>调用solvePnP()函数</h4><p><code>solvePnP()</code> 在官方文档中为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solvePnP</span><span class="params">(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, <span class="type">bool</span> useExtrinsicGuess=<span class="literal">false</span>, <span class="type">int</span> flags = CV_ITERATIVE)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>InputArray objectPoints ：世界坐标系中点的三维坐标</li>
<li>InputArray imagePoints ：点的像素坐标</li>
<li>InputArray cameraMatrix ：相机内参</li>
<li>InputArray distCoeffs ：畸变系数</li>
<li>OutputArray rvec ：输出旋转矩阵</li>
<li>OutputArray tvec ：输出平移矩阵</li>
<li>useExtrinsicGuess ：仅用于<code>flags=SOLVEPNP_ITERATIVE</code>，此值如果为<code>true</code> 需要<code>rvec</code>和<code>tvec</code>有输入值，以便函数把输入值作为旋转和平移的估计初始值</li>
<li>flags ：求解方法，默认SOLVEPNP_ITERATIVE，可选SOLVEPNP_P3P、SOLVEPNP_EPNP等等</li>
</ul>
<p>由于技术条件限制，使用了BSSN在<a href="https://github.com/BSSNBSSN/Ego-plannerforIntelligentUAVChampionshipSimulator">Ego-plannerforIntelligentUAVChampionshipSimulator</a>库中的相机参数（同为Realsense D455摄像头）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Mat cameraMatrix = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt;</span><br><span class="line">        <span class="number">268.5118713378906</span>, <span class="number">0.0</span>,               <span class="number">320.0</span>,</span><br><span class="line">        <span class="number">0.0</span>,               <span class="number">268.5118713378906</span>, <span class="number">240.0</span>,</span><br><span class="line">        <span class="number">0.0</span>,               <span class="number">0.0</span>,               <span class="number">1.0</span></span><br><span class="line">    );</span><br><span class="line"><span class="type">const</span> Mat distCoeffs = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">5</span>, <span class="number">1</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>一般来说：解算PnP，最少需要4个物体点与其成像点构成的点对，直接使用solvePnP求解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubPuber::solvePnP2_3</span><span class="params">(vector&lt;Point2f&gt; pnt2d, vector&lt;Point3f&gt; obj3d, Mat rVec, Mat tVec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solvePnP</span>(obj3d, pnt2d, cameraMatrix, distCoeffs, rVec, tVec, <span class="literal">false</span>, SOLVEPNP_ITERATIVE);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;RVec&quot;</span> &lt;&lt; endl &lt;&lt; rVec &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tVec&quot;</span> &lt;&lt; endl &lt;&lt; tVec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用cmake编译"><a href="#利用cmake编译" class="headerlink" title="利用cmake编译"></a>利用cmake编译</h4><p>ROS统一运用<code>cmake</code>进行编译，重点在于调用<code>opencv4</code> </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(object-camera-transform)</span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  geometry_msgs</span><br><span class="line">  image_transport</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">catkin_package(</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(solvepnp2d3d src/solvepnp2d3d.cpp src/mainsolve2d3d.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(solvepnp2d3d</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>RoboMaster</tag>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈术力口与流量主义</title>
    <url>/2022/08/26/%E6%B5%85%E8%B0%88%E6%9C%AF%E5%8A%9B%E5%8F%A3%E4%B8%8E%E6%B5%81%E9%87%8F%E4%B8%BB%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在8月24日Sega推出了<a href="https://t.bilibili.com/697989416159805506">The Vocaloid Collection（缩写ボカコレ）×世界计划联动企划『ボカセカ』（Vocaseka）举办决定</a>，此项目旨在征集新术曲并通过排名给予实装，在B站的评论区还是多半好评，但是对术圈究竟能带来什么还是有待观察。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/6d04c9e00531030bc57d6333177e697213148307.png@2072w.png" alt=""></p>
<h3 id="V家发展"><a href="#V家发展" class="headerlink" title="V家发展"></a>V家发展</h3><p>在谈到本篇主题之前，还是有必要梳理一下近15年来V家的发展，这里作者参考了B站Vocaloid的故事</p>
<iframe src="//player.bilibili.com/player.html?aid=845275103&bvid=BV1354y1j7x5&cid=329109063&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>V家其实经历了<strong>兴起-&gt;百家争鸣-&gt;商业冲击-&gt;恢复期-&gt;现在</strong>，V家最原始的是P主对这方面的热爱，将自己的才华用音乐所寄托的平台，这其实和当下许多同好会组织团体是共同的，在2009年后，随着Deco27，wowaka，hachi为首的三巨头形成，V家进入了其黄金时代。</p>
<p>然而在2011-2013年，JIN(自然之敌P)的横空出世使得整个V家陷入黑暗。JIN创作了三首在相同世界观下的《人造敌人》，《目隐编码》，《阳炎眩乱》后，他将这一套称为<strong>阳炎计划</strong></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Mekakucityactors_2.jpeg" alt="阳炎计划"></p>
<p>接下来便是商业公司1st恰逢时机地找上他，希望jin能与其展开合作，使用最新推出的歌姬IA演唱接下来的“阳炎”系列的歌曲。双方一拍即合。</p>
<p>jin的调教与旋律固然优秀，但是注入了商业色彩的行为，短时间大量的播放量和收藏数、弹幕数，不科学的数据分差，使阳炎曲一出，周刊排名就陷入混乱。新曲占得头筹，以往的旧曲也将前十、前二十的名次一一占有，给其他P主的优秀的新曲腾出来的空间少之又少。最夸张的时候创作者投的新稿攒了一周的数据也赶不上jin最新阳炎曲一天刷出来的数据。V厨们纷纷开始指出“阳炎系列”就是炒作。</p>
<h3 id="V家的流量危机"><a href="#V家的流量危机" class="headerlink" title="V家的流量危机"></a>V家的流量危机</h3><p>在从初音未来10周年时，随着hachi与wowaka时隔多年的投稿，皮诺曹P摆脱“老二”荣登榜首，让V厨们看到了在一个黄金时代的曙光。然而在后续几年中，无论是新歌周报，还是魔法未来的选曲，老歌情怀或是名P地位成为了曲目受欢迎的量度，诚实的讲最近4年的新歌仍然无法打动许多听众。小众P主默默无闻，大P主发歌后好评如潮，已经成为当下V家可悲的现状。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/3song.png" alt=""></p>
<p>作者近期在某术力口群中和群主商讨过此事，虽然不确定是否属实，大P主也存在删评刷分等一系列的恶劣行径，当下的V家已经不在能去评论歌本身的好坏，而是成为了流量之上的商品产业。</p>
<p>此时我们不妨去看看世界计划这款游戏，本人认为它一定上推动了V家的发展，抛开那糟糕的调音不说，在2022年还能看到以V家为主题的质量手游还是十分令人欣慰的，相比于另一款Sega的冷饭王Hatsune Miku: Project DIVA，世界计划表现的十分亮眼，同时其新推出的原创曲，更是将众多新老时代的P主汇聚一堂，诞生了不少优质的新歌。</p>
<p>然而，作为商业游戏，游戏中不同团体角色的欢迎程度不可避免的产生了流量差异，从近期的歌曲MV排名就可以看出不平衡性，在消费者自发产生的流量环境下，歌曲本身的评判似乎就已经参杂了流量的要素。而当下推出的ボカコレ更让不少V厨为其捏一把汗，毕竟谁也不知道它会对当下的环境造成多少商业的冲击。</p>
<h3 id="流量文化与社会环境"><a href="#流量文化与社会环境" class="headerlink" title="流量文化与社会环境"></a>流量文化与社会环境</h3><p>抛开V圈不谈，流量文化就已经渗透入我们的生活，流量文化的合理性也正在逐渐的加深。我们总是说要去追求那束白月光，但又有谁愿意放弃那脚下的六便士，利益是驱动发展的永恒不变的源泉。我认为这是可悲的，因为我见过曾经V圈的繁荣，但是更可悲的是，又有谁可以真正拒绝了利益与流量，这种流量不止是创作者形成的，更是消费者产生的，当200余万播放量的《炉心融解》消失在了刷子的视野里，流量就已经在V圈埋下了隐患。</p>
<p>当作为个体或者小团体已经无法抵挡流量的时候，我们不妨可以联想到一个更现实的理论——凯恩斯主义，在面对一个圈子，更多去思考的是如何稳定流量，而非是发展，因为发展并不是直接符合上层人的利益的，政府可以是这样，而大P主们，也可以是这样。</p>
<p>庆幸的事，V圈磕磕碰碰，但也毕竟也是只有属于少数人的圈子，可悲的是，它正在走在一条流量至上的道路上，却没有改变的势头。在当下，我们缺的是什么，是优秀的P主吗，并不是。缺少的是一个可以自由的去评价歌曲本身的环境，我们无法改变或阻止流量的引入，因为这个当下发展的先决条件，但当流量变成了环境失衡的武器，混乱就会降临。</p>
<h3 id="永远要记得，音乐应是生活中最纯粹的声音"><a href="#永远要记得，音乐应是生活中最纯粹的声音" class="headerlink" title="永远要记得，音乐应是生活中最纯粹的声音"></a>永远要记得，音乐应是生活中最纯粹的声音</h3><p>因为初音未来只是款音乐软件，没有生命，所以感受不到世间的恶意，看不见世间的丑恶；正因为初音未来没有活着，没有感情，所以制作人才能将自己的感情融入到歌里，让她唱出P主们最真实的心声。 </p>
<blockquote>
<p>変わらぬ愛も　儚い恋も<br>不变的爱也好 脆弱的恋情也好</p>
<p>君からすれば　ただの記号で</p>
<p>在你看来不过是记号罢了</p>
<p>正義も悪も　帰らぬ日々も<br>正义也好邪恶也好 无法回去的日子也好</p>
<p>君の前では　どうでもよくて<br>在你面前 怎样都无所谓</p>
<p>ずっと　ずっと　君が生きてなくてよかった<br>一直 一直 你没有活着真是太好了</p>
<p>《君が生きてなくてよかった》</p>
</blockquote>
<p>愿大家在百忙之中，点一首术力口，听那由情感谱写的电子之声。</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>VOCALOID圈的故事 作者：贝伦先生 <a href="https://www.bilibili.com/read/cv1810505">https://www.bilibili.com/read/cv1810505</a> 出处：bilibili</p>
]]></content>
      <categories>
        <category>人世简谈</category>
      </categories>
      <tags>
        <tag>术力口</tag>
        <tag>VOCALOID</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/2022/08/23/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="v1-0"><a href="#v1-0" class="headerlink" title="[v1.0]-"></a>[v1.0]-<20220823></h3><ul>
<li>今天完成了一个最简陋的个人博客！</li>
<li>虽然这行字也是调试的一部分（）</li>
</ul>
<h3 id="v1-1"><a href="#v1-1" class="headerlink" title="[v1.1]-"></a>[v1.1]-<20220824></h3><ul>
<li>尝试了hexo-theme-matery，但并不太适应，做了一些基本设置</li>
</ul>
<h3 id="v2-0"><a href="#v2-0" class="headerlink" title="[v2.0]-"></a>[v2.0]-<20220825></h3><ul>
<li>将主题改为NexT</li>
<li>加入了字数统计，阅读时间</li>
<li>对Sideboard进行美化，设置了标签，头像</li>
<li>增加了最新最潮的背景图片与文本阴影</li>
<li>博客基本设置完成</li>
</ul>
<h3 id="v2-1"><a href="#v2-1" class="headerlink" title="[v2.1]-"></a>[v2.1]-<20220825></h3><ul>
<li>完善个人介绍界面</li>
<li>增加了Project Sekai数据库链接</li>
<li>测试文章中插入图片</li>
<li>修改模版</li>
<li>添加了文档压缩</li>
</ul>
<h3 id="v2-2"><a href="#v2-2" class="headerlink" title="[v2.2]-"></a>[v2.2]-<20220905></h3><ul>
<li>增加了月推界面</li>
<li>增加部分密码机制</li>
<li>数学公式支持</li>
</ul>
<h3 id="致谢链接"><a href="#致谢链接" class="headerlink" title="致谢链接"></a>致谢链接</h3><p><a href="https://siriusq.top/Next主题美化#博文压缩">Next主题美化</a></p>
]]></content>
      <categories>
        <category>测试文件</category>
      </categories>
  </entry>
  <entry>
    <title>pictureTest</title>
    <url>/2022/08/25/pictureTest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="先扔张成果图"><a href="#先扔张成果图" class="headerlink" title="先扔张成果图"></a>先扔张成果图</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/ena01.jpg" alt="ena"></p>
<h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>在想插入图片的时候，我一开始是非常不愿意使用图床等一系列第三方仓库的，首先想到的就是用相对路径。</p>
<p>网上最常用的解决方案就是将_config.yml 文件中的post_asset_folder 选项设为 true 来打开，然后利用随文章创建一同创建的同名文件夹插入图片。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>但是本方案在使用了<code>hexo d</code>后<code>public</code>中HTML文件上显示的相对路径却变成了乱码，无法读取图片(而且网上也基本没有这个问题可能是本人电脑的问题)</p>
<h4 id="PicGO图床"><a href="#PicGO图床" class="headerlink" title="PicGO图床"></a>PicGO图床</h4><blockquote>
<p>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</p>
</blockquote>
<p>PicGo 本体支持如下图床：</p>
<ul>
<li>七牛图床</li>
<li>腾讯云COS</li>
<li>又拍云</li>
<li>GitHub v1.5.0</li>
<li>SM.MS V2 v2.3.0-beta.0</li>
<li>阿里云 OSS v1.6.0</li>
<li>Imgur v1.6.0</li>
</ul>
<p>如果有条件的话非常推荐使用GitHub的仓库制作图床，但是国内网络的不支持使得图片的加载会出现很大的问题，这里也附上知乎上的<a href="https://www.zhihu.com/question/64502309">配置GitHub图床教程链接</a></p>
<p>其次就是利用国内平台如腾讯云阿里云等，这里我使用的是阿里云，<br><a href="https://blog.csdn.net/weixin_42030522/article/details/123075824&quot;CSDN解决Hexo无法显示图片的几种方案&quot;">配置阿里云图床</a>这篇文章具体的阐述了整个过程，可以参考。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>把自己的图片上传到第三方图床还是有点不放心的，但是也只能依赖大厂网站了；当时本来以为配置相对路径很容易，结果查来查去改了方案也配置了3个多小时。至此博客的基本要素都差不多配置完毕。最后啥也别说，先来一句：“<strong>SaKana——</strong>”</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/sakana.jpg" alt="sakana"></p>
]]></content>
      <categories>
        <category>测试文件</category>
      </categories>
      <tags>
        <tag>调试心得</tag>
      </tags>
  </entry>
  <entry>
    <title>晓山瑞希HappyBirthday</title>
    <url>/2022/08/27/mzkHappyBirthday/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<font color=#DDAACC size=6 >祝最可爱的MIZUKI生日快乐！</font>

</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2146.JPG" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2148.JPG" alt=""></p>
<p><span class="heimu" title="你知道的太多了">警惕网恋mzk被骗3000石(就是作者自己)</span></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2138.JPG" alt=""></p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>世界计划</tag>
        <tag>晓山瑞希</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈在惠普暗影精灵8下装Win11与Linux双系统</title>
    <url>/2022/09/19/%E8%A3%85%E6%9C%BA%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- <span class="heimu" title="你知道的太多了">的丑态</span> -->
<h3 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h3><ul>
<li>启动硬盘（windows11与Ubuntu20.3）</li>
<li>固态硬盘（主播使用的是致态TiPlus5000 1TB)</li>
<li>暗影精灵8pro</li>
</ul>
<h3 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a>拆机</h3><p>千万不要看什么网上用乱七八糟的教程，其实这款电脑非常好拆，前面的卡扣非常的紧，但是后方其实用手指甲就可以撬开来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2827.png" style="zoom: 25%;" /></p>
<p>然后在左侧固态槽上安装硬盘即可。</p>
<blockquote>
<p>建议断开电源后点击一下开机键放一下静电后再操作</p>
<p>但是不要忘记最后把电源线连上</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2818.png" alt=""></p>
<p>在安装好后把外壳扣上，不要急着拧螺丝，先按电源键看看可不可以正常开机后再拧紧螺丝</p>
<h3 id="装Win11"><a href="#装Win11" class="headerlink" title="装Win11"></a>装Win11</h3><blockquote>
<p>注：此步骤不是必要过程，主要是我这个买了1TB的盘不太忍心用来装Ubuntu，打算调换一下两个盘，因此要重装win11</p>
</blockquote>
<p>首先你需要一个启动硬盘，推荐一下<code>rufus</code>，虽然我不会用但是看学长用很方便。 </p>
<p>开机时按住F9就是启动选项栏，在插入硬盘之后选择从硬盘启动即可。</p>
<p>Win11有一个自动bitlocker的功能要记得关闭，否则会影响后续的Linux安装。如果无法直接关就先开启bitlocker然后再关闭。</p>
<p>在装机好后可能会出现没有网卡驱动的问题，这里需要借助另一台电脑在HP官网上下载网卡驱动然后进行安装，在有网络的情况下在设置中检查更新即可自动安装其他驱动。</p>
<h3 id="装Ubuntu"><a href="#装Ubuntu" class="headerlink" title="装Ubuntu"></a>装Ubuntu</h3><p>装机程序一致，按照流程来，在最后装机前要注意选择。在安装类型中选择第一个与windows boot manager共存（其可以先看看其他选项确认一下你要装的盘的位置然后再返回）</p>
<p>最后加一行这个<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><br>理论上就安装完毕了</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在安装完毕后，重启电脑，会自动在开机中弹出菜单，选择需要的系统即可</p>
]]></content>
      <categories>
        <category>机械硬件</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>调试心得</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV实现物体追踪</title>
    <url>/2023/01/20/KCF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="OpenCV实现物体追踪"><a href="#OpenCV实现物体追踪" class="headerlink" title="OpenCV实现物体追踪"></a>OpenCV实现物体追踪</h3><h4 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h4><p>通过Opencv内置函数实现物体追踪，并且部署在ROS中，实现摄像头读取。本文不涉及追踪算法的具体原理，而是针对RM中装甲板识别做出具体的实践部署。</p>
<p>具体项目已经部署在GitHUb：<a href="https://github.com/Phoenizard/Track-Image-InROS">https://github.com/Phoenizard/Track-Image-InROS</a></p>
<h4 id="追踪对象"><a href="#追踪对象" class="headerlink" title="追踪对象"></a>追踪对象</h4><p>使用opencv自带的追踪对象，需要调用一下头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/tracking.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/ocl.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在OpenCV中一共有7中追踪算法，分别是<code>BOOSTING</code>, <code>MIL</code>, <code>KCF</code>, <code>TLD</code> , <code>MEDIANFLOW</code>, <code>MOSSE</code>, <code>CSRT</code> ,在使用中选择最常见的<code>KCF</code>算法</p>
<h5 id="声明追踪对象"><a href="#声明追踪对象" class="headerlink" title="声明追踪对象"></a>声明追踪对象</h5><p>使用<code>creat()</code>构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yourtracker = TrackerKCF::<span class="built_in">create</span>();</span><br></pre></td></tr></table></figure>
<h5 id="初始化目标"><a href="#初始化目标" class="headerlink" title="初始化目标"></a>初始化目标</h5><p>使用<code>init(cv::Mat_flame,cv::Rect2d_object)</code>初始化</p>
<ul>
<li>Mat_flame：放入初始帧图片</li>
<li>Rect2d_object：放入目标在初始帧照片中的像素矩阵</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::Rect2d bbox;</span><br><span class="line">yourtracker-&gt;<span class="built_in">init</span>(flame, bbox);</span><br></pre></td></tr></table></figure>
<h5 id="更新目标"><a href="#更新目标" class="headerlink" title="更新目标"></a>更新目标</h5><p>使用<code>update(cv::Mat_flame,cv::Rect2d_object)</code> 更新当前帧</p>
<ul>
<li>Mat_flame：放入当前帧</li>
<li>Rect2d_object：放入上一帧目标矩形</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yourtracker-&gt;<span class="built_in">update</span>(flame, bbox);</span><br></pre></td></tr></table></figure>
<h5 id="判断目标丢失"><a href="#判断目标丢失" class="headerlink" title="判断目标丢失"></a>判断目标丢失</h5><p>算法将自动通过滤波匹配目标，<code>update()</code>函数在定义中为<code>bool</code>类型，如果目标丢失，返回值为<code>false</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> ok = yourtracker-&gt;<span class="built_in">update</span>(flame, bbox);</span><br><span class="line"><span class="keyword">if</span>(!ok) cout &lt;&lt; <span class="string">&quot;Track Lost&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>在RM中，追踪算法运用于装甲板的识别和追踪中，代码逻辑如下：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/KCF流程图.png" alt="KCL流程图" style="zoom:30%;" /></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>在ROS中，由于接受和发布照片在同一对象中完成，我们依然使用订阅和发布的模版对象SubPuber（自定义的对象）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubPuber</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ros::NodeHandle nodeHandle;</span><br><span class="line">    ros::Subscriber imgSub;</span><br><span class="line">    ros::Publisher trackobj;</span><br><span class="line">    <span class="comment">// Define Part</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubPuber</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        imgSub = nodeHandle.<span class="built_in">subscribe</span>(<span class="string">&quot;/camera/color/image_raw&quot;</span>, <span class="number">1</span>, &amp;SubPuber::ObjectTracker, <span class="keyword">this</span>);</span><br><span class="line">        trackobj = nodeHandle.<span class="built_in">advertise</span>&lt;sensor_msgs::Image&gt;(<span class="string">&quot;/tracker&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Initate Part</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ObjectTracker</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr &amp;frontRGBImg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Mat image;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            image = cv_bridge::<span class="built_in">toCvShare</span>(frontRGBImg, <span class="string">&quot;bgr8&quot;</span>)-&gt;image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert to image!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Program Part</span></span><br><span class="line">        sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, image).<span class="built_in">toImageMsg</span>();</span><br><span class="line">        trackobj.<span class="built_in">publish</span>(*msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以结合<code>ROS::spin();</code>即可实现循环。具体来说，当程序运行到ros::spin()的时候，会找到订阅和发布的API，并且<strong>循环订阅</strong>和<strong>发布</strong>两个动作 [注意：不会循环代码的其他部分，仅仅是订阅和发布]。</p>
<p>在主程序中，创建对象和<code>spin()</code> 即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略初始化节点</span></span><br><span class="line">    SubPuber tracker;</span><br><span class="line">    ROS::<span class="built_in">spin</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>观察代码，<code>Initate Part</code> 仅仅运行一遍，很适合创建追踪器，而在<code>Program Part</code> 可以把追踪的代码部署与此循环执行。补充代码如下：</p>
<p>由于作者手边没有装甲板信息，则使用<code>ROI</code>交互界面，通过手动框出矩形框初始化目标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define Part</span></span><br><span class="line">Ptr&lt;Tracker&gt; tracker; </span><br><span class="line">cv::Rect2d bbox; </span><br><span class="line"><span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initate Part</span></span><br><span class="line">tracker = TrackerKCF::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program Part</span></span><br><span class="line"><span class="keyword">if</span>(state == <span class="number">0</span>)&#123;</span><br><span class="line">    bbox = bbox = <span class="built_in">selectROI</span>(image, <span class="literal">false</span>);</span><br><span class="line">    tracker-&gt;<span class="built_in">init</span>(image,bbox);</span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">bool</span> ok = tracker-&gt;<span class="built_in">update</span>(image,bbox);</span><br><span class="line">    <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">        <span class="built_in">rectangle</span>(image, bbox, <span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">4</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;TrackLost&quot;</span> &lt;&lt; endl;</span><br><span class="line">        state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
</search>
