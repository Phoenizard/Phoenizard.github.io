<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>OpenCV实现物体追踪</title>
    <url>/2023/01/20/KCF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="OpenCV实现物体追踪"><a href="#OpenCV实现物体追踪" class="headerlink" title="OpenCV实现物体追踪"></a>OpenCV实现物体追踪</h3><h4 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h4><p>通过Opencv内置函数实现物体追踪，并且部署在ROS中，实现摄像头读取。本文不涉及追踪算法的具体原理，而是针对RM中装甲板识别做出具体的实践部署。</p>
<p>具体项目已经部署在GitHUb：<a href="https://github.com/Phoenizard/Track-Image-InROS">https://github.com/Phoenizard/Track-Image-InROS</a></p>
<h4 id="追踪对象"><a href="#追踪对象" class="headerlink" title="追踪对象"></a>追踪对象</h4><p>使用opencv自带的追踪对象，需要调用一下头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/tracking.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/ocl.hpp&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>在OpenCV中一共有7中追踪算法，分别是<code>BOOSTING</code>, <code>MIL</code>, <code>KCF</code>, <code>TLD</code> , <code>MEDIANFLOW</code>, <code>MOSSE</code>, <code>CSRT</code> ,在使用中选择最常见的<code>KCF</code>算法</p>
<h5 id="声明追踪对象"><a href="#声明追踪对象" class="headerlink" title="声明追踪对象"></a>声明追踪对象</h5><p>使用<code>creat()</code>构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yourtracker = TrackerKCF::<span class="built_in">create</span>();</span><br></pre></td></tr></table></figure>
<h5 id="初始化目标"><a href="#初始化目标" class="headerlink" title="初始化目标"></a>初始化目标</h5><p>使用<code>init(cv::Mat_flame,cv::Rect2d_object)</code>初始化</p>
<ul>
<li>Mat_flame：放入初始帧图片</li>
<li>Rect2d_object：放入目标在初始帧照片中的像素矩阵</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cv::Rect2d bbox;</span><br><span class="line">yourtracker-&gt;<span class="built_in">init</span>(flame, bbox);</span><br></pre></td></tr></table></figure>
<h5 id="更新目标"><a href="#更新目标" class="headerlink" title="更新目标"></a>更新目标</h5><p>使用<code>update(cv::Mat_flame,cv::Rect2d_object)</code> 更新当前帧</p>
<ul>
<li>Mat_flame：放入当前帧</li>
<li>Rect2d_object：放入上一帧目标矩形</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yourtracker-&gt;<span class="built_in">update</span>(flame, bbox);</span><br></pre></td></tr></table></figure>
<h5 id="判断目标丢失"><a href="#判断目标丢失" class="headerlink" title="判断目标丢失"></a>判断目标丢失</h5><p>算法将自动通过滤波匹配目标，<code>update()</code>函数在定义中为<code>bool</code>类型，如果目标丢失，返回值为<code>false</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> ok = yourtracker-&gt;<span class="built_in">update</span>(flame, bbox);</span><br><span class="line"><span class="keyword">if</span>(!ok) cout &lt;&lt; <span class="string">&quot;Track Lost&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>在RM中，追踪算法运用于装甲板的识别和追踪中，代码逻辑如下：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/KCF流程图.png" alt="KCL流程图" style="zoom:30%;" /></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>在ROS中，由于接受和发布照片在同一对象中完成，我们依然使用订阅和发布的模版对象SubPuber（自定义的对象）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubPuber</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ros::NodeHandle nodeHandle;</span><br><span class="line">    ros::Subscriber imgSub;</span><br><span class="line">    ros::Publisher trackobj;</span><br><span class="line">    <span class="comment">// Define Part</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SubPuber</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        imgSub = nodeHandle.<span class="built_in">subscribe</span>(<span class="string">&quot;/camera/color/image_raw&quot;</span>, <span class="number">1</span>, &amp;SubPuber::ObjectTracker, <span class="keyword">this</span>);</span><br><span class="line">        trackobj = nodeHandle.<span class="built_in">advertise</span>&lt;sensor_msgs::Image&gt;(<span class="string">&quot;/tracker&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Initate Part</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ObjectTracker</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr &amp;frontRGBImg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Mat image;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            image = cv_bridge::<span class="built_in">toCvShare</span>(frontRGBImg, <span class="string">&quot;bgr8&quot;</span>)-&gt;image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Could not convert to image!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Program Part</span></span><br><span class="line">        sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, image).<span class="built_in">toImageMsg</span>();</span><br><span class="line">        trackobj.<span class="built_in">publish</span>(*msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以结合<code>ROS::spin();</code>即可实现循环。具体来说，当程序运行到ros::spin()的时候，会找到订阅和发布的API，并且<strong>循环订阅</strong>和<strong>发布</strong>两个动作 [注意：不会循环代码的其他部分，仅仅是订阅和发布]。</p>
<p>在主程序中，创建对象和<code>spin()</code> 即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略初始化节点</span></span><br><span class="line">    SubPuber tracker;</span><br><span class="line">    ROS::<span class="built_in">spin</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>观察代码，<code>Initate Part</code> 仅仅运行一遍，很适合创建追踪器，而在<code>Program Part</code> 可以把追踪的代码部署与此循环执行。补充代码如下：</p>
<p>由于作者手边没有装甲板信息，则使用<code>ROI</code>交互界面，通过手动框出矩形框初始化目标</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define Part</span></span><br><span class="line">Ptr&lt;Tracker&gt; tracker; </span><br><span class="line">cv::Rect2d bbox; </span><br><span class="line"><span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initate Part</span></span><br><span class="line">tracker = TrackerKCF::<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program Part</span></span><br><span class="line"><span class="keyword">if</span>(state == <span class="number">0</span>)&#123;</span><br><span class="line">    bbox = bbox = <span class="built_in">selectROI</span>(image, <span class="literal">false</span>);</span><br><span class="line">    tracker-&gt;<span class="built_in">init</span>(image,bbox);</span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">bool</span> ok = tracker-&gt;<span class="built_in">update</span>(image,bbox);</span><br><span class="line">    <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">        <span class="built_in">rectangle</span>(image, bbox, <span class="built_in">Scalar</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>), <span class="number">4</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;TrackLost&quot;</span> &lt;&lt; endl;</span><br><span class="line">        state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>针对凸透镜应用于绘画语言的探究</title>
    <url>/2023/08/16/ConvexMirror/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在历史上，凸透镜一直作为光学仪器被人们所研究，早在亚里士多德时期，他就对凸透镜的成像原理做出过简单的定义；13世纪的阿拉伯世界，阿拉伯人使用凸透镜来制作放大镜。随后，在16世纪的欧洲，伽利略·伽利莱和约翰内斯·凯普勒等科学家对凸透镜的性质和成像原理进行了深入研究。在凸透镜的研制上，随着中世纪文艺复兴时期玻璃吹制的发展，当时的人已经可以用较低的成本制作出精确、平滑的凸透镜，随之而来的是凸透镜在装饰上以及科学领域的双向发展。在一边，欧洲的贵族家庭开始将凸透镜作为装饰品挂在墙上，另一侧，显微镜、望远镜等精密仪器的出现推动着人们踏入微观与宇宙的世界。</p>
<p>伴随着凸透镜制造技术的发展，凸透镜作为绘画语言开始兴起于艺术作品中：凡·艾克（<em>Jan van Eyck</em>）在1434年的《阿尔诺芬尼夫妇像》（<em>Arnolfini Portrait</em>）利用凸透镜将房间的背面展示出来；帕尔米贾尼诺（Parmigianino）在1524年对着凸透镜所作《透镜下的自画像》（<em>Self-portrait in a Convex Mirror</em>）；罗伯特·坎平（<em>Robert Campin</em>）在1438年的祭坛画《施洗者约翰》（<em>Saint John and donor</em>）等等。到了20世纪，澳大利亚肖像画师兰伯特（<em>George Washington Lambert</em>）也描绘一幅在透镜中的房间《凸透镜》（<em>The convex mirror</em>）。凸透镜在绘画中也成为一个重要的绘画语言。</p>
<p>虽然对于很多绘画，比如凡·艾克的《阿尔诺尼夫妇像》，已经有相当多的学者对凸透镜在画中的含义做出各自的解读，但是先前的分析还很少有对凸透镜这一个体对绘画艺术的宏观影响作出分析，此文章将凸透镜同时视为一个绘画工具与艺术元素进行探索：</p>
<ul>
<li>凸透镜作为光学工具对当时绘画方式的影响</li>
<li>凸透镜技巧在绘画中的含义，即艺术家使用凸透镜，相比于直接对平面作画，有何差异及用意</li>
<li>凸透镜对艺术家观察真实事物的改变</li>
</ul>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Parmigianino_Selfportrait.jpg" style="zoom:10%;" /></p>
<h3 id="凸透镜对绘画方式的影响"><a href="#凸透镜对绘画方式的影响" class="headerlink" title="凸透镜对绘画方式的影响"></a>凸透镜对绘画方式的影响</h3><blockquote>
<p>Vasari says, “Francesco one day set himself to take his own portrait, looking at himself for that purpose In a convex mirror, such as is used by barbers … He accordingly caused a ball of wood to be made By a turner, and having divided it in half and Brought it to the size of the mirror, he set himself With great art to copy all that he saw in the glass,” Chiefly his reflection, of which the portrait Is the reflection once removed</p>
</blockquote>
<p>文艺复兴时期艺术评论家瓦萨里曾经提到过帕尔米贾尼诺作《透镜中的自画像》这一情景，帕尔米贾尼诺在理发师的工坊里看到了一面凸透镜，于是他把手放在镜前观察着由透镜带来的视觉上的扭曲与放大感。过去有一位学者David G.Stork根据《透镜中的自画像》进行了计算机建模，他的模型根据瓦萨里对帕尔米贾尼诺的描述设计，建立了一个包括凸面镜在内的帕尔米贾尼诺工作室的完整计算机图形模型。凸面镜的曲率半径与木板支撑的曲率半径相匹配（符合瓦萨里后续对帕尔米贾尼诺看到的透镜的描述）。他发现画中的图像与从稍微重新定向和重新定位的镜子中绘制的简单的水平直线房间是一致的。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/computer_recover.png" alt=""></p>
<p>从他们的研究中我们可以发现：</p>
<ul>
<li>画家极有可能是对着凸面镜进行作画的，面向透镜的作画方式已经可以实现</li>
<li>窗户、天花板横梁的变形和位置，尤其是连接后墙和天花板的倾斜孤线，确实与艺术家的房间布局一致，符合光学扭曲</li>
</ul>
<p>除了帕尔米贾尼诺直接把凸透镜成的像作为绘画作品外，艺术家们还常常把成像作为另一个绘画空间，添加在画面中（如凡·艾克的《阿尔诺芬尼夫妇》）。事实上对于任何艺术家来说，在不用凸透镜的情况下把现实中的事物通过恰当的扭曲并且与透镜中呈现的光学现象完全一致几乎是不可能的。正因如此，凸透镜给予了画家机会去在原本的绘画平面中构造一层新的绘画空间，在过去艺术家也尝试过创造过多重视觉空间。荷兰画家格利特·窦（Gerard Dou）就常用障眼法来创造出特别的视觉效果，在他的一张自画像中，一个男人靠在窗台上，抽着烟斗看着我们。窦使用障眼法，创造了窗内和窗外两个空间，窗台上那本打开的书似乎从窗户伸到我们的空间里，挂在铜杆上的窗帘仿佛就在画外，一拉上就能把画面遮住。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Gerard_Dou_-_Self-Portrait_-_WGA06660.jpg" style="zoom:5%;" /></p>
<p>因而，利用凸透镜作画给予了画家一个全新的方式去创造一个新的空间，来进一步帮助他们展示其想表达的事物与意义。同时，凸透镜带来的真实的光学扭曲使得整个艺术作品跟有表现力。</p>
<h3 id="凸透镜技巧的应用鉴赏"><a href="#凸透镜技巧的应用鉴赏" class="headerlink" title="凸透镜技巧的应用鉴赏"></a>凸透镜技巧的应用鉴赏</h3><h4 id="扭曲手法的表现力"><a href="#扭曲手法的表现力" class="headerlink" title="扭曲手法的表现力"></a>扭曲手法的表现力</h4><p>如果说平面镜是对现实真实的还原，那么凸透镜就是对现实真实的“扭曲”与“放大”。关于扭曲，通过对画面的夸张或者扭曲来突出主题在艺术史上还是较为常见的，比如说爱德华·蒙克的《呐喊》或者卡拉瓦乔的《美杜莎》。在蒙克的《呐喊》中，大胆的扭曲将手法将所有线条似乎都趋向版画上惟一的中心——那个高声呼喊的如同骷髅般的头部，把人物的恐惧、焦虑与绝望通过这种类漫画式的模样表达出来，直击人心。而卡拉瓦乔的美杜莎虽然没有蒙克那样夸张，但也将美杜莎将死时的愤恨通过脸部表情的扭曲凸显出来，塑造了一幅骇人的面庞。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Caravaggio_-_Medusa_-_Google_Art_Project.jpg" style="zoom:8%;" /></p>
<p>凸透镜同样给予画家另一种观察扭曲、表达扭曲的方法。不同于《呐喊》或者《美杜莎》对一个细节的夸张（甚至是虚假、表现主义的夸张）与扭曲。凸透镜的成像是和谐的，现实主义的，却在这种写实中添加了魔幻色彩，夸张了原有的真实。宛如一个连接着真实与理想的桥梁，在和谐中给予了作者表达自我，超越真实的机会。让我们再说回帕米贾尼诺的《凸面镜的自画像》，艺术家刻意将自己的手放在镜前，并发生扭曲，是整个画面最引人注意的。有人推测，20岁的艺术家渴望得到人们的注意，表达自己的才华，便把自己的手作为重点，暗示自己的才华。在整个过程中，艺术家事实上是对镜中的像进行了复刻，在写实的同时利用透镜突出了“自我”这一主题。</p>
<h4 id="边缘虚化的失焦画法"><a href="#边缘虚化的失焦画法" class="headerlink" title="边缘虚化的失焦画法"></a>边缘虚化的失焦画法</h4><p>北方文艺复兴时期，暗箱可能成为辅助画家观察景物、绘制画面的工具。通过暗箱，艺术家可以更加直观的感受到光线对于现实物体的影响并相对准确的呈现在画面上中，更重要的是，暗箱成像如同照片一般会显示出画面中的焦点以及远处的失焦物体，因而在通过暗箱绘画物体时，艺术家往往会开始呈现出一部分的精确的聚焦与模糊的失焦。类比于暗箱，艺术家通过直接观察凸透镜的画面也可以观察到这一现象。在《凸面镜的自画像》中，可能是画面在岁月中产生的损害，也可能是艺术家有意为之，在画面的左上角，即窗户的位置，我们能明显的观察到玻璃是被模糊化的，而艺术家对自己形象的刻画，无论是画面的中心——人像以及那“巨大”的手，我们都能看到其细致的纹理，整个画面如同相片般聚焦在人物中央，光线从镜子到人像再到远处的窗户连成一线，真实的形成了人物的聚焦以及远处玻璃的失焦。在1916年兰伯特的《凸透镜》中，这一现象被描绘的更加显著，我们可以发现整个画面从左至右依次站着四个人物，从近到远，而这四个人的面容也相应的从清晰到模糊，将失焦这一现象准确的描绘了出来。</p>
<p>值得注意的是另一幅艺术作品，荷兰画家卡雷尔（Carel Fabritius）对代尔夫特一个街景的描绘《A View of Delft》，这幅画面尽管有人猜测这是艺术家面对这凸透镜对街道广角的绘制，但本文并不认可这样的观点，尽管画面呈现出类似于广角镜一样的视觉效果，但是我们可以看到从教堂往右方向，并没有像凸透镜般发生光学上的弯曲，如果把作品认定为透镜下的观察，笔直的树木以及房屋反而带来了一种突兀以及不和谐感。同时，不像上文所说，远处的房屋在放大后也清晰可辨，连窗户分造型都是精准清晰的，不符合对透镜失焦的表述。这幅画更有可能是利用了一种独特的透视手法，如同另一位荷兰艺术家Pieter Janssens Elinga在其作品《透视盒》（Perspective box）一样，是一种透视的表达。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_Convex_Mirror_(c_1916)_George_Washington_Lambert_002.jpg" style="zoom:25%;" /></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/FabritiusViewOfDelft.jpg" style="zoom:8%;" /></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>除了其在自然科学上的重要意义，凸透镜在艺术史上也发挥着自己的作用。通过研究，凸透镜已经逐渐成为文艺复兴时期艺术家使用的绘画语言以及工具，它给予了艺术家一种新的形式去创造艺术作品，提升了艺术作品的维度，开创了一个新式的在写实中表达抽象的艺术手段，在奇幻感中、扭曲的线条中提供了表现力。与此同时，凸透镜作为暗箱的前身，给予了艺术家对失焦这一概念的观察，绘画不一定将所有的物体都清晰准确的表达出来，还可以通过失焦来描述现实。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]  Criminisi A, Kemp M, Kang S B. Reflections of reality in Jan van Eyck and Robert Campin[J]. Historical Methods: A Journal of Quantitative and Interdisciplinary History, 2004, 37(3): 109-122.</p>
<p>[2]  D. Ekserdjian, Parmigianino, Yale University Press, New Haven, CT, 2006.</p>
<p>[3]  Gombrich E H, Gombrich E H. The story of art[M]. London: Phaidon, 1995.</p>
<p>[4]  Stork D G, Furuichi Y. Reflections on Parmigianino’s self portrait in a convex mirror: a computer graphics reconstruction of the artist’s studio[C]//Computer Vision and Image Analysis of Art. SPIE, 2010, 7531: 149-157.</p>
<p>[5]  Usami Y, Stork D G, Fujiki J, et al. Improved methods for dewarping images in convex mirrors in fine art: applications to van Eyck and Parmigianino[C]//Computer vision and Image analysis of art II. SPIE, 2011, 7869: 119-129.</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>西方艺术史</tag>
        <tag>凸透镜</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题解[模拟]P1065作业调度方案题解[NOIP2006提高组]</title>
    <url>/2023/05/19/P1065/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。</p>
<p>每个工件的每个工序称为一个操作，我们用记号 <code>j-k</code> 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 <code>2-4</code> 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。</p>
<p>例如，当 $n=3,m=2$ 时，<code>1-1,1-2,2-1,3-1,3-2,2-2</code> 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。</p>
<p>一方面，每个操作的安排都要满足以下的两个约束条件。</p>
<ol>
<li><p>对同一个工件，每道工序必须在它前面的工序完成后才能开始；</p>
</li>
<li><p>同一时刻每一台机器至多只能加工一个工件。</p>
</li>
</ol>
<p>另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。</p>
<p>由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 <code>1 1 2 3 3 2</code>。</p>
<p>还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。</p>
<p>例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>工件号　</th>
<th>工序$1$　　</th>
<th>工序$2$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$1$</td>
<td>$1/3$</td>
<td>$2/2$</td>
</tr>
<tr>
<td>$2$</td>
<td>$1/2$</td>
<td>$2/5$</td>
</tr>
<tr>
<td>$3$</td>
<td>$2/2$</td>
<td>$1/4$</td>
</tr>
</tbody>
</table>
</div>
<p>则对于安排顺序 <code>1 1 2 3 3 2</code>，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0pmzuibb.png" alt="">
　</p>
<p>当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件（$1$）（$2$）的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件（$1$）（$2$）的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。</p>
<p>显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行为两个正整数 $m$, $n$，用一个空格隔开，<br>（其中 $m(&lt;20)$ 表示机器数，$n(&lt;20)$ 表示工件数）</p>
<p>第 $2$ 行：$m \times n$ 个用空格隔开的数，为给定的安排顺序。</p>
<p>接下来的 $2n$ 行，每行都是用空格隔开的 $m$ 个正整数，每个数不超过 $20$。</p>
<p>其中前 $n$ 行依次表示每个工件的每个工序所使用的机器号，第 $1$ 个数为第 $1$ 个工序的机器号，第 $2$ 个数为第 $2$ 个工序机器号，等等。</p>
<p>后 $n$ 行依次表示每个工件的每个工序的加工时间。</p>
<p>可以保证，以上各数据都是正确的，不必检验。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$1$ 个正整数，为最少的加工时间。</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 2 3 3 2</span><br><span class="line">1 2 </span><br><span class="line">1 2 </span><br><span class="line">2 1</span><br><span class="line">3 2 </span><br><span class="line">2 5 </span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>一道非常经典的模拟题，相当有阅读量与理解量。但是只要根据题目约束安排任务即可：</p>
<p>题目中有三个重要的约束：</p>
<ul>
<li>按照输入顺序依次安排任务</li>
<li>第i+1道工序的开始时间必须在第i道工序之后</li>
<li>如果某一间隔可以塞下这一工序，则直接放入，越早越好</li>
</ul>
<p>在数据上，我们需要得到在何时插入这个工序，定义为 <code>insert_time</code></p>
<p>那么大体上来说，代码结构为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q = []; <span class="comment">// 工序数组</span></span><br><span class="line">    <span class="keyword">for</span> ...&#123; </span><br><span class="line">        cin ...</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若干预处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        insert_time = 第(i<span class="number">-1</span>)道工序结束的时间;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 遍历每一个区间并寻找到合适区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 数据的更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量设计"><a href="#变量设计" class="headerlink" title="变量设计"></a>变量设计</h3><p>根据题目的三个约束，这里定义两个数组：</p>
<ol>
<li><p>每个零件的最新进度：<code>work_time[]</code><br> 此数组的检索为零件序号，内容为这一零件的最新工序的结束时间。对于零件i，即有：</p>
<script type="math/tex; mode=display">insert\_time >= work\_time[i]</script></li>
<li><p>对于每个机器，定义其时间轴数组为: <code>time_line[a][b]</code><br> 此数组的检索a为机器型号，检索b为时间点，如果在机器a在第b秒需要为零件c工作，则记为：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">time_line[a][b] = c;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>对于输入的工序流程，需要知道的数据包括：这一步是为了哪个零件、这一步需要哪个机器以及这一步的用时是多少，所以对于每一个步骤这里都将整合在一个结构体中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">step</span>&#123;</span><br><span class="line">	<span class="type">int</span> t, id_m, id_i;	</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, step&gt; q;</span><br></pre></td></tr></table></figure>
<h3 id="关键步骤：找区间"><a href="#关键步骤：找区间" class="headerlink" title="关键步骤：找区间"></a>关键步骤：找区间</h3><p>附上本人代码边看边解释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = insert_time;</span><br><span class="line"><span class="comment">// 定义区间初始位置</span></span><br><span class="line"><span class="type">int</span> have_work_point = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 定义工作位置标识 </span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="type">bool</span> isOk = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=s;j&lt;(s+q[i].t);j++)&#123;</span><br><span class="line">        <span class="comment">// 从空闲开头遍历这一工序需要的每一个时间</span></span><br><span class="line">   	    <span class="keyword">if</span>(time_line[q[i].id_m][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 时间轴上出现被占用的情况，不符合</span></span><br><span class="line">   		    have_work_point = j;</span><br><span class="line">            <span class="comment">// 标记在工作的时间，方便找到下一个空闲区间</span></span><br><span class="line">   		    isOk = <span class="literal">false</span>;</span><br><span class="line">   		    <span class="keyword">break</span>;</span><br><span class="line">   	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isOk)&#123;</span><br><span class="line">   	    insert_time = s;</span><br><span class="line">        <span class="comment">// 找到目标，就在空闲区间开始的位置插入新工序</span></span><br><span class="line">   	    <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   	    <span class="keyword">while</span>(time_line[q[i].id_m][have_work_point]!=<span class="number">0</span>)</span><br><span class="line">   		    have_work_point ++;</span><br><span class="line">   	    s = have_work_point;</span><br><span class="line">        <span class="comment">// 寻找下一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> m,n,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">step</span>&#123;</span><br><span class="line">	<span class="type">int</span> t, id_m, id_i;	</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>, step&gt; q;</span><br><span class="line"><span class="type">int</span> time_line[<span class="number">25</span>][<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> work_time[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(m*n);i++)&#123;</span><br><span class="line">		cin &gt;&gt; q[i].id_i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> machine_id[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			cin &gt;&gt; machine_id[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(m*n);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[j].id_i == i)&#123;</span><br><span class="line">				q[j].id_m = machine_id[flag];</span><br><span class="line">				flag ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> time_set[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			cin &gt;&gt; time_set[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=(m*n);j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[j].id_i == i)&#123;</span><br><span class="line">				q[j].t = time_set[flag];</span><br><span class="line">				flag ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//初始化，制作每一个步骤的结构体</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q.<span class="built_in">size</span>();i++)&#123; </span><br><span class="line">		<span class="type">int</span> insert_time = work_time[q[i].id_i];</span><br><span class="line">		<span class="type">int</span> s = insert_time;</span><br><span class="line">		<span class="type">int</span> have_work_point = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="type">bool</span> isOk = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=s;j&lt;(s+q[i].t);j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(time_line[q[i].id_m][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">					have_work_point = j;</span><br><span class="line">					isOk = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isOk)&#123;</span><br><span class="line">				insert_time = s;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(time_line[q[i].id_m][have_work_point]!=<span class="number">0</span>)&#123;</span><br><span class="line">					have_work_point ++;</span><br><span class="line">				&#125;</span><br><span class="line">				s = have_work_point;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=insert_time;j&lt;insert_time + q[i].t;j++)&#123;</span><br><span class="line">			time_line[q[i].id_m][j] = q[i].id_i;</span><br><span class="line">		&#125;</span><br><span class="line">		work_time[q[i].id_i] = insert_time + q[i].t; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(work_time[i] &gt; res) res = work_time[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>伦勃朗与维米尔系列：Rembrandt In His Prime</title>
    <url>/2023/07/22/RembrandtInHisPrime/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Rembrandt-House.png" alt="Rembrandt House"></p>
<h4 id="Family-and-Daily-Life"><a href="#Family-and-Daily-Life" class="headerlink" title="Family and Daily Life"></a>Family and Daily Life</h4><p>到1640年，伦勃朗34岁，家庭的悲剧让他的绘画风格变得朴素与低沉。让他对家庭的表达从浮华的风格变为了深沉的情感表达。油画的尺寸也缩小了，充满了阴影与自然的力量伦勃朗和他的妻子萨斯其亚生有4个孩子，只有最小的一个存活，而他妻子在生孩子后不久去世(1942年)。在描绘家庭上，伦勃朗总能细腻的柔和的表达出家庭的温情。</p>
<h5 id="Woman-Asleep-Saskia"><a href="#Woman-Asleep-Saskia" class="headerlink" title="Woman Asleep(Saskia)"></a>Woman Asleep(Saskia)</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Woman-Asleep.png" alt="Woman Asleep" style="zoom:25%;" /></p>
<h5 id="Saskia-in-her-Room"><a href="#Saskia-in-her-Room" class="headerlink" title="Saskia in her Room"></a>Saskia in her Room</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Saskia-in-her-Room.png" alt="Saskia in her Room"></p>
<p>伦勃朗的小儿子，Titus van Rijn (22 September 1641 – 4 September 1668) 是唯一存活下来的，也是伦勃朗最疼爱的，伦勃朗从儿子出生开始就为其作画，记录儿子的成长：</p>
<h5 id="Titus-at-his-Desk"><a href="#Titus-at-his-Desk" class="headerlink" title="Titus at his Desk"></a>Titus at his Desk</h5><p>儿子13岁时的肖像</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Titus-at-his-Desk.png" alt="Titus at his Desk" style="zoom:25%;" /></p>
<h5 id="Titus-the-Artist’s-Son-Reading"><a href="#Titus-the-Artist’s-Son-Reading" class="headerlink" title="Titus, the Artist’s Son, Reading"></a>Titus, the Artist’s Son, Reading</h5><p>儿子15岁的肖像</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Titus-the-Artists-Son-Reading.png" alt="Titus, the Artist’s Son, Reading" style="zoom:25%;" /></p>
<h5 id="Titus-the-Artist’s-Son"><a href="#Titus-the-Artist’s-Son" class="headerlink" title="Titus, the Artist’s Son"></a>Titus, the Artist’s Son</h5><p>儿子16岁的肖像</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Titus-the-Artists-Son.png" alt="Titus, the Artist’s Son" style="zoom:25%;" /></p>
<h5 id="Titus-in-a-Monk’s-Habit"><a href="#Titus-in-a-Monk’s-Habit" class="headerlink" title="Titus in a Monk’s Habit"></a>Titus in a Monk’s Habit</h5><p>儿子19岁的肖像</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Titus-in-a-Monks-Habit.png" style="zoom:25%;" /></p>
<h4 id="Emulating-the-Masters"><a href="#Emulating-the-Masters" class="headerlink" title="Emulating the Masters"></a>Emulating the Masters</h4><p>伦勃朗一直在思考如何超越前人，在当时，超越前人的前提是效法大师的手法与技艺，效法分为三个阶段：</p>
<ul>
<li>Translatio 翻译：学习前人的作品，临摹，理解里面的技艺</li>
<li>Imitatio 模仿：在自己的作品中添加大师的元素</li>
<li>Contaminatio 杂糅：将各种技法整合在一起，发挥特色</li>
</ul>
<p>最后，发展出自己的风格，做到特立独行，引领时代。伦勃朗也效法了不少前人，比如丢勒、提香等文艺复兴大师。</p>
<h5 id="The-Pancake-Woman"><a href="#The-Pancake-Woman" class="headerlink" title="The Pancake Woman"></a>The Pancake Woman</h5><p>比如这幅《做煎饼的女人》，就是伦勃朗模仿荷兰画家阿德里安•布鲁维尔Adriaen Brouwer的手法</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Pancake-Woman.png" alt=""></p>
<h5 id="Self-Portrait-Leaning-on-a-Stone-Sill"><a href="#Self-Portrait-Leaning-on-a-Stone-Sill" class="headerlink" title="Self-Portrait: Leaning on a Stone Sill"></a>Self-Portrait: Leaning on a Stone Sill</h5><p>这幅自画像是伦勃朗模仿提香经典的“大袖子”</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Leaning-on-a-Stone-Sill.png" alt=""></p>
<h5 id="Self-Portrait-at-the-Age-of-34"><a href="#Self-Portrait-at-the-Age-of-34" class="headerlink" title="Self-Portrait at the Age of 34"></a>Self-Portrait at the Age of 34</h5><p>随后，伦勃朗还结合提香的大袖子和拉斐尔对织物的手法刻画，糅合出另一幅自画像：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Self-Portrait-at-34.png" alt=""></p>
<p>在伦勃朗36岁时，伦勃朗已经形成了自己别具一格的风格以及老练的手法，也就是在此时，他迎来了自己人生的转折点，迎来了最伟大的一幅作品，The Night Watch</p>
<h4 id="The-Night-Watch-夜巡"><a href="#The-Night-Watch-夜巡" class="headerlink" title="The Night Watch 夜巡"></a>The Night Watch 夜巡</h4><p>伦勃朗这次是受到火枪民兵队的委托，给18为火枪手民兵队画群像。夜巡这一名字来源于这幅画整体以灰暗色为主，但是据记载，民兵队从来没有在夜晚行动过。伦勃朗没有采用传统的横向布局，将人一一布置好位置。而是采用肖像与叙事结合的手法，来体现出火枪队这一传奇组织。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-night-watch.png" alt=""></p>
<p>在画面中，人的目光各不相同，先看看两位主角，罗姆波特中士(Sergeant Rombout Kemp)伸出右臂指向画面中央，将我们的视线引向最重要的人物。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Detail1-NW.png" style="zoom: 33%;" /></p>
<p>科克上尉的衣着精致，披一条红色的丝绸缎带，缎带的尾端在膝盖处飘摇。他的右手戴着手套，捏着一根手杖——象征着他的权威，左手向前伸出，好像已经要戳破画布，碰到你的脸，他摆出这个手势的意思好像是向身旁的中尉下达命令：整肃队伍，马上出发。</p>
<p>而他身旁的威廉中尉 (Lieutenant Willem van Ruytenburch） 白色的衣服在强光下泛着光泽，腰间系着一条白色缎带，带跟皮靴质感上佳。而伦勃朗在面中尉的时候遇到了一点小问题，他手中的长枪的尖端直直地指向画面外，角度太大以至于X光射线扫描局部发现伦勃朗在这里涂改过多次。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Detail2-NW.png" alt=""></p>
<p>在两人的左侧，有一位小姑娘在亮处。小女孩是光线集中的位置，金色裙子蓝色辉肩，与行会的标志配色一致，暗示着火枪行会，鸡爪也是民兵队的标志。</p>
<p>在小女孩的左侧，一位士兵好似刚刚放过枪，在为火枪填充弹药。而画面右侧的众人有一位正在瞄准目标，有一位拿着长戟指向前方，都好像预示着前方有一个危机需要民兵队去解除。</p>
<p>伦勃朗对持枪、装弹的刻画上也是有讲究的，他充分的了解两个东西的模样并精准的画了出来：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Detail4-NW.png" style="zoom:25%;" /></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Detail5-NW.png" style="zoom:25%;" /></p>
<p>画面里，每个人都不是静止的，伦勃朗为每个人都精心安排了一出戏剧，让他们展现自己的模样。你仿佛置身于此，感受一场民兵队传奇的出行。</p>
<p>由于光线较暗，且并不是按照传统的形式来做的群像，火枪手行会在收藏了这幅作品后，又聘请其他画家在画面的上方加了一个备注，来表示这是火枪行会的群像。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Detail3-NW.png" alt=""></p>
<p>伦勃朗从《夜巡》 身上获得的酬金是1800荷兰盾，这是一笔相当大的报酬，每100荷兰盾就相当于现在的1000美金。在这张人物与真人大小相近的巨幅油画中，伦勃朗将动态构圈、明暗对比、和身临其境的声效完美融合，定格了荷兰黄金时代的一个永恒瞬间。在如此多的人物和动作之间，伦勃朗得到了他所追求的和谐。这幅画，也成为了伦勃朗最举世闻名的代名词。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>西方美术史</tag>
        <tag>伦勃朗</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnAI</title>
    <url>/2023/01/19/LearnAI/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Chapter-1-引言"><a href="#Chapter-1-引言" class="headerlink" title="Chapter 1 引言"></a>Chapter 1 引言</h2><p>是时候系统学习一下人工智能了,希望什么时候可以补充一下引言吧</p>
<ul>
<li>设备环境：Linux-Ubuntu20.04</li>
<li>编译环境：miniconda</li>
</ul>
<h2 id="Chapter-2-预备知识"><a href="#Chapter-2-预备知识" class="headerlink" title="Chapter 2 预备知识"></a>Chapter 2 预备知识</h2><h3 id="2-1-数据处理"><a href="#2-1-数据处理" class="headerlink" title="2.1 数据处理"></a>2.1 数据处理</h3><h4 id="2-1-1-创建张量"><a href="#2-1-1-创建张量" class="headerlink" title="2.1.1 创建张量"></a>2.1.1 创建张量</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<p><strong>此处为torch,<del>虽然包叫pytorch</del></strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
</code></pre><p>张量：数组，但里面的内容都是数值，维度不限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([12])
</code></pre><p>通过<code>shape</code>可以查询张量的形状;[]代表维度为1，12代表这一维度的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x.numel()</span><br></pre></td></tr></table></figure>
<pre><code>12
</code></pre><p><code>numel()</code>可以访问张量中元素的总数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]])
</code></pre><p>通过<code>reshape(c,r)</code>,可以将张量重新排列成多维形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x.reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[6], line 1
----&gt; 1 y = x.reshape(4, 4)
      2 y


RuntimeError: shape &#39;[4, 4]&#39; is invalid for input of size 12
</code></pre><p>但重组时，col与row的乘积必须等于元素总数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = torch.zeros((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">o = torch.ones((<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(z, <span class="string">&#x27;\n&#x27;</span> ,o)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]],

        [[0., 0., 0., 0.],
         [0., 0., 0., 0.],
         [0., 0., 0., 0.]]]) 
 tensor([[[1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.]],

        [[1., 1., 1., 1.],
         [1., 1., 1., 1.]]])
</code></pre><p>使用<code>zeros()</code>构造全0矩阵，同理<code>ones()</code>, <del>没有除了1和0之外的数</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 1,  2,  3,  4],
        [ 5,  6,  7,  8],
        [ 9, 10, 11, 12]])
</code></pre><p>使用<code>tensor()</code>手动构造变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.2559,  0.4066,  0.4201, -1.1634],
        [-2.0670,  0.6678,  0.9912,  0.2923],
        [ 0.2710,  1.9265, -1.6423, -0.9642]])
</code></pre><p>生成随机数张量，元素平均数为0，标准差为1的正态分布中随机采样</p>
<h4 id="2-1-2-张量运算"><a href="#2-1-2-张量运算" class="headerlink" title="2.1.2 张量运算"></a>2.1.2 张量运算</h4><h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>,<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">y = torch.tensor([<span class="number">2</span>,  <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">x+y,x-y,x*y,x/y,x**y,x%y</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([ 3.,  5.,  8., 13.]),
 tensor([-1., -1.,  0.,  3.]),
 tensor([ 2.,  6., 16., 40.]),
 tensor([0.5000, 0.6667, 1.0000, 1.6000]),
 tensor([1.0000e+00, 8.0000e+00, 2.5600e+02, 3.2768e+04]),
 tensor([1., 2., 0., 3.]))
</code></pre><p>对于相同形状的张量，可以通过(+,-,*,/,%)作运算，具体来说：$I+J \rightarrow I_i+J_i$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">x = torch.tensor([numpy.e,numpy.log(<span class="number">2</span>),<span class="number">1</span>,torch.e])</span><br><span class="line">torch.exp(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([15.1543,  2.0000,  2.7183, 15.1543], dtype=torch.float64)
</code></pre><p><code>exp()</code>求解e的x次方：$y_i=e^{x_i}$</p>
<h5 id="张量拼接"><a href="#张量拼接" class="headerlink" title="张量拼接"></a>张量拼接</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">torch.cat((x,y),dim=<span class="number">0</span>), torch.cat((x,y),dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11],
         [ 2,  1,  4,  3],
         [ 1,  2,  3,  4],
         [ 4,  3,  2,  1]]),
 tensor([[ 0,  1,  2,  3,  2,  1,  4,  3],
         [ 4,  5,  6,  7,  1,  2,  3,  4],
         [ 8,  9, 10, 11,  4,  3,  2,  1]]))
</code></pre><p>通过<code>cat()</code>可以实现拼接，<code>dim=0</code>按照行，<code>dim=1</code>按列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]])</span><br><span class="line">torch.cat((x,y),dim=<span class="number">0</span>), torch.cat((x,y),dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[13], line 3
      1 x = torch.arange(12).reshape((3,4))
      2 y = torch.tensor([[2,1,4],[1,2,3],[4,3,2]])
----&gt; 3 torch.cat((x,y),dim=0), torch.cat((x,y),dim=1)


RuntimeError: Sizes of tensors must match except in dimension 0. Expected size 4 but got size 3 for tensor number 1 in the list.
</code></pre><p>若尺寸不对应则会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = torch.tensor([[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">x == y</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[False,  True, False,  True],
        [False, False, False, False],
        [False, False, False, False]])
</code></pre><p>近似于求位与运算</p>
<h5 id="元素求和"><a href="#元素求和" class="headerlink" title="元素求和"></a>元素求和</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">torch.<span class="built_in">sum</span>(x), x.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>(tensor(66), tensor(66))
</code></pre><h5 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.arange(<span class="number">3</span>).reshape((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">b = torch.arange(<span class="number">2</span>).reshape((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0, 1],
        [1, 2],
        [2, 3]])
</code></pre><p>试试多维，有点废脑子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([ [ [<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>] ] ,[[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>] ] ])</span><br><span class="line">y = torch.tensor([ [ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] ])</span><br><span class="line">x,y,x+y</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[[1],
          [1],
          [1]],

         [[2],
          [3],
          [4]]]),
 tensor([[[1, 2, 3]]]),
 tensor([[[2, 3, 4],
          [2, 3, 4],
          [2, 3, 4]],

         [[3, 4, 5],
          [4, 5, 6],
          [5, 6, 7]]]))
</code></pre><h5 id="张量切片"><a href="#张量切片" class="headerlink" title="张量切片"></a>张量切片</h5><p>按行切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">x,x[-<span class="number">1</span>],x[<span class="number">2</span>],x[<span class="number">0</span>:<span class="number">2</span>],x[<span class="number">0</span>:<span class="number">3</span>],x[<span class="number">0</span>:-<span class="number">1</span>],x[:-<span class="number">1</span>],x[:],x[:<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]),
 tensor([ 8,  9, 10, 11]),
 tensor([ 8,  9, 10, 11]),
 tensor([[0, 1, 2, 3],
         [4, 5, 6, 7]]),
 tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]),
 tensor([[0, 1, 2, 3],
         [4, 5, 6, 7]]),
 tensor([[0, 1, 2, 3],
         [4, 5, 6, 7]]),
 tensor([[ 0,  1,  2,  3],
         [ 4,  5,  6,  7],
         [ 8,  9, 10, 11]]),
 tensor([], size=(0, 4), dtype=torch.int64))
</code></pre><p>自定义切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">x[:,<span class="number">1</span>] , x[<span class="number">1</span>:<span class="number">3</span>,<span class="number">1</span>:] , x[<span class="number">0</span>::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>], x[<span class="number">0</span>::<span class="number">2</span>,<span class="number">0</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([1, 5, 9]),
 tensor([[ 5,  6,  7],
         [ 9, 10, 11]]),
 tensor([[ 1,  3],
         [ 9, 11]]),
 tensor([[ 0,  2],
         [ 8, 10]]))
</code></pre><p><code>a:b:c</code>,在区间[a,b)中取数，step=c,a,c默认为0，b默认最后一位</p>
<h5 id="暴力写入"><a href="#暴力写入" class="headerlink" title="暴力写入"></a>暴力写入</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[<span class="number">1</span>, <span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0,  1,  2,  3],
        [ 4,  5,  9,  7],
        [ 8,  9, 10, 11]])
</code></pre><h5 id="内存节省"><a href="#内存节省" class="headerlink" title="内存节省"></a>内存节省</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">4</span>)</span><br><span class="line">before = <span class="built_in">id</span>(y)</span><br><span class="line">y = y + x</span><br><span class="line"><span class="built_in">id</span>(y) == before</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p>在处理变量中，一般操作会导致新建内存，如果矩阵数据特别大，容易消耗内存,可以使用原地存储</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">4</span>)</span><br><span class="line">before = <span class="built_in">id</span>(y)</span><br><span class="line">y += x</span><br><span class="line"><span class="built_in">id</span>(y) == before</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

Cell In[22], line 3
      1 y = torch.arange(4)
      2 before = id(y)
----&gt; 3 y += x
      4 id(y) == before


RuntimeError: output with shape [4] doesn&#39;t match the broadcast shape [3, 4]
</code></pre><h5 id="类型互换"><a href="#类型互换" class="headerlink" title="类型互换"></a>类型互换</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">4</span>)</span><br><span class="line">x = torch.arange(<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line">z = torch.zeros_like(y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(z):&#x27;</span>,<span class="built_in">id</span>(z))</span><br><span class="line">z[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;id(z):&#x27;</span>,<span class="built_in">id</span>(z))</span><br></pre></td></tr></table></figure>
<pre><code>id(z): 140157950377472
id(z): 140157950377472
</code></pre><p>Pytorch与Numpy的互换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = x.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">type</span>(A),<span class="built_in">type</span>(B)</span><br></pre></td></tr></table></figure>
<pre><code>(numpy.ndarray, torch.Tensor)
</code></pre><p>将大小为1的张量转化为python标量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a,a.item(),<span class="built_in">float</span>(a),<span class="built_in">int</span>(a)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([3.5000]), 3.5, 3.5, 3)
</code></pre><h3 id="2-2数据预处理"><a href="#2-2数据预处理" class="headerlink" title="2.2数据预处理"></a>2.2数据预处理</h3><h4 id="2-2-1-生成数据集文件"><a href="#2-2-1-生成数据集文件" class="headerlink" title="2.2.1 生成数据集文件"></a>2.2.1 生成数据集文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>创建CSV文件：房价数据-房间数量/巷子类型/价格</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure>
<pre><code>   NumRooms Alley   Price
0       NaN  Pave  127500
1       2.0   NaN  106000
2       4.0   NaN  178100
3       NaN   NaN  140000
</code></pre><p>运用pandas库读取csv</p>
<h4 id="2-2-2-补充丢失数据"><a href="#2-2-2-补充丢失数据" class="headerlink" title="2.2.2 补充丢失数据"></a>2.2.2 补充丢失数据</h4><p>补充丢失数据的典型方法是插值法和删除法</p>
<ul>
<li>插值法：用一个数字替代缺失位</li>
<li>删除法：直接忽略缺少的数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs, outputs = data.iloc[:,<span class="number">0</span>:<span class="number">2</span>], data.iloc[:, <span class="number">2</span>]</span><br><span class="line">inputs = inputs.fillna(inputs.mean())</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<pre><code>   NumRooms Alley
0       3.0  Pave
1       2.0   NaN
2       4.0   NaN
3       3.0   NaN
</code></pre><p>在补充房间数，使用插值法，通过插入已知数的平均值补充未知数，<code>input.mean()</code>读取数据平均数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inputs = pd.get_dummies(inputs,dummy_na=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(inputs)</span><br></pre></td></tr></table></figure>
<pre><code>   NumRooms  Alley_Pave  Alley_nan
0       3.0           1          0
1       2.0           0          1
2       4.0           0          1
3       3.0           0          1
</code></pre><p>在补充巷子时，看成是有Pave为1，无为0的矩阵形式</p>
<h4 id="2-2-3-转化为张量形式"><a href="#2-2-3-转化为张量形式" class="headerlink" title="2.2.3 转化为张量形式"></a>2.2.3 转化为张量形式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.tensor(inputs.values)</span><br><span class="line">y = torch.tensor(outputs.values)</span><br><span class="line"></span><br><span class="line">x,y</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[3., 1., 0.],
         [2., 0., 1.],
         [4., 0., 1.],
         [3., 0., 1.]], dtype=torch.float64),
 tensor([127500, 106000, 178100, 140000]))
</code></pre><p>利用<code>tensor()</code>构造张量</p>
<h4 id="实例：删除空数据最多的一列"><a href="#实例：删除空数据最多的一列" class="headerlink" title="实例：删除空数据最多的一列"></a>实例：删除空数据最多的一列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">count_max = <span class="number">0</span></span><br><span class="line">labels = [<span class="string">&#x27;NumRooms&#x27;</span>,<span class="string">&#x27;Alley&#x27;</span>,<span class="string">&#x27;Price&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> labels:</span><br><span class="line">    count = data[label].isna().<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">if</span> count &gt; count_max:</span><br><span class="line">        count_max = count</span><br><span class="line">        flag = label</span><br><span class="line">data_new = data.drop(flag,axis=<span class="number">1</span>)</span><br><span class="line">data_new</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>NumRooms</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NaN</td>
<td>127500</td>
</tr>
<tr>
<td>1</td>
<td>2.0</td>
<td>106000</td>
</tr>
<tr>
<td>2</td>
<td>4.0</td>
<td>178100</td>
</tr>
<tr>
<td>3</td>
<td>NaN</td>
<td>140000</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3-线性代数"><a href="#2-3-线性代数" class="headerlink" title="2.3 线性代数"></a>2.3 线性代数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-标量"><a href="#2-3-1-标量" class="headerlink" title="2.3.1 标量"></a>2.3.1 标量</h4><p>虽然直接声明常量更为常见，但是<code>torch</code>也支持创建标量，即长度为1的一维张量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor(<span class="number">3.0</span>)</span><br><span class="line">y = torch.tensor(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-向量"><a href="#2-3-2-向量" class="headerlink" title="2.3.2 向量"></a>2.3.2 向量</h4><h5 id="向量的声明"><a href="#向量的声明" class="headerlink" title="向量的声明"></a>向量的声明</h5><p>向量的声明通常就是一维张量，即<code>tensor([x,y,z,...])</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>,dtype=torch.float32)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([0., 1., 2., 3.])
</code></pre><h5 id="向量的形状"><a href="#向量的形状" class="headerlink" title="向量的形状"></a>向量的形状</h5><p>shape可以查看向量的维度，是一个元素组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.arange(<span class="number">12</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">y, y.shape</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[[ 0,  1],
          [ 2,  3],
          [ 4,  5]],

         [[ 6,  7],
          [ 8,  9],
          [10, 11]]]),
 torch.Size([2, 3, 2]))
</code></pre><h4 id="2-3-3-矩阵"><a href="#2-3-3-矩阵" class="headerlink" title="2.3.3 矩阵"></a>2.3.3 矩阵</h4><h5 id="声明矩阵"><a href="#声明矩阵" class="headerlink" title="声明矩阵"></a>声明矩阵</h5><p>一个二维张量,$R^{(M·N)}$ 对应A(m,n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.,  1.,  2.,  3.],
        [ 4.,  5.,  6.,  7.],
        [ 8.,  9., 10., 11.],
        [12., 13., 14., 15.],
        [16., 17., 18., 19.]])
</code></pre><h5 id="矩阵转制"><a href="#矩阵转制" class="headerlink" title="矩阵转制"></a>矩阵转制</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.T</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.,  4.,  8., 12., 16.],
        [ 1.,  5.,  9., 13., 17.],
        [ 2.,  6., 10., 14., 18.],
        [ 3.,  7., 11., 15., 19.]])
</code></pre><h5 id="按元素相乘-Hadamard-Product"><a href="#按元素相乘-Hadamard-Product" class="headerlink" title="按元素相乘 Hadamard Product"></a>按元素相乘 Hadamard Product</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = A.clone()</span><br><span class="line">A * B</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[  0.,   1.,   4.,   9.],
        [ 16.,  25.,  36.,  49.],
        [ 64.,  81., 100., 121.],
        [144., 169., 196., 225.],
        [256., 289., 324., 361.]])
</code></pre><h5 id="矩阵降维"><a href="#矩阵降维" class="headerlink" title="矩阵降维"></a>矩阵降维</h5><ol>
<li>矩阵的按列降维和按行降维</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A_sum_axis0 = A.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line">A_sum_axis1 = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(A_sum_axis0, A_sum_axis0.shape)</span><br><span class="line"><span class="built_in">print</span>(A_sum_axis1, A_sum_axis1.shape)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([40., 45., 50., 55.]) torch.Size([4])
tensor([ 6., 22., 38., 54., 70.]) torch.Size([5])
</code></pre><ol>
<li>求平均值，按平均值降维，矩阵数据必须是<code>dtype=torch.float32</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.mean(), A.mean(axis=<span class="number">0</span>), A.mean(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor(9.5000),
 tensor([ 8.,  9., 10., 11.]),
 tensor([ 1.5000,  5.5000,  9.5000, 13.5000, 17.5000]))
</code></pre><ol>
<li>非均值降维</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum_A = A.<span class="built_in">sum</span>(axis=<span class="number">1</span>,keepdim=<span class="literal">True</span>)</span><br><span class="line">A, sum_A, A/sum_A</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
 tensor([[ 6.],
         [22.],
         [38.],
         [54.],
         [70.]]),
 tensor([[0.0000, 0.1667, 0.3333, 0.5000],
         [0.1818, 0.2273, 0.2727, 0.3182],
         [0.2105, 0.2368, 0.2632, 0.2895],
         [0.2222, 0.2407, 0.2593, 0.2778],
         [0.2286, 0.2429, 0.2571, 0.2714]]))
</code></pre><h5 id="矩阵处理"><a href="#矩阵处理" class="headerlink" title="矩阵处理"></a>矩阵处理</h5><p>按列、行累加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A, A.cumsum(axis=<span class="number">0</span>), A.cumsum(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  5.,  6.,  7.],
         [ 8.,  9., 10., 11.],
         [12., 13., 14., 15.],
         [16., 17., 18., 19.]]),
 tensor([[ 0.,  1.,  2.,  3.],
         [ 4.,  6.,  8., 10.],
         [12., 15., 18., 21.],
         [24., 28., 32., 36.],
         [40., 45., 50., 55.]]),
 tensor([[ 0.,  1.,  3.,  6.],
         [ 4.,  9., 15., 22.],
         [ 8., 17., 27., 38.],
         [12., 25., 39., 54.],
         [16., 33., 51., 70.]]))
</code></pre><h4 id="2-3-4-点乘与乘法"><a href="#2-3-4-点乘与乘法" class="headerlink" title="2.3.4 点乘与乘法"></a>2.3.4 点乘与乘法</h4><h5 id="向量点乘"><a href="#向量点乘" class="headerlink" title="向量点乘"></a>向量点乘</h5><p>点乘等价于每个元素相乘并求和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.ones(<span class="number">4</span>, dtype=torch.float32)</span><br><span class="line"><span class="built_in">print</span>(torch.dot(x, y))</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">sum</span>(x * y))</span><br></pre></td></tr></table></figure>
<pre><code>tensor(6.)
tensor(6.)
</code></pre><h5 id="矩阵-向量乘法"><a href="#矩阵-向量乘法" class="headerlink" title="矩阵-向量乘法"></a>矩阵-向量乘法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.mv(A, x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 14.,  38.,  62.,  86., 110.])
</code></pre><h5 id="矩阵-矩阵乘法"><a href="#矩阵-矩阵乘法" class="headerlink" title="矩阵-矩阵乘法"></a>矩阵-矩阵乘法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">B = torch.ones(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">torch.mm(A, B)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 6.,  6.,  6.],
        [22., 22., 22.],
        [38., 38., 38.],
        [54., 54., 54.],
        [70., 70., 70.]])
</code></pre><h4 id="2-3-5-范数"><a href="#2-3-5-范数" class="headerlink" title="2.3.5 范数"></a>2.3.5 范数</h4><h5 id="L1范数"><a href="#L1范数" class="headerlink" title="L1范数"></a>L1范数</h5><script type="math/tex; mode=display">
||x||_1 = \sum_{i=1}^{n}{|x_i|}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = torch.tensor([<span class="number">3.</span>, <span class="number">4.</span>, <span class="number">12.</span>])</span><br><span class="line">torch.<span class="built_in">abs</span>(u).<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<pre><code>tensor(19.)
</code></pre><h5 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h5><script type="math/tex; mode=display">
norm = ||x||_2 = \sqrt{\sum_{i=1}^{n}{x_i^2}}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.norm(u)</span><br></pre></td></tr></table></figure>
<pre><code>tensor(13.)
</code></pre>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>计算机视觉</tag>
        <tag>人工智能</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>伦勃朗与维米尔系列：Rembrandt In Amsterdam</title>
    <url>/2023/07/18/RembrandtInAmsterdam/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="Coming-to-Amsterdam"><a href="#Coming-to-Amsterdam" class="headerlink" title="Coming to Amsterdam"></a>Coming to Amsterdam</h4><p>伦勃朗在22岁时前往了阿姆斯特丹，17世纪的阿姆斯特丹是欧洲最大的经济中心与贸易中心，东印度公司垄断了亚洲一带的海上贸易，为城市带来了巨大财富。1630年，阿姆斯特丹证券交易所成立，象征着城市不凡的实力。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Amsterdam_Stock_Exchange.png" alt="Amsterdam Stock Exchange" style="zoom:20%;" /></p>
<p>同时，阿姆斯特丹还是理性主义思想的发源地，著名的理性主义先驱斯宾诺莎就出生于此</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Baruch_de_Spinoza.png" alt="Baruch de Spinoza" style="zoom:30%;" /></p>
<blockquote>
<p>巴鲁赫·德·斯宾诺莎「Baruch de Spinoza」，1632年11月24日—1677年2月21日，犹太人，近代西方哲学公认的三大理性主义者之一，与笛卡尔和莱布尼茨齐名。斯宾诺莎出生阿姆斯特丹的一个从西班牙逃往荷兰的犹太家庭。年轻时进入培养拉比的宗教学校，在艰难的生活条件下，他仍然坚持哲学和科学的研究，他的思想通过通信方式传播到欧洲各地，赢得人们的尊重。1677年不幸死于肺痨，享年45岁。他的主要著作有《笛卡尔哲学原理》、《神学政治论》、《伦理学》、《知性改进论》等。</p>
</blockquote>
<p>当时的阿姆斯特丹在发展经济思想的同时，全民教育也相当的普及，随着印刷业与版画业的发展，全民基本都具备了读写能力，这也从一方面解释了为何在这是兴起了“自传”的浪潮。伦勃朗也参与了当时的版画与印刷的发展，学习了版画制作的技巧。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/View_of_Amsterdam_from_the_Northwest.png" alt="View of Amsterdam from the Northwest" style="zoom:33%;" /></p>
<p>伦勃朗住在阿姆斯特丹的西北边，这是他对着窗户描绘的阿姆斯特丹的手稿。</p>
<h4 id="Painting-People"><a href="#Painting-People" class="headerlink" title="Painting People"></a>Painting People</h4><h5 id="Frans-Hals-and-Portrait"><a href="#Frans-Hals-and-Portrait" class="headerlink" title="Frans Hals and Portrait"></a>Frans Hals and Portrait</h5><p>伦勃朗擅长肖像画、自画像，他初到阿姆斯特丹就已经小有名气，不少人来委托他，让他为其做画。但是在当时，阿姆斯特丹还有一位在当时比伦勃朗更有名气的画家，就是哈尔斯。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Self-Portrait-Hals.png" alt="Hals" style="zoom:25%;" /></p>
<p>弗朗斯·哈尔斯「Frans·Hals」，l7世纪荷兰画派的奠基人和最杰出的肖像画大师之一。很少有人能像他那样运用洒脱而准确的笔触来塑造形体，使画中人形神兼备，成为有性格的典型人物。在这幅自画像中，可以看到其胡子层次分明，这是当时画家常用的工具：刮刀，所做成的，画中领子的褶皱被刻画的极为细腻，一抹蓝色与黑色的衣服反差，他的眼神看向画外，更有一种与观众的互动感，显得更加传神。</p>
<p>哈尔斯也深受卡拉瓦乔画派的影响，不仅仅是用色以及光线上的强烈对比反差，还将人物的神情戏剧化，夸张的表达人物一瞬间的舒展的面容。相比于伦勃朗刻画人脸的色彩渐变，哈尔斯在这两幅画中将红色与面容的颜色反差，更有戏剧性。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Frans_Hals_Boy Drinking.png" alt=""></p>
<h5 id="Portrait-of-Nicolaes-Ruts"><a href="#Portrait-of-Nicolaes-Ruts" class="headerlink" title="Portrait of Nicolaes Ruts"></a>Portrait of Nicolaes Ruts</h5><p>让我们再看回伦勃朗，伦勃朗更显分寸感与自然感。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Portrait-of-Nicolaes-Ruts.png" alt="Portrait of Nicolaes Ruts"></p>
<p>这幅画是伦勃朗在阿姆斯特丹接到的第一单，是荷兰著名的贸易商人尼古拉斯·鲁斯。我们可以看到模特站在侧光前，在墙上他的背景被清晰的勾勒出来，白色花边的领口与毛织衣装显示出鲁斯的财富实力。伦勃朗还特意将面容上的褶皱给画出，刻画出一个肃穆庄严的形象。这幅画的成功也让伦勃朗逐渐成为荷兰肖像画的名人，1631到1635年，他还为鲁斯的其他同胞们作画，也成为伦勃朗重要的合作伙伴。</p>
<h5 id="Portrait-of-Marten-Soolmans-and-Oopjen-Copit"><a href="#Portrait-of-Marten-Soolmans-and-Oopjen-Copit" class="headerlink" title="Portrait of Marten Soolmans and Oopjen Copit"></a>Portrait of Marten Soolmans and Oopjen Copit</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Marten_Oopjen.png" style="zoom:50%;" /></p>
<p>1634年，伦勃朗为一对夫妻分别作了肖像画，挂在壁炉两侧。其中男性手持手套，这是荷兰当时结婚的习俗，暗示着两人成婚，妻子手持扇子。两人都身着黑色袍子，白色花边，显示出两人的富贵。其中，男子的鞋上襄着水晶花边，是伦勃朗用刻刀阳刻出来的。值得注意的是，男性在左女性在右的传统来源于乔托《最后的审判》，其中在基督的右手边（画面左侧）是他的爱徒，而耶稣左手边（画面右侧）都是次一等的门徒，所以在挂画中，把男性挂在左侧暗示着基督喜爱的位置，是当时男性主导婚姻的暗示。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LastJugdetment.png" alt="最后的审判" style="zoom:30%;" /></p>
<h5 id="The-Shipbuilder-and-his-Wife"><a href="#The-Shipbuilder-and-his-Wife" class="headerlink" title="The Shipbuilder and his Wife"></a>The Shipbuilder and his Wife</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_Shipbuilder_and_his_Wife.png" alt="The Shipbuilder and his Wife" style="zoom: 25%;" /></p>
<p>伦勃朗在1633年还为东印度公司的企业家兼设计师作了一幅夫妇像，这幅画脱离了传统肖像画，伦勃朗捕捉了一个生活的瞬间，妻子为丈夫递来一封信，丈夫停下手中的工作。他手持圆规，纸上是他正在绘制的设计图稿，显示了男人的身份与职业，这个船正是当时荷兰大帆船的设计图。在这幅画中，伦勃朗将自己的签名藏在了书信中，暗示着他与名望之人的往来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Arrival-of-Elector-Frederick-V-of-the-Palatinate-and-Elizabeth-Stuart.png" style="zoom:25%;" /></p>
<h5 id="The-Anatomy-Lesson-of-Doctor-Nicolaes-Tulp"><a href="#The-Anatomy-Lesson-of-Doctor-Nicolaes-Tulp" class="headerlink" title="The Anatomy Lesson of Doctor Nicolaes Tulp"></a>The Anatomy Lesson of Doctor Nicolaes Tulp</h5><p>在阿姆斯特丹，外科医生行会每年都会有一场解剖学的公开演示课堂解剖真人，1632年著名外科医生蒂普教授来主刀这次解刨活动，真人是由死刑犯提供。外科医生行会选择伦勃朗为这次年度活动作一幅群像。过去也有人为外科医生行会作过群像。托马斯这幅群像已经相当不错，每个人都炯炯有神，后面四个人眼神集中于骨骼，专心的听人讲解，前面的两人面向观众，活灵活现。                                                                                                </p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Anatomy-Lesson-of-Doctor Sebastiaen.png" alt="The Anatomy Lesson of Doctor Sebastiaen Egbertsz de Vrij" style="zoom: 50%;" /></p>
<p>但伦勃朗对群像的理解可谓是颠覆性的，他摆脱了传统将每个人排练好，做好动作的群像手法，将群像生活化，戏剧化。我们说伦勃朗是一位伟大的剧作家，他会在他的每一幅画中加入一个故事，来表达他想描绘的。而这幅《蒂普医生的解剖课》让他名声大噪。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Anatomy-Lesson-of-Doctor-Nicolaes-Tulp.png" alt="The Anatomy Lesson of Doctor Nicolaes Tulp"></p>
<p>画中一条黑影把画面分割为两块，上面一侧的光线打在解剖医生上，而下面一侧光打亮了尸体，这是伦勃朗对光的使用，每个人都注视着蒂普医生，把课堂的紧张感与认真的神情刻画出来。图中可以看到，最后方的人物头上有帽子的痕迹，经过X光证实，伦勃朗在画这幅画的时候反复的修改过，也就是说伦勃朗观察了每个人的神情，并通过自己的想象，构造了这样一个教学的场景，使整个画面充实生动。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Andreas-vesalius.png" alt="Andreas Vesalius"></p>
<p>值得注意的细节是，正常的解剖顺序应该是从胸腔开始，打开人体的腹部。但是画中描绘的是蒂普医生结构手臂的情景，同时医生的左手弯曲，好像在展示什么。这一幕其实是致敬文艺复兴时期医学家安德鲁瓦萨里，他在《人体结构》中展示了手臂前臂的肌肉与拇指的弯曲相关，他也表明人与其他动物最大的不同就是只有人类的拇指是朝向侧面的。蒂普医生展示这样的动作正是在论述人作为高等动物的优越性。</p>
<h4 id="Rembrandt’s-Signature"><a href="#Rembrandt’s-Signature" class="headerlink" title="Rembrandt’s Signature"></a>Rembrandt’s Signature</h4><h5 id="Self-Portrait-in-Soft-Hat"><a href="#Self-Portrait-in-Soft-Hat" class="headerlink" title="Self-Portrait in Soft Hat"></a>Self-Portrait in Soft Hat</h5><p>最早在伦勃朗给自己戴帽子的自画像中，他第一次给自己的画签上了”Rembrandt”。在随后的几年他开始使用自己的名字，而非是自己的姓与故乡名。在历史上，只有文艺复兴三杰这样做。这也意味着他在当时已经是荷兰甚至北方的最顶尖的画家，以及伦勃朗对自己的认可与自信。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/SIgnature.png" alt="Rembrandt's Signature" style="zoom: 35%;" /></p>
<h4 id="Rembrandt’s-Family"><a href="#Rembrandt’s-Family" class="headerlink" title="Rembrandt’s Family"></a>Rembrandt’s Family</h4><p>伦勃朗在1631年于阿姆斯特丹的艺术品经销商亨德里克·乌伦博格相识，他看到了伦勃朗的才能并作为伦勃朗的经纪人帮助他售卖他的画作、为他提供工作室。在1634年，伦勃朗与乌伦博格的侄女萨斯基亚·乌伦博格订婚。</p>
<p>伦勃朗对他的妻子相当的疼爱，在结婚后，还经常把他的妻子画成花神的模样，为其留下众多肖像作品。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Saskia.png" alt="Saskia"></p>
<h5 id="View-over-the-Amstel-from-the-Rampart"><a href="#View-over-the-Amstel-from-the-Rampart" class="headerlink" title="View over the Amstel from the Rampart"></a>View over the Amstel from the Rampart</h5><p>伦勃朗很快在阿姆斯特尔河边买了一件房，并从窗边描绘了河边美景。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/View-over-the-Amstel-from-the-Rampart.png" alt="View over the Amstel from the Rampart"></p>
<h5 id="Self-Portrait-with-Saskia-in-the-Guise-of-the-Prodigal-Son"><a href="#Self-Portrait-with-Saskia-in-the-Guise-of-the-Prodigal-Son" class="headerlink" title="Self-Portrait with Saskia in the Guise of the Prodigal Son"></a>Self-Portrait with Saskia in the Guise of the Prodigal Son</h5><p>29岁的伦勃朗正处名利双收的时候，他绘制了一幅更加大胆主题的自画像。他把自己画成是一个浪子，他的妻子坐在他的腿上，放荡不羁。两人都穿着16世纪的服装，男人是笑嘻嘻、醉醺醺的年轻人的形象，显然是打扮的有些过头了。作品的背景是浪子的圣经寓言。在这个寓言中，一个富人的次子得到了他的遗产份额，并将其带到了一个遥远的国家。在那里，他把钱浪费在食物和女人上，过了一会儿不得不忍受饥饿，流浪街头。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Self-Portrait with Saskia-in-the-Guise-of-the-Prodigal-Son.png" alt="Self-Portrait with Saskia in the Guise of the Prodigal Son"></p>
<p>这幅画结合了许多绘画对象，强调了艺术家的欢乐狂热：伦勃朗穿着高贵的衣服，戴着华丽的羽毛帽子，高兴地用举起的啤酒杯向接受者敬酒。他用左手风骚地撩起萨斯基亚的裙子，萨斯基亚从后面描绘，并将她的目光引向观众。背景是孔雀公鸡，高贵的面料和场景的金色支持着傲慢、性感的描绘。</p>
<p>伦勃朗做这幅画，有些学者猜测是否是伦勃朗对自己的警示，把自己画作是浪子，来劝勉自己不要挥霍无度。的确，在30岁前，伦勃朗的生活都顺风顺水，这幅画的背后也可能包含了他对如此顺利生活的真实感的质疑，抑或是他对未来的担忧。</p>
<h4 id="Painting-History-New-Testament-Mythology-Old-Testament"><a href="#Painting-History-New-Testament-Mythology-Old-Testament" class="headerlink" title="Painting History: New Testament / Mythology / Old Testament"></a>Painting History: New Testament / Mythology / Old Testament</h4><blockquote>
<p>伦勃朗的历史画别具一格，运用微妙的细节，将画面戏剧化，敢于打破常规，抓住命运突然反转的时刻。</p>
</blockquote>
<p>伦勃朗一直想成为历史画家，或许成为历史画家也是每一位画家的梦想之一，在当时历史画在西方艺术分类中品类最高，选材上包括希腊神话、圣经故事、古罗马古希腊历史传说等。在他30岁时，伦勃朗已经很擅长把握群体，刻画人物了，在这期间，伦勃朗创作了不少宏大的历史画，而且每一幅都有着他独特的颠覆传统的思考。</p>
<p>在历史画题材中，基督受难是许多艺术家选择的，也是最为出名的，整个基督受难分为六个阶段：犹大背叛、基督被捕、基督受审、上十字架、下十字架、埋葬。在这里，我们介绍伦勃朗为这一主题作的其中两幅。</p>
<h5 id="Passion-of-Christ-The-Deposition"><a href="#Passion-of-Christ-The-Deposition" class="headerlink" title="Passion of Christ: The Deposition"></a>Passion of Christ: The Deposition</h5><p>先来看一下鲁本斯所画的下十字架：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Rubens-Descent-from-the-Cross.png" alt="Peter Paul Rubens Descent from the Cross" style="zoom:25%;" /></p>
<p>在过去，安特卫普的鲁本斯也画过同样一个主题的下十字架。这幅画将光线集中于耶稣，四周的人围在基督的尸体旁，依旧可以看到被钉子钉处的血迹，来衬托出世人的罪恶。艺术评论家惠更斯曾经评价：“鲁本斯乃世界七大奇迹之一， 当世画家中的阿佩莱斯。”对于基督形象的刻画，鲁本斯参考了古希腊的雕塑《拉奥孔》，将人死去后痛苦的身姿表现出来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Laocoon-and-Descent.png" alt="拉奥孔" style="zoom: 25%;" /></p>
<p>让我们再来看看伦勃朗画的《下十字架》</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Rembrandt-The-Deposition.png" alt="Rembrandt:The Deposition" style="zoom:50%;" /></p>
<p>伦勃朗这幅画采用了三角构图，同样是描绘了耶稣下十字架将要被装进裹尸布中，远处的城堡，暗示故事发生在耶路撒冷。与伦勃朗不同的是，整个画面以暗色为色调，一束光从画面上方打在基督身上，他并没有刻画出基督钉在十字架上的痕迹，而是把尸体刻画得普通而富有真实化，一侧的手臂从十字架上送下，仿佛有不可承受之重，更加真实感。对比鲁本斯和伦勃朗，两幅画都是这一主题的佼佼者，不过伦勃朗打破了传统，将耶稣描绘的更加真实化，平凡化，这也体现了伦勃朗对历史画作独特的风格。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Descent-etching.png" alt="Etching Version for Descent"></p>
<p>在当时的荷兰，鲁本斯常常把油画蚀刻成版画来流传，伦勃朗随后也学习到了版画相关技巧，他开始追逐鲁本斯，也将自己的油画蚀刻成版画，流传出来。在版画上把一个人改成了自己的脸，既是版权的象征，也有身临其境的在场感，这一点在同为基督受难的作品《上十字架》上体现的更为明显。值得注意的是，油画与蚀刻画是左右对称的，原因是蚀刻术与印章原理相同，艺术家需要对着作品在刻板上蚀刻，最后再印到画板。</p>
<h5 id="Passion-of-Christ-The-Raising-of-the-Cross"><a href="#Passion-of-Christ-The-Raising-of-the-Cross" class="headerlink" title="Passion of Christ: The Raising of the Cross"></a>Passion of Christ: The Raising of the Cross</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Raising-of-the-Cross.png" style="zoom:50%;" /></p>
<p>在基督受难的另一幅作品，《上十字架》中，带着蓝色贝雷帽的男士就是伦勃朗自画像，把基督送上十字架，意味着自己的忏悔，这印证了当时一种新教思想，即是每个人的罪孽才是得基督送上十字架，表达了自己的忏悔。</p>
<blockquote>
<p><em>Tis not the Jews who crucified</em><br><em>Nor who betrayed you in the judgment place</em><br><em>Nor who, Lord Jesus, spat into your face</em><br><em>Nor who with buffets struck you as you died</em></p>
<p><em>Tis not the soldiers who with brutal fists</em><br><em>Raised the hammer and raised the nail</em><br><em>Or the cursed wood on Calvary’’s hill</em><br><em>Or drew lots, tossed the dice to win your cloak</em></p>
<p><em>I am the one, oh Lord, who brought you here</em><br><em>I am the heavy tree, too stout to bear</em><br><em>I am the rope that reined you in</em></p>
<p><em>The scourge that flayed you, nail and spear</em><br><em>The blood-soaked crown they made you wear</em><br><em>‘Twas all for me, alas, ‘twas for my sin.</em></p>
</blockquote>
<h5 id="Christ-in-the-Storm-on-the-Sea-of-Galilee"><a href="#Christ-in-the-Storm-on-the-Sea-of-Galilee" class="headerlink" title="Christ in the Storm on the Sea of Galilee"></a>Christ in the Storm on the Sea of Galilee</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Christ-in-the-Storm-on-the-Sea-of-Galilee.png" alt="Christ in the Storm on the Sea of Galilee" style="zoom: 25%;" /></p>
<p>《加利利海上风暴》是伦勃朗又一幅圣经题材的作品，描绘的是信徒应该对耶稣有无条件的信仰。故事的背景是门徒与耶稣在加利利海上航行，耶稣睡着的时候海上忽然刮起了风暴，门徒们慌张不已，把耶稣叫醒希望得到耶稣的帮助。先看画面的整体，在荷兰大航海时期，很多画家都开始描绘海上的风浪与暴风雨后的情景，伦勃朗在此也是借鉴了Jan Porcellis的作品《在暴风雨中航行的船》中的一个部分。在画面的远处都有明亮的天空，暗示着希望，在这里也暗示着耶稣基督的神迹。不同于Jan Porcellis,伦勃朗的光更加鲜艳，对比度更加强烈，不仅显示了基督的神迹吗，也照亮了每一个门徒的脸，让肖像大师伦勃朗对他们神情的刻画更加细致，生动。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Ships-in-a-Storm-on-a-Rocky-Coast.png" alt="Ships in a Storm on a Rocky Coast" style="zoom:25%;" /></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Details-Storm.png" style="zoom:28%;" /></p>
<p>让我们再来看看画面的细节部分：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Details-Christ-in-the-Storm-on-the-Sea-of-Galilee.png" alt="Details" style="zoom:25%;" /></p>
<p>耶稣基督的脸朝向远处的光芒，神情轻松，丝毫让人想不到一股巨浪正拍打着船只。基督周围的门徒则探着头，慌张的询问着基督如何是好，十分慌张，还有的门徒抓紧船只的桅杆和绳索，恐惧写在他们的脸上。门徒与基督神态上的对比，更突出了对基督无条件坚定信仰的主题。</p>
<h5 id="John-the-Baptist-Preaching"><a href="#John-the-Baptist-Preaching" class="headerlink" title="John the Baptist Preaching"></a>John the Baptist Preaching</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/John-the-Baptist-Preaching.png" alt="John the Baptist Preaching"></p>
<p>这幅画显示了施洗者约翰在旷野向“出来受洗的众人”讲道「路加福音3:3-18」，其中有富人和穷人，有税吏和士兵。伦勃朗的这幅画是文艺复兴时期艺术的一个流行主题。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/St-John-the-Baptist-Preaching.png" alt="St. John the Baptist Preaching" style="zoom:33%;" /></p>
<p>这是过去艺术家描绘约翰布道的情景，众多的人，以及中间的施洗者约翰。而伦勃朗虽然也是相同的情景，这幅画本身是对伦勃朗的用光以及群像的手法展示，但是在内容上伦勃朗可谓是相当大胆。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Detail-John.jpg" style="zoom:67%;" /></p>
<p>在圣经的正剧中，大量的出现动物、孩童等一些鄙陋的细节。有鸡蹦到人的头上，边上还有猪在吃食；有母亲在给小孩把尿；有动物打成一片，交配的情景。把不雅的场景搬到圣经这样的历史画题材中是伦勃朗独特的理解，他为一出戏安排了小丑，使得整个戏更加生动。更重要的是，这暗示了人类群体的多样性，各式各样的人聚在一起，听着约翰的布道，还有边上的闲杂人士在继续自己的生活。</p>
<h5 id="Diana-Bathing-with-the-Stories-of-Actaeon-and-Callisto"><a href="#Diana-Bathing-with-the-Stories-of-Actaeon-and-Callisto" class="headerlink" title="Diana Bathing, with the Stories of Actaeon and Callisto"></a>Diana Bathing, with the Stories of Actaeon and Callisto</h5><p>《戴安娜与仙女沐浴》展示了奥维德的《变形记》中的两集，在这两集里，都有人因为性侵犯而受到女神戴安娜的惩罚。在画面左边，猎人阿克托翁在无意间因为看到女神裸体而受到惩罚变成麋鹿最后被他的猎犬咬死。在画面右边，戴安娜的其他仙女正在撕下卡利斯托的衣服，以揭示她是如何违背了她的贞洁誓言，她怀了朱庇特的孩子，为此，戴安娜将她驱逐出宫廷。可以说是第一次，有艺术家将两个故事画在同一幅作品上。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Diana-Bathing.png" alt="Diana Bathing, with the Stories of Actaeon and Callisto"></p>
<p>我们可以看到带着月牙形头冠的就是月神狄安娜，她盯着猎人阿克泰翁，此时猎人的头上已经长出了鹿角，暗示着他已经中了狄安娜的诅咒。在画面右边，卡利斯托的衣服被掀起来露出怀孕的肚子，扭打在一起。</p>
<p>伦勃朗又一次把把正剧改成了闹剧，打闹，看戏，动物的交配，各种闹剧元素被伦勃朗加上。故事的主题都是讲述了人被无法掌握的欲望左右，猎人和卡利斯托都是在毫无防备的悲剧，将禁忌的欲望和在一起，在闹剧中写悲情，更令人感伤沉思。</p>
<h5 id="Abduction-of-Europa"><a href="#Abduction-of-Europa" class="headerlink" title="Abduction of Europa"></a>Abduction of Europa</h5><blockquote>
<p>公主这时候十分害怕<br>向后一看，陆地愈来愈远<br>她一手握紧住一只角，一手扶着牛背<br>她的衣裾在风中飘舞着。</p>
<p>——奥维德《变形记》II:833-875</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Abduction-of-Europa.png" alt="Abduction of Europa"></p>
<p>《劫走欧罗巴》也是伦勃朗以《变形记》故事为主题的历史画作，这幅画中，宙斯刚刚把欧罗巴带离海岸，欧罗巴还注视着岸上的女伴，表情惊恐。故事发生在离荷兰相当远的腓尼基海岸，或者在当时称为“东方”。但伦勃朗从未去过那里，也没有哪个作品证明过腓尼基的海岸是什么样的。于是伦勃朗在画面的右后方画上了一个不伦不类的马车，高贵、神秘，是当时人对东方的猜测。</p>
<h5 id="Abduction-of-Ganymede"><a href="#Abduction-of-Ganymede" class="headerlink" title="Abduction of Ganymede"></a>Abduction of Ganymede</h5><blockquote>
<p>神明们见他容貌俊美<br>把他掳去<br>给宙斯斟酒<br>留他在不朽的神界居住</p>
<p>——《伊利亚特》XX:233-235</p>
</blockquote>
<p>关于掠夺，《伊利亚特》中还有宙斯劫走伽倪墨得斯的故事。伽倪墨得斯是特洛伊国王特罗斯之子，因为其年少貌美，因此受到宙斯的喜爱，将他带到天上成为宙斯的情人并代替青春女神赫柏为诸神斟酒。在过去的艺术作品中，艺术家们都会把伽倪墨得斯的英俊潇洒表达在作品当中，还是来看著名画家鲁本斯的《劫走伽倪墨得斯》，伽倪墨得斯被画作的是英俊的美少女，深得众神的喜爱。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RubensAbduction-of-Ganymede.png" alt=""></p>
<p>而在伦勃朗的画中，伽倪墨得斯成了一个小天使，甚至是一个哇哇叫的婴儿，被一只大鸟抓走。这幅画中，伦勃朗很有可能是参考了布鲁塞尔的撒尿的小孩雕塑。小天使见不得美丽，只有狼狈和挣扎。而当黑云压顶，被雄鹰掳走的瞬间，被强迫掳走的伽倪墨得斯正该如此绝望与无助，伦勃朗将故事的感性与人性凸显出来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Abduction-of-Ganymede.png" alt="Abduction of Ganymede"></p>
<p>然而，有一部分学者认为这幅画还有更深的政治意味，芭芭拉 •盖滕斯「Barbara Gacghtens」在一篇未发表的文章中提出伦勒朗的《伽倪墨得斯》引用的可能是另一个关于统治者的古老神话，他们要接受“雄鹰测试”，老鹰会把他们带向高空和明媚的太阳，来检测他们的力量和勇气。伦勒朗绘制的这个婴儿，是被老鹰抓在爪子里，不情愿地被拖上了天空，还吓得哇哇大叫并且尿了出来，他的雄鹰测试很显然是失败的。婴儿的村衣被老鹰抓了起来，上边还有一条原本无法解释的缨绳，现在可以将他视为将军们在战场上佩戴的腰带，或者是王子们作为指挥官的地位象征，然而这种对比其实更像是讽刺，婴儿的恐惧明显削弱了亡所引申的意义。</p>
<p>如果这幅画指的是荷兰年轻的王子、总督的儿子威康二世（Wiliam Il， 生于1626年），他也比这幅画中的婴儿年长许多。年轻的威康二世在新的奥兰治王朝策略中提出了提前执政的要求，1650年他突然去世，荷兰也进入了一个混乱的“无总督”时期。伦勒朗绘制的没有通过雄鹰测试的 《伽倪墨得斯》可能是在间接批评这位年轻的继承人。</p>
<h5 id="Belshazzar’s-Feast"><a href="#Belshazzar’s-Feast" class="headerlink" title="Belshazzar’s Feast"></a>Belshazzar’s Feast</h5><p>在《伯沙撒的盛宴》中，伦勒朗对《旧约》宗教场景的戏剧化展现达到了高潮。丰富多彩的服饰、静物元素和灯光都凸显了人物的面部表情和戏剧化的姿势。在画作的中心，一个身着华丽的锦缎长袍、头戴充满异国色彩头巾的统治者仿佛受到了惊吓，一下子把身子转了过去。在他两侧，不论是面朝着我们还是背朝着我们的人物都同样惊讶不已，其中一个拿着金色水壶正在倒酒的人物都被吓得动不了了。他们都看到了一个超自然的事情，一位圣人正在用希伯来文字写下对众人的警告，这个神圣的信息是在警告伯沙撒，因为他的亵渎，“上帝已经算好了你的国家还能存在的日子，而且你的国家很快就会灭亡了；经过考验，你不能胜任国王”。在那一晚，他的王国被米堤亚人和波斯人分隔。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Belshazzars-Feast.png" alt=""></p>
<p>在墙上，伦勃朗精准的把希伯来文给表示出来，根据《圣经》，这些文字只有先知达尼尔看得懂，不仅仅是因为他熟知希伯来语，而且墙上的文字刻意被竖过来写，与常规横向阅读希伯来语不同。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Menasseh-ben-Israel.png" style="zoom: 25%;" /></p>
<blockquote>
<p>Daniel reads the words “MENE, MENE, TEKEL, UPHARSIN” and interprets them for the king: “MENE, God has numbered the days of your kingdom and brought it to an end; TEKEL, you have been weighed … and found wanting;” and “UPHARSIN”, your kingdom is divided and given to the Medes and Persians. </p>
</blockquote>
<h5 id="The-Blinding-of-Samson"><a href="#The-Blinding-of-Samson" class="headerlink" title="The Blinding of Samson"></a>The Blinding of Samson</h5><p>在《旧约》的《士师记》中，参孙是在神的应许中出生，并在神的眷顾下成长。他生来就有超凡的力气，唯一的弱点就是他的头发，如果把头发剪下，他就手无缚鸡之力。参孙不尊重以色列人的律法和父母的劝戒，随自己的喜好，娶非利士女子达利拉为妻。非利士人几次想杀死参孙，可惜此人神力，能够一人扛起城门。于是非利士让参孙的妻子大利拉套出参孙神力的原因，起初参孙还有所防备，最后他抵挡不住美色的诱惑说出了自己头发的秘密。他的妻子趁他熟睡时剪掉了他的头发，参孙随后被闯入的非利士人刺瞎双眼。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Blinding-of-Samson.png" alt="The Blinding of Samson"></p>
<p>这是一幅画啊描绘的是这位英雄人物背叛行为的高潮，我们可以看到尖刀已经刺进参孙的眼睛，后面的士兵勒住参孙，边上还有士兵用手铐拴住参孙的手臂。整个画面相当的残忍，与之对比的是参孙的妻子，她手拿参孙的头发跑去，看不出一丝的悲伤，甚至有些许的喜悦。将整个背叛的场景更富有戏剧化，对比性。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>西方美术史</tag>
        <tag>伦勃朗</tag>
      </tags>
  </entry>
  <entry>
    <title>世界计划 COLORFUL LIVE 2nd - Will -</title>
    <url>/2023/01/10/PJSK2023Live/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<blockquote>
<font color=#39C5BB size=6 > 你的下一个MM，何必是MM </font>

</blockquote>
</blockquote>
<hr>
<h3 id="开场-成员介绍"><a href="#开场-成员介绍" class="headerlink" title="开场+成员介绍"></a>开场+成员介绍</h3><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LN:IN.png" alt="LN"></p>
<p>你游葱葱单推人来咯——</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MMJ:IN.png" alt="MMJ"></p>
<p>&gt;</p>
<blockquote>
<p>もっともっとたくさんの歌を！</p>
<p>もっともっとたくさんの元気を！</p>
<p>もっともっとたくさんの希望を！</p>
<p>もっともっとも～っとたくさんの人達に届けられるように！</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VBS:IN.png" alt="VBS"></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WS:IN.png" alt="WS"></p>
<blockquote>
<font color=#ff9900> 这是，为了「笑颜」而登上舞台的少年少女的故事—— </font>


</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/25时:IN.png" alt="25时"></p>
<p>真的是自闭4人组</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Miku:IN.png" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VL:IN.png" alt=""></p>
<hr>
<h3 id="上半场"><a href="#上半场" class="headerlink" title="上半场"></a>上半场</h3><h4 id="Leo-Need"><a href="#Leo-Need" class="headerlink" title="Leo/Need"></a>Leo/Need</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LN-1.png" alt=""></p>
<p>原创曲: Stage of sekai</p>
<p>翻唱曲: Calc</p>
<h4 id="More-More-Jump"><a href="#More-More-Jump" class="headerlink" title="More!More!Jump!"></a>More!More!Jump!</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MMJ-1.png" alt=""></p>
<p>原创曲: モア！ジャンプ！モア！</p>
<p>翻唱曲: 吸血鬼</p>
<h4 id="Vivid-BAD-SQUAD"><a href="#Vivid-BAD-SQUAD" class="headerlink" title="Vivid BAD SQUAD"></a>Vivid BAD SQUAD</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VBS-1.png" alt=""></p>
<p>原创曲: シネマ/电影</p>
<p>翻唱曲: echo</p>
<h4 id="Wonderlands×Showtime"><a href="#Wonderlands×Showtime" class="headerlink" title="Wonderlands×Showtime"></a>Wonderlands×Showtime</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WS-1.png" alt=""></p>
<p>原创曲: 不可思议的wonder</p>
<p>翻唱曲: 踊れオーケストラ</p>
<h4 id="25时，在Nightcord"><a href="#25时，在Nightcord" class="headerlink" title="25时，在Nightcord"></a>25时，在Nightcord</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/25时-1.png" alt=""></p>
<p>原创曲: 写作悔恨的未来</p>
<p>翻唱曲: フォニイ/phony</p>
<hr>
<h3 id="中场：千本樱"><a href="#中场：千本樱" class="headerlink" title="中场：千本樱"></a>中场：千本樱</h3><p><del>千本樱虽好，但SEGA能不能来点新的</del></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/V-1.png" alt=""></p>
<hr>
<h3 id="下半场"><a href="#下半场" class="headerlink" title="下半场"></a>下半场</h3><h4 id="Wonderlands×Showtime-1"><a href="#Wonderlands×Showtime-1" class="headerlink" title="Wonderlands×Showtime"></a>Wonderlands×Showtime</h4><p>翻唱曲：Telecaster B-Boy</p>
<p>原创曲：微笑调查队</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WS-2.png" alt=""></p>
<h4 id="More-More-Jump-1"><a href="#More-More-Jump-1" class="headerlink" title="More!More!Jump!"></a>More!More!Jump!</h4><p>原创曲：天使のクローバー</p>
<p>翻唱曲：心予報</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MMJ-2.png" alt=""></p>
<h4 id="Vivid-BAD-SQUAD-1"><a href="#Vivid-BAD-SQUAD-1" class="headerlink" title="Vivid BAD SQUAD"></a>Vivid BAD SQUAD</h4><p>原创曲：街</p>
<p>翻唱曲：黎明前线</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/VBS-2.png" alt=""></p>
<h4 id="25时，在Nightcord-1"><a href="#25时，在Nightcord-1" class="headerlink" title="25时，在Nightcord"></a>25时，在Nightcord</h4><p>原创曲：Lower</p>
<p>翻唱曲：苦巧克力装饰</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/25时-2.png" alt=""></p>
<h4 id="Leo-Need-1"><a href="#Leo-Need-1" class="headerlink" title="Leo/Need"></a>Leo/Need</h4><p>翻唱曲：火花</p>
<p>原创曲：Stella</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LN-2.png" alt=""></p>
<hr>
<h3 id="返场"><a href="#返场" class="headerlink" title="返场"></a>返场</h3><h4 id="V家合唱：群青赞歌"><a href="#V家合唱：群青赞歌" class="headerlink" title="V家合唱：群青赞歌"></a>V家合唱：群青赞歌</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/V-2.png" alt=""></p>
<h4 id="队长曲：Journey"><a href="#队长曲：Journey" class="headerlink" title="队长曲：Journey"></a>队长曲：Journey</h4><p>撅撅撅撅你——</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/队长团-2.png" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/队长团-1.png" alt=""></p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>世界计划</tag>
        <tag>初音未来</tag>
        <tag>25时在夜电台</tag>
      </tags>
  </entry>
  <entry>
    <title>伦勃朗与维米尔系列：The Mysterious Vermeer</title>
    <url>/2023/08/16/TheMysteriousVermeer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>维米尔于1632年出生于荷兰代尔夫特，在如今的代尔夫特中心广场，代尔夫特斜塔中保存着他的墓石。不同于其他艺术家向往大城市寻求发展，直到1675年去世，他都没有离开过他的故乡。在代尔夫特，他曾四次担任当地的画家协会会长，相比于高产伦勃朗，维米尔目前传世的也就三十多件作品，仿佛绘画并非是维米尔的谋生之道，而是他思考探索艺术的乐趣。维米尔在结婚之后一直住在他的丈母娘家中，在房子中有他的画室，虽然不大，但相当的精致。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Delft-1.png" style="zoom:20%;" /></p>
<p>维米尔的作品尺寸不大，主题大多是女性——她们或在读书，或在缝纫，或者准备着日复一日的早餐，或者正在读信。她们在平凡的生活中，没有强烈的喜怒哀乐，她们只是生活着，平凡而真实地生活着。而背景都是一间简单的屋子，阳光斜射进室内画面左侧的窗户，温和而安静，仿佛天长地久。</p>
<blockquote>
<p>画中常出现大幅的地图，好像知道外面的世界己经在起巨大的变化，男子都出远洋了，在海上冒险，偶尔有信寄回来，女子静静读着信，好像平静的市镇生活唯一的高潮便是一封来自远方的信。伦勃朗的世界充满悲剧内敛的情操，有着男性的阳刚与沉重；弗美尔则非常女性，以女性的委婉幽静推开一扇窗，让人们看到如小品般的宁静。</p>
<p>——蒋勋</p>
</blockquote>
<h5 id="View-of-Delft"><a href="#View-of-Delft" class="headerlink" title="View of Delft"></a>View of Delft</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/View_of_Delft.png" alt="View of Delft"></p>
<h4 id="Vermeer’s-Early-Works"><a href="#Vermeer’s-Early-Works" class="headerlink" title="Vermeer’s Early Works"></a>Vermeer’s Early Works</h4><p>维米尔的早期作品包括了女性与家庭，其中穿插着圣经与神话题材。</p>
<h5 id="Diana-and-her-Nymphs"><a href="#Diana-and-her-Nymphs" class="headerlink" title="Diana and her Nymphs"></a>Diana and her Nymphs</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Diana_and_her_Nymphs.png" alt=""></p>
<p>维米尔这幅《狄安娜和仙女》同样绘制的是月神狄安娜在森林中洗浴的情景，维米尔从作画开始就擅长绘制女性。狄安娜在这幅画中与伦勃朗的拔士巴有异曲同工之妙，都展现了忧郁之感。据史料研究，维米尔把忧郁之情寄托于画面中旨在纪念他的学徒，荷兰画家卡雷尔。他曾与卡雷尔一起研究绘画中的视觉陷阱，卡雷尔的《代尔夫特风景》就是在展现一种独特的视觉效果，可惜的是当时代尔夫特的火药库发生爆炸，卡雷尔丧生于此。在卡雷尔逝世那年，维米尔画了狄安娜，将自己的悲伤暗藏在画中的人物之中。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Carel_Fabritius.png" style="zoom:30%;" /></p>
<h5 id="A-View-of-Delft"><a href="#A-View-of-Delft" class="headerlink" title="A View of Delft"></a>A View of Delft</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/A_View_of_Delft.png" alt="A View of Delft" style="zoom:25%;" /></p>
<h5 id="Christ-in-the-House-of-Martha-and-Mary"><a href="#Christ-in-the-House-of-Martha-and-Mary" class="headerlink" title="Christ in the House of Martha and Mary"></a>Christ in the House of Martha and Mary</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Christ_in_the_House_of_Martha_and_Mary.png" style="zoom:30%;" /></p>
<blockquote>
<p>我们很容易像马大那样为了那些物质利益忙前忙后，觉得有责任承担义务，或拜访、照顾他人但内心深处产生压力，感到忿忿不平，别人悠闲自得自己却忙得不可开交。我们或许以为伺奉别人就能最好地侍奉主，特别是在我们精力充沛的时候，但耶稣对马大说的话对我们这些生活在纷繁物质世界里的人特别适用—“不可缺少的只有一件事”。耶稣没有多说，只说玛利亚选择了那必不可缺的，那更好的事情。那天晚上玛利亚专注于耶稣，马大错过了什么呢？也许她错过机会，她主就要死去，因此在他身旁听他说话的机会将不复再来。唯一要做事情过去是，现在仍然是要了解他。我们大家都能在生活中找到自己的平衡点，牢记耶稣对马大说的话，她为太多的事情忧虑烦扰。如果我们想和耶和华那样，就必须牢记他的话。我们的工作是满足他人的需要，正如耶稣所做的那样，但他从未因为伺奉分心，他挤出时间独处，这样就可以做祈祷并获得他父的思想和力量。</p>
<p>——《圣经中的女人》</p>
</blockquote>
<p>这幅画描绘的是耶稣到两姐妹家传道，画面上方的是姐姐马大，她瞻前顾后，通过劳动接待耶稣的布道，而妹妹玛丽亚则坐在椅子上专注的聆听。姐妹两人其实代表了两种对信仰的实践，分别是行动派与沉思派，分别代表了天主教派与荷兰新教派。行动派代表了责任、担当、勤劳；而沉思派意味着思想上的理解，倾听，热爱世界。维米尔将两者画在一起，在画中，耶稣指向马大，头部转向玛丽亚，做到了两个教派的均衡。暗示了两者需要在生活中找到平衡，既要操持生活，也要感悟倾听。维米尔作这幅画离不开他的宗教背景。他在新教的大环境中出生于天主教家庭，但他天生文静，更倾向于思考，他就位于两个教派的矛盾之中。</p>
<h4 id="The-Golden-Age-of-Genre-Painting"><a href="#The-Golden-Age-of-Genre-Painting" class="headerlink" title="The Golden Age of Genre Painting"></a>The Golden Age of Genre Painting</h4><p>风俗画作为一大重要的艺术题材风靡全球。日本的浮世绘就以日常生活为主题，描绘自然之美，抑或是欢歌笑语，轻松的同时往往会带有沉重的隐喻。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Ukiyoe.png" style="zoom:20%;" /></p>
<p>列宾作为沙俄时期批判现实主义画室因其风俗画《伏尔加河上的纤夫》闻名，他的风俗画揭示了社会的不平等，传达的社会信息超过了其本身的艺术性。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Barge_Haulers_on_the_Volga.png" style="zoom:20%;" /></p>
<p>而荷兰画家老勃鲁盖尔擅长描绘普通人的日常，他称自己为“农民勃鲁盖尔”。他曾经画过一幅《尼德兰谚语》，一幅画中包含了数个分镜故事，将古老的谚语故事展现在画中，比如给猫咪挂铃铛多此一举、向着炉子打哈欠不自量力、两人赤身坐在窗边狼狈为奸等，讽刺人们的荒谬。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Netherlandish_Proverbs.png" alt="Netherlandish_Proverbs" style="zoom:25%;" /></p>
<p>伦勃朗的徒弟窦擅长将障眼法融合到风俗画中，他和他的徒弟梅曲都会在风俗画中设置一个看似墙壁的面，仿佛观众与画面人物之间还有一层空间。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Maid_at_the_Window.png" style="zoom:20%;" /></p>
<p>为莱顿创建了画家协会的斯滕更是一位风俗画高手，在他的风俗画中，人物活泼、场景随意，整个画面幽默生动，斯滕也善于将音乐融合在画中，与维米尔有异曲同工之妙。在他的自画家中，他把自己打扮成一个抽象的放荡不羁的音乐家，手持鲁特琴，颇有亲和力与表现力。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/SelfPortrait_Playing_the_Lute.png" alt="Self-Portrait Playing the Lute" style="zoom: 28%;" /></p>
<p>在他的画作中，经常出现纵酒狂欢的混乱，他通常会像伦勃朗一样，安排一出闹剧，刻意的混乱将人间喧嚣表达的淋漓尽致，将荷兰黄金时代中乡村人们的欢悦生活幽默的表达出来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Beware_of_Luxury.png" style="zoom:30%;" /></p>
<p>在当时的荷兰，整体的艺术文化，不同画家的艺术风格都是你中有我我中有你，人才辈出促成了荷兰黄金时代，维米尔生于这个时代，融汇大师的技巧，又展现出自己独特的才华。随着通识艺术的普及，绘画与音乐和谐共处，荷兰黄金时代几乎家家户户都有音乐之声，这也促成了维米尔与音乐的佳话。</p>
<h4 id="Color-and-Sound-in-Vermeer’s-Paintings"><a href="#Color-and-Sound-in-Vermeer’s-Paintings" class="headerlink" title="Color and Sound in Vermeer’s Paintings"></a>Color and Sound in Vermeer’s Paintings</h4><blockquote>
<p>音乐之声宜和，绘画之像宜谐，其道同也。</p>
<p>——范·曼德尔《绘画之书》</p>
</blockquote>
<p>在维米尔的画作中，乐器是常客。荷兰当时各式各样的乐器几乎都在他的作品中出现过：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/instrumen_in_paint.png" style="zoom:25%;" /></p>
<p>不可思议的是，音乐可以体现在绘画作品当中，乐器的“神态“都能被表达出来。斯腾的《小夜曲》展示了一群人的吹拉弹唱，在酒馆门口奏响音乐，仿佛能听到激昂的歌声与急促的弹奏。而维米尔更是把音乐作为画面的元素来呈现故事。</p>
<h5 id="A-Young-Woman-Seated-at-a-Virginal"><a href="#A-Young-Woman-Seated-at-a-Virginal" class="headerlink" title="A Young Woman Seated at a Virginal"></a>A Young Woman Seated at a Virginal</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/A_Young_Woman_Seated_at_a_Virginal.png" style="zoom: 25%;" /></p>
<p>这是维米尔作的坐在维金纳琴边上的女子。维金纳琴的琴盖上画有神话题材的绘画，再看画面本身，女子手弹琴键看向画外，似乎在期待着什么；而琴边上的大提琴似乎也暗示着她应该有一个伴奏。一个女子忐忑不安的期待着那个与她合奏的人这样的场景就被维米尔所描绘出来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Virginal.png" style="zoom:25%;" /></p>
<h5 id="Lady-at-the-Virginal-with-a-Gentleman-The-Music-Lesson"><a href="#Lady-at-the-Virginal-with-a-Gentleman-The-Music-Lesson" class="headerlink" title="Lady at the Virginal with a Gentleman (The Music Lesson)"></a>Lady at the Virginal with a Gentleman (The Music Lesson)</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_Music_Lesson.png" style="zoom:25%;" /></p>
<p>维米尔的音乐课展现了一段独特的故事。先看看画面本身，女子站在琴边，一旁的男子在指点她弹奏，又或是与她和唱。琴、桌子、波斯毯子、盘子和椅子都出现在画面里，我们不禁思考，除了音乐课本身，为何还要增加如此的装饰。如果桌子和上面的装饰是塑造了一个乐室的真实情景，那又是谁坐了那把椅子，又是谁动了大提琴。我们不禁猜测，乐师刚刚从椅子上起身，而椅子正对的便是观众，或者更有可能的，是画家维米尔自己。仿佛上一秒乐师正和维米尔聊天，讲解着大提琴的故事，下一秒听到的学徒的错误便上去指点。画面中的镜子也暗示着这样的猜测：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/detail_Music_Lesson.png" style="zoom:25%;" /></p>
<p>镜面的左上方，画架的一角显露出来，正好与画家的方向对应，印证了画家自己就正对着钢琴；但是在镜子中，女子的头在镜子中看向侧方，与女子本体的姿势矛盾。我们可以这样理解：维米尔把上一时刻女子弹错的瞬间保留在镜子中，女子发现自己的错误，赶紧看向了自己的手与弹错的地方，而下一个时刻则是画面主体，乐师上前纠正女子。镜子制造了时间的延续性，镜子里的时刻是另一个场景的延续，延伸了叙事。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/light_in_music_lesson.png" style="zoom: 20%;" /></p>
<p>维米尔对光线的把握也是一流的，如果不是把两个色块放在一起比较，我们无法看出画面左右侧的色差是如此之大。维米尔如同写实般，把光线的渐变给描绘出来，令人叹为观止。同时，很多学者认为维米尔使用了暗箱这样的光学仪器来辅助他作画，有证据表明，维米尔常常先定色调，仿佛他已经看穿了光的色彩一般，与此同时，维米尔也是第一个把光学虚焦体现在画中的：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Lacemaker.png" style="zoom:40%;" /></p>
<p>这幅作品我们可以看到桌前的装饰品，木盒都是虚焦的，而女孩本身的手和针线却是相当清晰的。这是过去的艺术家没有的细节。</p>
<h4 id="About-Synaesthesia"><a href="#About-Synaesthesia" class="headerlink" title="About  Synaesthesia"></a>About  Synaesthesia</h4><h5 id="Young-Woman-Playing-a-Guitar"><a href="#Young-Woman-Playing-a-Guitar" class="headerlink" title="Young Woman Playing a Guitar"></a>Young Woman Playing a Guitar</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Young_Woman_Playing_a_Guitar.png" style="zoom:30%;" /></p>
<p>同感，便是看画听音，维米尔的乐器仿佛自己就带有声音。让我们看看弹吉他的少女。这幅画看似平常，但细节上，我们竟无法数清这画面中究竟有多少琴弦。从古至今的画作，艺术家都愿意把物体清晰的呈现出来，但是维米尔常常使用模糊的手法还表达物体。在这幅作品中，看不清的琴弦暗示着颤动的声音，四弦一声如裂帛中，琴弦迸开，在这一瞬间打通了音乐与绘画。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/detail_Guitar.png" style="zoom:200%;" /></p>
<p>有同感学问的专家曾指出，每一种音色都对应着一种色彩，如同亮红色对应着激昂和弦等，但并非每个人都能感同身受，甚至过度的通告反而会失去了自由的联想。归根结底，同感只是与维米尔建立联系的一种方式，并非是唯一解读维米尔的钥匙。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Synaesthesia.png" style="zoom:25%;" /></p>
<h4 id="About-Balence"><a href="#About-Balence" class="headerlink" title="About Balence"></a>About Balence</h4><p>维米尔非常擅长把握艺术的平衡，正如他早期的作品《基督在两姐妹家》，维米尔的成对画作往往都能在含义上达成一种平衡。来看看两幅弹奏钢琴的女子：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/pair_piano.png" style="zoom:50%;" /></p>
<p>两幅作品都画中有画，一个画面中是丘比特、而另一幅是妓院老鸨为；有解释称，两位女子都象征着爱情的两级，左侧为一心一意，贞洁纯真，白天的背景也暗示着庄重与圣洁；而右侧黑暗的背景，妓院的主题暗示着淫荡与放荡不羁。但维米尔的表达应该是更加含蓄多元的，两幅画可能并非一定是音乐与爱情的联系，但一定保留着维米尔对对立平衡的和谐追求。</p>
<h4 id="Vermeer’s-Chair"><a href="#Vermeer’s-Chair" class="headerlink" title="Vermeer’s Chair"></a>Vermeer’s Chair</h4><h5 id="Officer-and-Laughing-Girl"><a href="#Officer-and-Laughing-Girl" class="headerlink" title="Officer and Laughing Girl"></a>Officer and Laughing Girl</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Officer_and_Laughing_Girl.png" style="zoom:33%;" /></p>
<p>维米尔在这幅《女子与官员》中出现了两把西班牙椅，墙上还挂着一幅地图。椅子、地图这两个元素时常出现在维米尔的画作中。地图看似不明所以，但事实上，蓝色的部分代表的是陆地，而右侧为北部，维米尔画的是一幅荷兰地图，而地图的中心就是他的故乡代尔夫特。但是这幅画被历史学家卫士勒解读为是战争的象征，他认为狮子头是暴力战争的暗示，把荷兰画在中间，是引战的象征。我们可以认为这样的解读是强词夺理，但这也暗示着黄金时代也没有那么美好，在美好生活的同时战争也在各地发生。</p>
<h4 id="The-Art-of-Painting"><a href="#The-Art-of-Painting" class="headerlink" title="The Art of Painting"></a>The Art of Painting</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_Art_of_Painting.png" style="zoom:50%;" /></p>
<p>维米尔在晚期作过一个关于绘画本身的预言。神秘的维米尔没有留下任何关于自己的肖像画，学者普遍认为这幅作品中画家的背影就是维米尔自己。这幅画中，椅子、地图、女子等元素再一次出现，在桌子上放有戏剧面具，可能暗示着维米尔与伦勃朗一样擅长把画面安排为一场戏剧，来表达自己；吊灯上的双头鹰是荷兰哈姆斯堡王朝的标志，暗示了当时欧洲混乱的三十年战争；女子端着小号，维米尔依旧保持着对音乐的热爱。</p>
<p>在这幅画中，维米尔在近端放置了一把椅子，这把与艺术家的椅子一近一远，提供了空间上的参考，而地砖构成了视觉上的骗局。画面左侧的链子被人掀开放在椅子上，把整个屋子的全景都投射在椅子处。正如弹琴的女子，可能维米尔自己也在等那么一个人去做在椅子上，一个懂得鉴赏他的人，去观察艺术作画的艺术。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>西方艺术史</tag>
        <tag>维米尔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/23/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>测试文件</category>
      </categories>
  </entry>
  <entry>
    <title>对2022的年度总结（二次元篇）</title>
    <url>/2022/12/31/final2022/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="我与二次元"><a href="#我与二次元" class="headerlink" title="我与二次元"></a>我与二次元</h2><p>因为疫情，很多二次元的展子都没了，很多平时暑假的例行活动都没了，希望明年还是可以去吧。</p>
<h3 id="二次元巡礼"><a href="#二次元巡礼" class="headerlink" title="二次元巡礼"></a>二次元巡礼</h3><h4 id="洛天依展"><a href="#洛天依展" class="headerlink" title="洛天依展"></a>洛天依展</h4><hr>
<ul>
<li>坐标：上海大悦城</li>
<li>时间：2022-07-19</li>
</ul>
<hr>
<p>算是第一次了解中国的虚拟歌姬洛天依了，虽然在很多场合还是带着一股“社会主义”，不过在国内的创作环境下也是难免的。不如说是很多平凡的国内小P主将洛天依的形式立体化，令人欣慰。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1851672472555_.pic.jpg" alt="洛天依开天神话"></p>
<p>从会场里把洛天依的手办买回来咯，就叫小傻吧。（图中左一）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1881672472695_.pic.jpg" alt=""></p>
<h4 id="动漫星城"><a href="#动漫星城" class="headerlink" title="动漫星城"></a>动漫星城</h4><hr>
<ul>
<li>坐标：广州 No.1, Jixiang Road</li>
<li>时间：2022-08-07</li>
</ul>
<hr>
<p>和群友去广州的目的地之一，广州动漫星城。（天气不太好，不过室内的地方为什么要在意天气呢）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1981672473491_.pic_hd.jpg" alt="动漫星城"></p>
<p>先看看群友最爱的米库女士吧</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1891672473290_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1961672473290_.pic.jpg" alt=""></p>
<p>Animate的看板娘涩谷香音</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1901672473290_.pic.jpg" alt=""></p>
<p>令人感慨，自己当时还看星团。现在是彻底裂啦——（开香槟咯）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1911672473290_.pic.jpg" alt=""></p>
<p>主播甚至买了几个诈骗货<br>（唐可可，没有你我怎么活——）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1951672473290_.pic.jpg" alt=""></p>
<p>买的时候掌柜还放着基本杂志，随便拿了一本发现东西还不少</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1941672473290_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1931672473290_.pic.jpg" alt=""></p>
<p>草……（怎么不见彩啊）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1921672473290_.pic.jpg" alt=""></p>
<p>总体来说成分很多，革命尚未成功…就当是小漫展来逛了吧！什么时候上海也能整一个大二次元集市啥的。</p>
<h4 id="邦多利咖啡厅"><a href="#邦多利咖啡厅" class="headerlink" title="邦多利咖啡厅"></a>邦多利咖啡厅</h4><hr>
<ul>
<li>坐标：上海市黄浦区思南公馆</li>
<li>时间：2022-09-05</li>
</ul>
<hr>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1991672474331_.pic.jpg" alt=""></p>
<p>想不到是在常去的思南公馆里面，本来以为只有一个思南书局，想不到里面的咖啡馆也值得一去。就是…感觉邦要倒了，可能是时间不对，进去了基本就没什么人。</p>
<p>山吹面包房（误）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2001672474331_.pic.jpg" alt=""></p>
<p>进了店还是一个屏幕几排座位，上面显然是社死打歌的。本来还是有点兴趣去搓一把的，发现上面是手机还没有防滑垫就不太想弄了。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2051672474331_.pic.jpg" alt=""></p>
<p>看看菜单，警惕消费陷阱</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2021672474331_.pic.jpg" alt=""></p>
<p>其实饮料还不错</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2041672474331_.pic.jpg" alt=""></p>
<p>冰淇淋嘛多少就有点抽象</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2071672474331_.pic.jpg" alt=""></p>
<p>好像拿走这个沙绫——</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2031672474331_.pic.jpg" alt=""></p>
<p>还是看看白葱吧</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2081672474434_.pic.jpg" alt=""></p>
<p>临走的时候从楼梯口下去的，看到橱窗是真不错。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2011672474331_.pic.jpg" alt=""></p>
<h4 id="社团招募的二次元"><a href="#社团招募的二次元" class="headerlink" title="社团招募的二次元"></a>社团招募的二次元</h4><hr>
<ul>
<li>坐标：UNNC</li>
<li>时间：2022-09-17</li>
</ul>
<hr>
<p>一些现视研的摊子</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2091672476493_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2111672476493_.pic.jpg" alt=""></p>
<p>捕捉野生自闭fu</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2101672476493_.pic.jpg" alt=""></p>
<p>看看术力口群的群HOMO吧</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2121672476493_.pic.jpg" alt=""></p>
<p>拉近一下镜头，先辈Suki！</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2131672477175_.pic.jpg" alt=""></p>
<h4 id="魔法未来十周年"><a href="#魔法未来十周年" class="headerlink" title="魔法未来十周年"></a>魔法未来十周年</h4><hr>
<ul>
<li>坐标：UNNC图书馆</li>
<li>时间：2022-10-23</li>
</ul>
<hr>
<p>魔法未来十周年观影会，术力口群组织策划</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2141672481700_.pic.jpg" alt=""></p>
<p>看看南小二的米库女士</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2161672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2151672481700_.pic.jpg" alt=""></p>
<p>被撅珍贵影像</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2201672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2191672481700_.pic.jpg" alt=""></p>
<p>专心致志的崇明前辈，十分甚至九分满意</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2171672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2181672481700_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2231672481717_.pic.jpg" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2211672481700_.pic.jpg" alt=""></p>
<p>我看我自己</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2251672481717_.pic.jpg" alt=""></p>
<p>还有一张术力口群合影</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2221672481700_.pic.jpg" alt=""></p>
<h3 id="番剧动漫"><a href="#番剧动漫" class="headerlink" title="番剧动漫"></a>番剧动漫</h3><h4 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h4><p>上半年一直处于备考阶段，现在能回想起来比较深刻的应该是《罪恶王冠》、《白色相簿1》、《86-不存在的战区》、《鬼灭之刃游郭篇》、《夏日幻魂》、《Lovelive：Superstar》、《Lovelive：虹咲学园偶像》、《派对浪客诸葛孔明》</p>
<p>上半年冬天看的几部番可以说质量非常高，本人也是非常的看重。第一部要谈的就是《白色相簿1》</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/v2-69af0443fdb28d5336d42169419e2147_r.jpg" alt=""></p>
<blockquote>
<p>冬天的相簿总是如此洁白，让人心中不适。</p>
<p>冬日的街道，寒冷的风中，传来的歌声使人停住了脚步。</p>
<p>屏幕中，她在那头唱着歌。我在这头静静地看着。</p>
<p>冬季里的风，在我回大学的路上，一直吹着。</p>
<p>对我来说，这样的风，一直都是普通的。</p>
<p>至少，到现在为止，她过着她特别的生活，我过着我普通的生活。</p>
<p>我们没有一起被卷进什么事件中，自己过着自己的日子。</p>
</blockquote>
<p>白色相簿1讲述的是一个平凡的，无力的男主，在都市中，被一个个女神所围绕的故事。他没有做错什么，他只是一个无力的青年，试图去回应每一个人的期待，试图去进入另一个不属于他的世界。</p>
<p>动漫中对人物的刻画淋漓尽致，把人物在那个时代，用电话维持着交流，拿起听筒的不安与期待，每一封书信的寄出，却不知道是否能将心意传达的。</p>
<p>故事中，每个人的爱都是自私的，也是最真实的。每个人都在寻找着自己生活的寄托，而这也伤害了身边的人，人的成长更多的是找到自己所爱与被爱之间的平衡。这部动漫通过语言，画面和心理描写让人用心体会到角色中感受到那份难以割舍的感情与那个社会带来的无力感之间的矛盾。</p>
<p>接下来想说的是《罪恶王冠》吧。看完只有一个感觉，男主真帅，女主真好看，音乐真不错，ryo是神，很过瘾。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/18d8bc3eb13533fa9d3f2f32afd3fd1f41345b24.jpg" alt=""></p>
<p>这部番没有上一部那么严肃，但是谁不爱看中二少年拥有王之力后为了妹子奉献自我拯救世界呢。</p>
<p>很多人说这个烂尾了，但是在我心里就是最屌最帅的。</p>
<p>毕竟，那可是最中二的王之力啊。</p>
<h4 id="暑期档"><a href="#暑期档" class="headerlink" title="暑期档"></a>暑期档</h4><p>2022年暑假，也没有怎么看太多的番，现在能回忆起来的，多少是几部新番：《处刑少女的生存之道》、《夏日重现》、《辉夜大小姐第三季》、《朋友游戏》、《JOJO奇妙冒险：石之海》、《邪神与中二厨》、《少女歌剧剧场版》、《穿越时空的少女》</p>
<p>其实这里面没有哪一部真正想说的。虽然说夏日重现评分很高，但是前期过度的拉扯，后期的奇幻结局反而没有了石头门所达到的轮回系的高度。《辉夜三》很不错，真的能感受到制作组的用心，是一部非常优质的番（还是那句话，赤坂我杀你一千遍）。《JOJO》一如既往的高质量智斗，不过也就那样吧，吹完了前几部这个也依旧精彩。《邪神》夹心酱，非常用心的拍，非常用心的恰米，由于是众筹的，非常不容易，以高完成度为观众带来笑容，非常推荐。</p>
<h4 id="下半年"><a href="#下半年" class="headerlink" title="下半年"></a>下半年</h4><p>出圈的《莉可莉丝》以为下半年基本都没怎么看B站了。印象最深的还是隔离时候看的《心理测试者》。</p>
<p>（果然神番都离不开EGOIST）</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/1280px-Psycho_Pass_10th_Anniversary.jpg" alt=""></p>
<p>&gt;</p>
<blockquote>
<p>你看得到我们的颜色吗，西比拉系统？</p>
</blockquote>
<p>又是一部在乌托邦中思考正义与邪恶的故事，就像女主人公一样，“我痛斥这样的系统，可是我在生活中接受它的意义。”究竟该把正义交给一个数值，还是交给常规伦理自我意识的判断，是人类科技发展中无法绕开的问题。</p>
<blockquote>
<p>“是的，我不想无谓的死去，也承认现今社会很多人依赖Sibyl系统。但是，你们知道对本该神圣的法律，最不敬的做法是什么吗？那就是，创造并运行根本不值得保护的法律。不要太小看人类了。我们无时无刻都在努力创造更好的社会。终有一天会有人来到这个房间，拔出电源。我们一定会发现新的道路。Sibyl系统，你们没有未来！”</p>
</blockquote>
<h3 id="动漫音乐"><a href="#动漫音乐" class="headerlink" title="动漫音乐"></a>动漫音乐</h3><p>快和米库女士一周年了，列出今年最喜欢的几首动漫&amp;术力口吧。</p>
<ol>
<li>アンノウン・マザーグース 不为人知的鹅妈妈童谣</li>
<li>Grievous Lady(-nothing is but what is not-)</li>
<li>だれかの心臓になれたなら 如果能成为谁的心脏的话</li>
<li>Paper Bouquet 《处刑少女的生存之道》片头曲</li>
<li>祝福のメシアとアイの塔 祝福的救世主与爱之塔</li>
<li>ローリンガール 翻滚少女</li>
<li>ロミオとシンデレラ 罗密欧与灰姑娘</li>
<li>限りなく灰色へ 无尽的灰色</li>
<li>The Everlasting Guilty Crown</li>
<li>フユノ 冬野</li>
<li>Halcyon</li>
<li>I’m still alive today</li>
<li>冬之花</li>
<li>PRAGMATISM</li>
<li>名前のない怪物 无名怪物</li>
</ol>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/2271672491609_.pic.jpg" alt=""></p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>初音未来</tag>
        <tag>二次元</tag>
        <tag>动漫</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模算法：K-Means聚类算法</title>
    <url>/2023/08/23/kmeans/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>聚类属于无监督学习，指在没有参照系下对样本集合进行分组，这种分组往往是无标签化的，即分类后无法知道这一类的意义，仅仅是在特征上具有较大相似性。K-means算法是常见的聚类算法，在给定分类组数的情况下算法自动进行分类。</p>
<p>K-means算法支持大于2维的特性维度，但不支持过大维度的特性。同时对噪声点较为敏感，需要进行一定的数据处理。在聚类上，关键依据是样本的特征向量在空间中互相的距离。</p>
<h3 id="几何距离"><a href="#几何距离" class="headerlink" title="几何距离"></a>几何距离</h3><p>距离即为两个样本的间隔，定义样本的特征为：</p>
<script type="math/tex; mode=display">
X = [x_1, x_2, \dots, x_d]^T, d \ refers\  to\  the\  Dimension</script><p>常见距离算法如下：<br>（可参考知乎文章：<a href="https://zhuanlan.zhihu.com/p/374627115）">https://zhuanlan.zhihu.com/p/374627115）</a></p>
<ol>
<li>明氏距离：<script type="math/tex; mode=display">
 pdist(x, 'minkowski', r) = [\sum_{k=1}^d{|x_{ik} - x_{jk}|^m}]^{\frac{1}{m}}</script></li>
</ol>
<ul>
<li>当m=1时为曼哈顿距离<br>  当数据集具有离散和/或二进制属性时，Manhattan似乎工作得很好，因为它考虑了在这些属性的值中实际可以采用的路径。以欧几里得距离为例，它会在两个向量之间形成一条直线，但实际上这是不可能的。</li>
<li>当m=2时为欧几里得距离<br>  尽管欧几里德距离是一种常见的距离度量，但它不是尺度不变的，这意味着计算的距离可能是倾斜的，这取决于特征的单位。通常，在使用这个距离度量之前，需要对数据进行标准化（normalize）。</li>
</ul>
<ol>
<li>切氏距离:<script type="math/tex; mode=display">
 max(abs(x_i-x_j)) = {max}_{1\leq k \leq d} |x_{ik}-x_{jk}|</script></li>
<li>马氏距离：<br> 马氏距离是欧几里得距离维度，权重归一化后的集合距离，即经过了标准化处理，较为常用：<script type="math/tex; mode=display">
 pdist(x, 'mahal') = [(x_i-x_j)^T \sum^{-1}(x_i-x_j)]^{\frac{1}{2}}</script></li>
</ol>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>K-means 有一个著名的解释：牧师—村民模型：</p>
<blockquote>
<p>有四个牧师去郊区布道，一开始牧师们随意选了几个布道点，并且把这几个布道点的情况公告给了郊区所有的村民，于是每个村民到离自己家最近的布道点去听课。听课之后，大家觉得距离太远了，于是每个牧师统计了一下自己的课上所有的村民的地址，搬到了所有地址的中心地带，并且在海报上更新了自己的布道点的位置。牧师每一次移动不可能离所有人都更近，有的人发现A牧师移动以后自己还不如去B牧师处听课更近，于是每个村民又去了离自己最近的布道点。就这样，牧师每个礼拜更新自己的位置，村民根据自己的情况选择布道点，最终稳定了下来。我们可以看到该牧师的目的是为了让每个村民到其最近中心点的距离和最小。</p>
</blockquote>
<p>从上述故事不难发现K-means分为两步：</p>
<ol>
<li>统计k个组的中心对象，并重新按k个中心对象确立k个组</li>
<li>以中心对象为准则，每个点与k个中心分别计算距离并归近最近中心点的组<br>直到中心对象不再移动，分类完毕。而整个过程的初始是随机给k个点。<br>（虽然这里我们说随机初始值，但是如果初始点与期望分组中心越接近，结果越准确）</li>
</ol>
<h4 id="鸢尾花聚类"><a href="#鸢尾花聚类" class="headerlink" title="鸢尾花聚类"></a>鸢尾花聚类</h4><p>鸢尾花数据集是机器学习中相当经典的例子，里面仅仅150个样本，每个样本有4列特征。我们仅仅使用petalWidth, petalLength两组特征数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris     <span class="comment">#从sklearn库中导入鸢尾花数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">Y = iris.target</span><br><span class="line">data = []</span><br><span class="line">petalLength = []</span><br><span class="line">petalWidth = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iris.data:</span><br><span class="line">    data.append([i[<span class="number">2</span>],i[<span class="number">3</span>]])</span><br><span class="line">    petalLength.append(i[<span class="number">2</span>])</span><br><span class="line">    petalWidth.append(i[<span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(data[:<span class="number">5</span>]) <span class="comment"># 打印前5个数据</span></span><br><span class="line"><span class="comment"># ================================ #</span></span><br><span class="line">[[<span class="number">1.4</span>, <span class="number">0.2</span>], [<span class="number">1.4</span>, <span class="number">0.2</span>], [<span class="number">1.3</span>, <span class="number">0.2</span>], [<span class="number">1.5</span>, <span class="number">0.2</span>], [<span class="number">1.4</span>, <span class="number">0.2</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/iris.png" style="zoom:67%;" /></p>
<p>在K-means算法前，还需要定义两个函数，计算距离与计算组的中心对象，这里我们使用欧式距离：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math, random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eucliDist</span>(<span class="params">A, B</span>):</span><br><span class="line">    <span class="comment"># 多维欧拉距离</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;&#123;:.10f&#125;&#x27;</span>.<span class="built_in">format</span>(math.sqrt(<span class="built_in">sum</span>([(a - b)**<span class="number">2</span> <span class="keyword">for</span> (a,b) <span class="keyword">in</span> <span class="built_in">zip</span>(A,B)]))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">centerPoint</span>(<span class="params">point_set</span>):</span><br><span class="line">    <span class="comment"># 获取点的维度</span></span><br><span class="line">    dim = <span class="built_in">len</span>(point_set[<span class="number">0</span>])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> point_set:</span><br><span class="line">            res[i] += j[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dim):</span><br><span class="line">        res[i] = res[i] / <span class="built_in">len</span>(point_set) <span class="comment"># 每个维度依次求平均，重心求法</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>进入K-means算法部分，按照原理模拟即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myKMeans</span>(<span class="params">n_clusters</span>):</span><br><span class="line">    key_index = random.sample(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data)), n_clusters)</span><br><span class="line">    <span class="comment"># key_index = [20, 80, 140]</span></span><br><span class="line">    <span class="comment"># 这里并没有选择随机，而是选择了三个直观符合分类分布的三个点为初始值</span></span><br><span class="line">    is_change = <span class="literal">True</span></span><br><span class="line">    key_point = []</span><br><span class="line">    group = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters)]</span><br><span class="line">    cmp = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 初始化：以n个关键点分组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">        group[i].append(data[key_index[i]])</span><br><span class="line">        <span class="comment"># i同时对应group与key</span></span><br><span class="line">        key_point.append(data[key_index[i]])</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 迭代器</span></span><br><span class="line">    <span class="keyword">while</span> is_change:</span><br><span class="line">        <span class="comment"># 遍历所有点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">            <span class="comment"># 与n个目标点比较</span></span><br><span class="line">            tmp_dis = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">                tmp_dis.append(eucliDist(key_point[j], data[i]))</span><br><span class="line">            min_index = np.argmin(np.array(tmp_dis))</span><br><span class="line">            group[min_index].append(data[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算每组的中心对象</span></span><br><span class="line">        tmp_key_point = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">            new_center = centerPoint(group[i])</span><br><span class="line">            tmp_key_point.append(new_center)</span><br><span class="line">            cmp += <span class="built_in">float</span>(eucliDist(new_center, key_point[i]))</span><br><span class="line">        <span class="comment"># 比较中心点与目标点差异</span></span><br><span class="line">        <span class="keyword">if</span> cmp &lt; <span class="number">0.00002</span>:</span><br><span class="line">            is_change = <span class="literal">False</span></span><br><span class="line">            key_point = tmp_key_point</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            is_change = <span class="literal">True</span></span><br><span class="line">            key_point = tmp_key_point</span><br><span class="line">            cmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">                group[i][<span class="number">0</span>] = key_point[i]</span><br><span class="line">    predicted = []</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">            <span class="keyword">if</span> d <span class="keyword">in</span> group[j]:</span><br><span class="line">                predicted.append(j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> predicted, group, key_point</span><br></pre></td></tr></table></figure>
<p>接收结果并且数据可视化结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">3</span></span><br><span class="line">p, g, k = myKMeans(n)</span><br><span class="line">colors_p = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> p:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        colors_p.append(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        colors_p.append(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        colors_p.append(<span class="string">&quot;green&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;MyPredicted&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;petal length&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal width&#x27;</span>)</span><br><span class="line">plt.scatter(petalLength, petalWidth, c=colors_p)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MyKmeans.png" style="zoom:67%;" /></p>
<h3 id="选择K值"><a href="#选择K值" class="headerlink" title="选择K值"></a>选择K值</h3><p>在上述例子中，由于我们已知鸢尾花的分类共有3个，所以定义K为3，但是现实中可能我们无法判断出K的取值，这时候我们可以使用手肘法去判断K的合理数值：</p>
<ol>
<li><p>定义聚类的误差平方和：</p>
<script type="math/tex; mode=display">
 SSE = \sum\limits_{i=1}^{k} \sum\limits_{x\in{c_i}} ||x-\mu_i||^2</script><p>用代码表示实际是遍历每个点与中心点的距离的平方并求和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_error</span>(<span class="params">centers, d, p</span>):</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d)):</span><br><span class="line">        c = p[i]</span><br><span class="line">        cnt += (eucliDist(centers[c], d[i]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回不同K下的取值:寻找图中的曲折点即可:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sse = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10</span>):</span><br><span class="line">    p,g,k = myKMeans(i)</span><br><span class="line">    sse.append(square_error(k, data, p))</span><br><span class="line">    </span><br><span class="line">plt.title(<span class="string">&quot;SSE&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;SSE&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],sse)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MySSE.png" style="zoom:50%;" /></p>
<h3 id="Sklearn-实现K-means"><a href="#Sklearn-实现K-means" class="headerlink" title="Sklearn 实现K-means"></a>Sklearn 实现K-means</h3><p>Sklearn作为python中的机器学习库已经封装好了K-means算法，使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="comment"># K-means 调库</span></span><br><span class="line">estimator = KMeans(n_clusters=<span class="number">3</span>, n_init=<span class="string">&#x27;auto&#x27;</span>).fit(data)  <span class="comment">#聚类</span></span><br><span class="line">label_pred = estimator.labels_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">colors_p = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> label_pred:</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        colors_p.append(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        colors_p.append(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        colors_p.append(<span class="string">&quot;green&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;Predicted&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;petal length&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;petal width&#x27;</span>)</span><br><span class="line">plt.scatter(petalLength,petalWidth, c=colors_p)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/skl-kmeans.png" style="zoom:67%;" /></p>
<p>同时，由于手写K-means中随机数对结果波动较大，我们可以通过封装的k-means库重新查看一下SSE，引证手肘法选k值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SSE = []  <span class="comment"># 存放每次结果的误差平方和</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">    estimator = KMeans(n_clusters=k)  <span class="comment"># 构造聚类器</span></span><br><span class="line">    estimator.fit(data)</span><br><span class="line">    SSE.append(estimator.inertia_) <span class="comment"># estimator.inertia_获取聚类准则的总和</span></span><br><span class="line">X = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;SSE&#x27;</span>)</span><br><span class="line">plt.plot(X,SSE,<span class="string">&#x27;o-&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/SSE.png" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学建模</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模算法：层次分析法</title>
    <url>/2023/08/22/mm-ahp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="模型定位"><a href="#模型定位" class="headerlink" title="模型定位"></a>模型定位</h4><p>层次分析法「The analytic hierarchy process」是在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的<strong>决策方法</strong>。</p>
<p>模型共分为三个层级：</p>
<ul>
<li>目标层：结果输出层，确定目标是什么？</li>
<li>准则层：影响因素集，决定这一结果的因素有什么？</li>
<li>方案层：备选集，从哪些样本中选择？</li>
</ul>
<p>模型适用于评价类、排名类、决策类问题</p>
<h4 id="模型流程"><a href="#模型流程" class="headerlink" title="模型流程"></a>模型流程</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/AHP_1.png" style="zoom:50%;" /></p>
<h5 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h5><p>在计算中，需要将不同准则的数量级统一，这个过程称为归一化，将一组统一标准的数据视为列向量，把数据化为在总数中的占比即可，范围为(0,1)：</p>
<script type="math/tex; mode=display">
x_i = \frac{x_i}{\sum_{k=1}^nx_k}\ ,\  i\in{1,2,\dots,n}</script><h5 id="生成判断矩阵"><a href="#生成判断矩阵" class="headerlink" title="生成判断矩阵"></a>生成判断矩阵</h5><p>两两比较每个准则(指标)的重要性，记为$a_{ij}$, 来表示相对于指标j，指标i的重要性，且满足：</p>
<script type="math/tex; mode=display">
a_{ij} = \frac{1}{a_{ji}}</script><div class="table-container">
<table>
<thead>
<tr>
<th>$a_{ij}$</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>指标$i$与指标$j$相同重要</td>
</tr>
<tr>
<td>3</td>
<td>指标$i$比指标$j$稍微重要</td>
</tr>
<tr>
<td>5</td>
<td>指标$i$比指标$j$明显重要</td>
</tr>
<tr>
<td>7</td>
<td>指标$i$比指标$j$强烈重要</td>
</tr>
<tr>
<td>9</td>
<td>指标$i$比指标$j$极端重要</td>
</tr>
</tbody>
</table>
</div>
<p>注：2，4，6，8表示在两者之间</p>
<h5 id="一致性检验"><a href="#一致性检验" class="headerlink" title="一致性检验"></a>一致性检验</h5><p>由于重要性的比较是单看两者的主观评价，结果不可避免会产生矛盾，我们虽然不能追求完美一致，但是这一判断矩阵必须通过一致性检验，确保重要性差异较为一致：</p>
<script type="math/tex; mode=display">
CR = \frac{CI}{RI} ， CI = \frac{\lambda_{max}-n}{n-1}</script><p>其中$\lambda_{max}$为判断矩阵的最大特征值，$RI$为常数，在不同因素数下有不同取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>n</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>RI</td>
<td>0</td>
<td>0</td>
<td>0.52</td>
<td>0.89</td>
<td>1.12</td>
<td>1.26</td>
<td>1.36</td>
<td>1.41</td>
<td>1.46</td>
<td>1.49</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>若$CR \leq 0.1 $ : 通过一致性检验</li>
<li>若$CR &gt; 0.1 $ : 重新生成判断矩阵</li>
</ul>
<h5 id="权重矩阵"><a href="#权重矩阵" class="headerlink" title="权重矩阵"></a>权重矩阵</h5><ol>
<li>矩阵按列归一化：即每个数值除以所在列的和</li>
<li>每行求平均降维即可</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Python-Version"><a href="#Python-Version" class="headerlink" title="Python Version"></a>Python Version</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准则重要性矩阵</span></span><br><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">             [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">             [<span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">             [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">[n, m] = A.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一致性检验</span></span><br><span class="line">V, D = np.linalg.eig(A)</span><br><span class="line"></span><br><span class="line">maxlam = np.<span class="built_in">max</span>(V)</span><br><span class="line">CI = (maxlam - n) / (n - <span class="number">1</span>)</span><br><span class="line">RI = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.58</span>, <span class="number">0.9</span>, <span class="number">1.12</span>, <span class="number">1.24</span>, <span class="number">1.32</span>, <span class="number">1.41</span>, <span class="number">1.45</span>, <span class="number">1.49</span>, <span class="number">1.52</span>, <span class="number">1.54</span>, <span class="number">1.56</span>, <span class="number">1.58</span>, <span class="number">1.59</span>]</span><br><span class="line"><span class="comment"># 判断是否通过一致性检验</span></span><br><span class="line">CR = CI / RI[n - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> CR &gt;= <span class="number">0.1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有通过一致性检验\n&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;通过一致性检验\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算权重</span></span><br><span class="line">Asum = np.<span class="built_in">sum</span>(A, axis=<span class="number">0</span>)</span><br><span class="line">Aprogress = A/(np.ones((n, <span class="number">1</span>), dtype=np.int64) * Asum)</span><br><span class="line"></span><br><span class="line">W = np.average(Aprogress, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="Matlab-Version"><a href="#Matlab-Version" class="headerlink" title="Matlab Version"></a>Matlab Version</h5><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%输入判断矩阵</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">2</span> <span class="number">2</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">    <span class="number">1</span>/<span class="number">5</span> <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">%一致性检验</span></span><br><span class="line">maxlam = <span class="built_in">max</span>(eig(A));</span><br><span class="line">[~, n] = <span class="built_in">size</span>(A);</span><br><span class="line">RI = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.58</span>,<span class="number">0.9</span>,<span class="number">1.12</span>,<span class="number">1.24</span>,<span class="number">1.32</span>,<span class="number">1.41</span>,<span class="number">1.45</span>, <span class="number">1.49</span>, <span class="number">1.52</span>, <span class="number">1.54</span>, <span class="number">1.56</span>, <span class="number">1.58</span>, <span class="number">1.59</span>];</span><br><span class="line">CI = (maxlam - n) / (n<span class="number">-1</span>);</span><br><span class="line">CR = CI / RI(n);</span><br><span class="line"><span class="keyword">if</span> CR &lt; <span class="number">0.10</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;通过一致性检验&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;不通过一致性检验&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span>  <span class="comment">% 终止运行 </span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%计算权重向量</span></span><br><span class="line">[n,~] = <span class="built_in">size</span>(A);</span><br><span class="line">Asum = sum(A,<span class="number">1</span>);    <span class="comment">% 按列求和</span></span><br><span class="line">Aprogress = A./(<span class="built_in">ones</span>(n,<span class="number">1</span>)*Asum);</span><br><span class="line"></span><br><span class="line">W = sum(Aprogress, <span class="number">2</span>)./n;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>日式麻将个人技巧[持续更新中...]</title>
    <url>/2022/08/28/mahjong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<font color=FF7F50 size=6 >人，一定要有梦想

——献给每一个尝试国士无双的雀士们</font>


</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>说到日式麻将最大的特色，就是”役”的存在，役越多，和牌分数越高。日麻和牌简单，但是做大牌就需要一定的技巧以及耐心。我们在此不妨把一局分成两个阶段：做牌与防守。</p>
<h3 id="做牌"><a href="#做牌" class="headerlink" title="做牌"></a>做牌</h3><blockquote>
<p>不吃不碰才有大成长！</p>
<p>——作者本人</p>
</blockquote>
<p>做牌，就是做大牌，前提就是玩家要知道各种牌型，这里作者就介绍几种作者常用的牌型</p>
<h4 id="常见牌型"><a href="#常见牌型" class="headerlink" title="常见牌型"></a>常见牌型</h4><p>以下是作者推荐的比较容易记住的基本牌型</p>
<ul>
<li>断幺九[一番]：和牌时牌中不含有数字一九和东南西北白中发 <span class="heimu" title="你知道的太多了">新手雀士最爱</span></li>
<li>役牌[一番]：凑成刻子(三连)或杠子，可以碰；点数可叠加<ul>
<li>场风：即本场的风向（如东N局，南N局）</li>
<li>自风：玩家面前的风向</li>
<li>三元牌：白、中、发</li>
<li><span class="heimu" title="你知道的太多了">三元牌对越多越好，甚至能误打误撞做成小三元</li>
</ul>
</li>
<li>一杯口：一组相同的顺子<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/一杯口.png" alt=""></li>
<li>平和：和牌时只有顺子，雀头不能是自风或场风或三元牌</li>
<li>对对和[二番]:全是刻子、杠子<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/对对和.png" alt=""></li>
<li>七对子[二番]:七副对子(只能门前清)<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/七对子.png" alt=""></li>
<li>混一色[不吃不碰三番/二番]:同花色的牌+字牌</li>
<li>清一色[不吃不碰六番/五番]</li>
</ul>
<h4 id="立直"><a href="#立直" class="headerlink" title="立直"></a>立直</h4><p>如果牌太散无法凑出牌型，这里建议全程不吃不碰争取<strong>立直</strong>，即门前淸时，支付1000点宣告听牌，立直后只能暗杠与和牌。</p>
<h4 id="其他役"><a href="#其他役" class="headerlink" title="其他役"></a>其他役</h4><p>还有一些常见的役如:</p>
<ul>
<li>一发：立直后，在一巡内完成和牌。并且，期间不能有人的吃、碰、杠、拔北</li>
<li>岭上开花：杠后摸岭上牌补牌时自摸</li>
<li>海底捞月：自摸最后一张牌</li>
<li>河底摸鱼：和最后一张打出的牌</li>
</ul>
<p>都是麻将中的被动役，运气到了自然水到渠成，无需特意准备</p>
<h4 id="做牌心得"><a href="#做牌心得" class="headerlink" title="做牌心得"></a>做牌心得</h4><ol>
<li><p>发牌之后<br>快速理清自己不需要什么牌，如非场风非自风牌，不成对子的白中发，一和九（三麻中的万字）在换好牌后，重新审视自己的牌并确定方向</p>
</li>
<li><p>争取立直</p>
<p>在做牌中，如果追求只胜利和牌，在做牌中推荐：</p>
<blockquote>
<p>碰役牌&gt;断幺九/立直&gt;其他牌型</p>
</blockquote>
<p>如果追求大牌，由于立直可以和很多牌型配合，还是建议在听牌前不吃不碰</p>
</li>
<li><p>敢于想象</p>
<p>这一条适用于在做混一色或者七对子时，在做牌时如果手牌上是顺子，因为对于七对子来说对子就是完成任务，对于听顺子34，来牌无非就是2，3，4，5有效，而来了2或5顺子完成了，来了3或4对子就完成了，实际上凑对子的概率和顺子是相同的，为什么不走掉顺子换对子呢？</p>
<p> <span class="heimu" title="你知道的太多了">七对子甚至可以转对对和</p>
<p>在混一色中，如果其他色牌不需要，还是要耐心等待换牌，在途中可以吃碰，一心瞄准这一个目标。最坏就是一心防守分数不涨。</p>
</li>
</ol>
<h3 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h3><p>由于结算机制，我们可以发现，不和牌不可怕，可怕的是自己被和牌，只要不扣分，基本可以苟到第二，很多时候，优秀的防守比进攻更加重要</p>
<h4 id="立直防守"><a href="#立直防守" class="headerlink" title="立直防守"></a>立直防守</h4><p>上面作者非常支持大家去立直，但是如果场上已经有人立直的情况下，如果剩牌较少，可以碰碰运气，但剩余较多便不建议立直，毕竟立直意味着挂机，容易给别人和牌的同时被人防守，相对来讲，越早立直越好<span class="heimu" title="你知道的太多了">就像越早听牌越好一样这不是废话吗</p>
<h4 id="观察弃牌"><a href="#观察弃牌" class="headerlink" title="观察弃牌"></a>观察弃牌</h4><ol>
<li><p>由于任何玩家都不能和已经和过的牌，且在出牌过程中其他玩家也面临着这样的选择，要根据此记录对面不和什么牌</p>
</li>
<li><p>纵使可以从弃牌堆里看出对面大概不要什么类型的牌，也不能因此打出这一类的牌，要记住，100%的确定性永远比赌来的重要，如果已经到轮牌中后期（剩40%左右）哪怕拆开自己的牌型，为了防守也是值得的</p>
</li>
</ol>
<h4 id="中期换牌"><a href="#中期换牌" class="headerlink" title="中期换牌"></a>中期换牌</h4><p>在中期开始做牌时，如果发到已经打过较多的字牌（东南西北白中发）不妨留一手，这些牌在后期是较为保险不易被和的，借此甩掉一些用处不大的牌</p>
<h4 id="末期阶段"><a href="#末期阶段" class="headerlink" title="末期阶段"></a>末期阶段</h4><p>如果到了仅剩15张时还没有听牌，不妨放弃原有的思路，哪怕是振听也要将自己听牌，以免无人和牌后结算时被罚分</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>游戏毕竟是分数结算，所以不扣分其实就变成了胜利的关键。运气好就做大牌，运气不好不扣分，是计分游戏上分的关键。</p>
<p>祝愿大家早日国士无双！</p>
<p><br><br><br><br><br></p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>[1] 本文部分图文摘自日麻中文维基百科<a href="https://wiki.lingshangkaihua.com/mediawiki/index.php/役種表">https://wiki.lingshangkaihua.com/mediawiki/index.php/役種表</a></p>
]]></content>
      <categories>
        <category>个人心得</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>日式麻将</tag>
      </tags>
  </entry>
  <entry>
    <title>pictureTest</title>
    <url>/2022/08/25/pictureTest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="先扔张成果图"><a href="#先扔张成果图" class="headerlink" title="先扔张成果图"></a>先扔张成果图</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/ena01.jpg" alt="ena"></p>
<h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>在想插入图片的时候，我一开始是非常不愿意使用图床等一系列第三方仓库的，首先想到的就是用相对路径。</p>
<p>网上最常用的解决方案就是将_config.yml 文件中的post_asset_folder 选项设为 true 来打开，然后利用随文章创建一同创建的同名文件夹插入图片。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>但是本方案在使用了<code>hexo d</code>后<code>public</code>中HTML文件上显示的相对路径却变成了乱码，无法读取图片(而且网上也基本没有这个问题可能是本人电脑的问题)</p>
<h4 id="PicGO图床"><a href="#PicGO图床" class="headerlink" title="PicGO图床"></a>PicGO图床</h4><blockquote>
<p>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</p>
</blockquote>
<p>PicGo 本体支持如下图床：</p>
<ul>
<li>七牛图床</li>
<li>腾讯云COS</li>
<li>又拍云</li>
<li>GitHub v1.5.0</li>
<li>SM.MS V2 v2.3.0-beta.0</li>
<li>阿里云 OSS v1.6.0</li>
<li>Imgur v1.6.0</li>
</ul>
<p>如果有条件的话非常推荐使用GitHub的仓库制作图床，但是国内网络的不支持使得图片的加载会出现很大的问题，这里也附上知乎上的<a href="https://www.zhihu.com/question/64502309">配置GitHub图床教程链接</a></p>
<p>其次就是利用国内平台如腾讯云阿里云等，这里我使用的是阿里云，<br><a href="https://blog.csdn.net/weixin_42030522/article/details/123075824&quot;CSDN解决Hexo无法显示图片的几种方案&quot;">配置阿里云图床</a>这篇文章具体的阐述了整个过程，可以参考。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>把自己的图片上传到第三方图床还是有点不放心的，但是也只能依赖大厂网站了；当时本来以为配置相对路径很容易，结果查来查去改了方案也配置了3个多小时。至此博客的基本要素都差不多配置完毕。最后啥也别说，先来一句：“<strong>SaKana——</strong>”</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/sakana.jpg" alt="sakana"></p>
]]></content>
      <categories>
        <category>测试文件</category>
      </categories>
      <tags>
        <tag>调试心得</tag>
      </tags>
  </entry>
  <entry>
    <title>晓山瑞希HappyBirthday</title>
    <url>/2022/08/27/mzkHappyBirthday/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><blockquote>
<font color=#DDAACC size=6 >祝最可爱的MIZUKI生日快乐！</font>

</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2146.JPG" alt=""></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2148.JPG" alt=""></p>
<p><span class="heimu" title="你知道的太多了">警惕网恋mzk被骗3000石(就是作者自己)</span></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2138.JPG" alt=""></p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>世界计划</tag>
        <tag>晓山瑞希</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈PnP的算法原理与实践</title>
    <url>/2023/01/14/solvePnP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="PnP问题概述"><a href="#PnP问题概述" class="headerlink" title="PnP问题概述"></a>PnP问题概述</h3><p><strong>PnP (Perspective-n-Point)</strong> 是求解3D到2D点对运动的方法，目的是<strong>求解相机坐标系相对世界坐标系的位姿</strong>。已知n个3D点的坐标 (相对世界坐标系) 以及这些点的像素坐标时，如何估计相机的位姿(即求解世界坐标系到相机坐标系的旋转矩阵 $R$ 和平移向量 $t$ )</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义</th>
<th>表达符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>相对世界坐标</td>
<td>$P^W= \begin{bmatrix}X^W&amp;Y^W&amp;Z^W\end{bmatrix}^T$</td>
</tr>
<tr>
<td>相对相机坐标</td>
<td>$P^C= \begin{bmatrix}X&amp;Y&amp;Z\end{bmatrix}^T$</td>
</tr>
<tr>
<td>像素坐标（齐次化）</td>
<td>$P^{u,v}= \begin{bmatrix}u&amp;v&amp;1\end{bmatrix}^T$</td>
</tr>
<tr>
<td>归一化坐标</td>
<td>$P’= \begin{bmatrix}X\over{Z}&amp;Y\over{Z}&amp;1\end{bmatrix}^T$</td>
</tr>
<tr>
<td>相机内参</td>
<td>$K=\begin{pmatrix}f_x&amp;0&amp;c_x\\0&amp;f_y&amp;c_y\\0&amp;0&amp;1\end{pmatrix}$</td>
</tr>
<tr>
<td>深度信息</td>
<td>$ω = Z^C $</td>
</tr>
</tbody>
</table>
</div>
<p><strong>已知</strong>：n个点在<strong>世界坐标系</strong>下的坐标$P_1^W,P_2^W,…,P_n^W$，这些点相应在<strong>像素坐标系</strong>下的坐标$p_1^{u,v},p_2^{u,v},…,p_n^{u,v}$，相机<strong>内参</strong>矩阵 $K$。<strong>求解</strong>：<strong>相机坐标系相对于世界坐标系的位姿</strong>，即$P^C=R_{CW}×P_W+t_{WC}$中的$R_{CW}$和$t_{CW}$，或记作$T = \begin{bmatrix}R|T\end{bmatrix}$ </p>
<h3 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h3><h4 id="基本法则"><a href="#基本法则" class="headerlink" title="基本法则"></a>基本法则</h4><p>通过针孔相机模型，有以下公式：</p>
<script type="math/tex; mode=display">
\omega P^{u,v}=Z\begin{pmatrix}u\\v\\1\end{pmatrix}=\begin{pmatrix}f_x&0&c_x\\0&f_y&c_y\\0&0&1\end{pmatrix}\begin{pmatrix}X\\Y\\Z\end{pmatrix}=KP_C=KTP_W</script><p>对于$T=\begin{pmatrix}R|t\end{pmatrix}=\begin{pmatrix}t_1&amp;t_2&amp;t_3&amp;t_4\\t_5&amp;t_6&amp;t_7&amp;t_8\\t_9&amp;t_{10}&amp;t_{11}&amp;t_{12}\end{pmatrix}$ ，共有12个未知数，则至少需要6个点对来求解方程</p>
<h4 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h4><p>将物体的坐标减少一维处理：</p>
<script type="math/tex; mode=display">
P^C=\omega P'</script><script type="math/tex; mode=display">
P^C=(RP^W+t)=\begin{bmatrix}X&Y&Z\end{bmatrix}^T \rightarrow P'=\begin{bmatrix}X\over{Z}&Y\over{Z}&1\end{bmatrix}^T \overset{def}{=} \begin{bmatrix}u'&v'&1\end{bmatrix}^T</script><p>可以看作把点转化为$Z=1$这一平面上</p>
<h3 id="DLT方法（Direct-Linear-Transform）"><a href="#DLT方法（Direct-Linear-Transform）" class="headerlink" title="DLT方法（Direct Linear Transform）"></a>DLT方法（Direct Linear Transform）</h3><p>DLT是最直接求解PnP问题的方法，通过对线性等式进行化简，转化为线性方程组的形式求解变换矩阵</p>
<h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><ol>
<li><p>对等式进行化简：</p>
<script type="math/tex; mode=display">
\omega P^{u,v}=K\begin{bmatrix}R|t\end{bmatrix}P^W</script><script type="math/tex; mode=display">
\omega K^{-1}P^{u,v}=TP^W</script><script type="math/tex; mode=display">
\because wP^{u,v}=KP^C \therefore \omega K^{-1}P^{u,v} = P_C</script><script type="math/tex; mode=display">
P^C = TP^W</script></li>
<li><p>归一化处理：</p>
<script type="math/tex; mode=display">
P^C=\omega P'=TP^W \\
\omega \begin{pmatrix}u'\\v'\\1\end{pmatrix} = \begin{pmatrix}t_1&t_2&t_3&t_4\\t_5&t_6&t_7&t_8\\t_9&t_{10}&t_{11}&t_{12}\end{pmatrix} \begin{pmatrix}X^W\\Y^W\\Z^W\\1\end{pmatrix}</script><p>观察$u’和v’$ ，可以得到</p>
<script type="math/tex; mode=display">
\begin{cases}
u'=\frac{t_1X+t_2Y+t_3Z+t_4}{t_9X+t_{10}Y+t_{11}Z+t_{12}} \\
v'=\frac{t_5X+t_6Y+t_7Z+t_8}{t_9X+t_{10}Y+t_{11}Z+t_{12}}
\end{cases}</script><p>将转换矩阵$T$的行向量重新写为</p>
<script type="math/tex; mode=display">
t_{r1}=\begin{bmatrix}t_1\\t_2\\t_3\\t_4\end{bmatrix}\
t_{r1}=\begin{bmatrix}t_5\\t_6\\t_7\\t_8\end{bmatrix}\
t_{r1}=\begin{bmatrix}t_9\\t_{10}\\t_{11}\\t_{12}\end{bmatrix}</script><p>把上述方程组看作是向量点乘并且移项，化简；再写作为矩阵形式，由于$t_{r1},t_{r2},t_{r3}$为未知量，写成$At=0$</p>
<script type="math/tex; mode=display">
\begin{cases}
t_{r1}^T\ P^W - t_{r3}^T\ P^W\ u' = 0 \\
t_{r2}^T\ P^W - t_{r3}^T\ P^W\ v' = 0
\end{cases}
\iff
\begin{pmatrix}
P^{W\ T} & 0 & -u'^T\ P^W \\
0& P^{W\ T} & -v'^T\ P^W
\end{pmatrix}
\begin{pmatrix}
t_{r1} \\ t_{r2} \\ t_{r3}
\end{pmatrix}
=0</script></li>
<li><p>构造方程组</p>
<p>将n个点对代入上式，可以得到：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
P_1^{W\ T} & 0 & -u_1'^T\ P_1^W \\
0& P_1^{W\ T} & -v_1'^T\ P_1^W \\
\vdots & \vdots & \vdots \\
P_N^{W\ T} & 0 & -u_N'^T\ P_N^W \\
0& P_N^{W\ T} & -v_N'^{T}\ P_N^W 
\end{pmatrix}
\begin{pmatrix}
t_{r1} \\ t_{r2} \\ t_{r3}
\end{pmatrix}
=0</script><p>通过消元求解即可</p>
</li>
</ol>
<h4 id="多个点优化处理"><a href="#多个点优化处理" class="headerlink" title="多个点优化处理"></a>多个点优化处理</h4><p>$ t $一共有12维，最少通过6对匹配点即可实现增广矩阵$T=[R|t]$的线性求解。当匹配点的数量大于6对时，可以使用SVD等方法求超定方程的最小二乘解。针对SVD求超定方程的最小二乘解，说明如下：当匹配点数量大于6对时，可以获得一个在$|t|=1$约束下的最小二乘解$t^∗=argmint||At||$。具体的，令$A=UDV^T$，则最小二乘解$t^∗$为$V$的最后一列$t^v$，再利用SVD确定最优旋转矩阵近似以及相应的尺度，便可以确定最终的相机姿态</p>
<h3 id="实践：检测二维码与相机的相对位置"><a href="#实践：检测二维码与相机的相对位置" class="headerlink" title="实践：检测二维码与相机的相对位置"></a>实践：检测二维码与相机的相对位置</h3><p>在PnP问题中，如果把物体看作是世界坐标的原点，那么求解相机相对于世界坐标原点的位姿就等价于求解了相机与物体的相对位置。对于一个典型的PnP问题，可以利用<code>opencv4</code>中自带的<code>solvePnP()</code>函数实现，在实践中，需要获得物体的像素坐标，并且以物体为中心，建立世界坐标系。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/graph.png" alt=""></p>
<p>作者在实践中是在ROS系统中获取了Realsense D455摄像头的<code>topic</code>来获取的摄像头画面。以下代码都需要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br></pre></td></tr></table></figure>
<p>完整代码请见：<a href="https://github.com/Phoenizard/SolvePnP">https://github.com/Phoenizard/SolvePnP</a></p>
<h4 id="获取角点坐标"><a href="#获取角点坐标" class="headerlink" title="获取角点坐标"></a>获取角点坐标</h4><p>使用二维码的目的是为了更简便的获取二维码的角点数据（最小正接旋转矩形的四个顶点），利用<code>opencv4</code>中的<code>QRCodeDetector</code>内置对象，构造了一个二维码检测器，返回值为<code>vector&lt;cv::Point2f&gt;</code>类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;Point2f&gt; <span class="title">get2DPoint</span><span class="params">(Mat rawImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QRCodeDetector qrDecoder = <span class="built_in">QRCodeDetector</span>();</span><br><span class="line">    <span class="comment">// 构造二维码检测器</span></span><br><span class="line">    vector&lt;Point2f&gt; bbox;</span><br><span class="line">    qrDecoder.<span class="built_in">detect</span>(rawImage,bbox);</span><br><span class="line">    <span class="comment">// detect(src, output array) </span></span><br><span class="line">    <span class="comment">// output array可以为vector和Mat</span></span><br><span class="line">    <span class="keyword">if</span>(!bbox.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        string tag[<span class="number">4</span>] = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="built_in">line</span>(rawImage, bbox[i], bbox[(i+<span class="number">1</span>)%<span class="number">4</span>], <span class="built_in">Scalar</span>(<span class="number">124</span>,<span class="number">252</span>,<span class="number">0</span>),<span class="number">4</span>,<span class="number">8</span>);</span><br><span class="line">            <span class="comment">// 绘制轮廓</span></span><br><span class="line">            <span class="built_in">putText</span>(rawImage, tag[i],bbox[i],FONT_HERSHEY_DUPLEX,<span class="number">2</span>,<span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bbox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下，可以看到二维码被框出，系统输出四个角点坐标：</p>
<p><strong>注意是从左上顺指针输出角点坐标</strong></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/getPoint.jpeg" alt="getPoint" style="zoom:30%;" /></p>
<h4 id="构造世界坐标系"><a href="#构造世界坐标系" class="headerlink" title="构造世界坐标系"></a>构造世界坐标系</h4><p>由于二维码是2D的，以正方形的中心，二维码平面为$xy$平面建系，构造三维点集，用<code>vector&lt;cv::Point3f&gt;</code>存储，需要与得到的2d点一一对应。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_LENGTH 65</span></span><br><span class="line"><span class="comment">// 定义二维码边长的一边</span></span><br><span class="line"><span class="comment">// 注意：单位为毫米mm</span></span><br><span class="line">vector&lt;Point3f&gt; point_in_3d = vector&lt;Point3f&gt;&#123;</span><br><span class="line">            <span class="built_in">Point3f</span>(-HALF_LENGTH, HALF_LENGTH, <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">Point3f</span>(HALF_LENGTH, HALF_LENGTH, <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">Point3f</span>(HALF_LENGTH, -HALF_LENGTH, <span class="number">0</span>),</span><br><span class="line">            <span class="built_in">Point3f</span>(-HALF_LENGTH, -HALF_LENGTH, <span class="number">0</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="调用solvePnP-函数"><a href="#调用solvePnP-函数" class="headerlink" title="调用solvePnP()函数"></a>调用solvePnP()函数</h4><p><code>solvePnP()</code> 在官方文档中为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solvePnP</span><span class="params">(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, <span class="type">bool</span> useExtrinsicGuess=<span class="literal">false</span>, <span class="type">int</span> flags = CV_ITERATIVE)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>InputArray objectPoints ：世界坐标系中点的三维坐标</li>
<li>InputArray imagePoints ：点的像素坐标</li>
<li>InputArray cameraMatrix ：相机内参</li>
<li>InputArray distCoeffs ：畸变系数</li>
<li>OutputArray rvec ：输出旋转矩阵</li>
<li>OutputArray tvec ：输出平移矩阵</li>
<li>useExtrinsicGuess ：仅用于<code>flags=SOLVEPNP_ITERATIVE</code>，此值如果为<code>true</code> 需要<code>rvec</code>和<code>tvec</code>有输入值，以便函数把输入值作为旋转和平移的估计初始值</li>
<li>flags ：求解方法，默认SOLVEPNP_ITERATIVE，可选SOLVEPNP_P3P、SOLVEPNP_EPNP等等</li>
</ul>
<p>由于技术条件限制，使用了BSSN在<a href="https://github.com/BSSNBSSN/Ego-plannerforIntelligentUAVChampionshipSimulator">Ego-plannerforIntelligentUAVChampionshipSimulator</a>库中的相机参数（同为Realsense D455摄像头）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Mat cameraMatrix = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt;</span><br><span class="line">        <span class="number">268.5118713378906</span>, <span class="number">0.0</span>,               <span class="number">320.0</span>,</span><br><span class="line">        <span class="number">0.0</span>,               <span class="number">268.5118713378906</span>, <span class="number">240.0</span>,</span><br><span class="line">        <span class="number">0.0</span>,               <span class="number">0.0</span>,               <span class="number">1.0</span></span><br><span class="line">    );</span><br><span class="line"><span class="type">const</span> Mat distCoeffs = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">5</span>, <span class="number">1</span>) &lt;&lt; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>一般来说：解算PnP，最少需要4个物体点与其成像点构成的点对，直接使用solvePnP求解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubPuber::solvePnP2_3</span><span class="params">(vector&lt;Point2f&gt; pnt2d, vector&lt;Point3f&gt; obj3d, Mat rVec, Mat tVec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">solvePnP</span>(obj3d, pnt2d, cameraMatrix, distCoeffs, rVec, tVec, <span class="literal">false</span>, SOLVEPNP_ITERATIVE);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;RVec&quot;</span> &lt;&lt; endl &lt;&lt; rVec &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tVec&quot;</span> &lt;&lt; endl &lt;&lt; tVec &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用cmake编译"><a href="#利用cmake编译" class="headerlink" title="利用cmake编译"></a>利用cmake编译</h4><p>ROS统一运用<code>cmake</code>进行编译，重点在于调用<code>opencv4</code> </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>.<span class="number">2</span>)</span><br><span class="line"><span class="keyword">project</span>(object-camera-transform)</span><br><span class="line"><span class="keyword">add_compile_options</span>(-std=c++<span class="number">11</span>)</span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">  cv_bridge</span><br><span class="line">  geometry_msgs</span><br><span class="line">  image_transport</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  sensor_msgs</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line">catkin_package(</span><br><span class="line">)</span><br><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">add_executable</span>(solvepnp2d3d src/solvepnp2d3d.cpp src/mainsolve2d3d.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(solvepnp2d3d</span><br><span class="line">  <span class="variable">$&#123;catkin_LIBRARIES&#125;</span></span><br><span class="line">  <span class="variable">$&#123;OpenCV_LIBS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>数学</tag>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的大学生活：初来UNNC</title>
    <url>/2022/09/13/nbndh/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="初来宁波"><a href="#初来宁波" class="headerlink" title="初来宁波"></a>初来宁波</h3><blockquote>
<p>宁波，取自“海定则波宁”，简称“甬”，早在周朝已有此称。“甬”字是古代大钟的一个象形字，在鄞、奉两县的县境上，山的峰峦很像古代的覆钟，故叫甬山，这条江就叫甬江，这一带地方就称为“甬”地。</p>
</blockquote>
<p>从上海前往宁波，若不是绕行杭州一带，直接走杭州湾跨海大桥，也就2小时左右。这一绕路，正逢中秋盛时天文大潮，虽没有到奔腾汹涌之势，一行白浪宛如千里雪骑，逆流而上，亦有浪遏飞舟之意。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2485.png" style="zoom:10%;" /></p>
<p>宁波分成老的市中心和东部新城，UNNC算是在南部的机场附近了。抵达宁波最大的感受是整个城市繁华却又不失人文的情怀。放眼城市，并不像上海一般高楼丛生，错中复杂，中间的老城区只能唉声叹气，等待着时代的淘汰，流离失所。宁波有展现其雄姿的高楼大厦，也有如欧洲小镇般的别墅街道，每走几个街道，就会有一个像样的公园点缀着生活。不得不说，宁波的城市干净，整洁，老建筑与新建筑融为一体，显得融洽。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2501.png" style="zoom:10%;" /></p>
<blockquote>
<p>宁波老外滩，坐落于浙江省宁波市江北区三江口（甬江、奉化江和余姚江的三江汇流之地）的北岸江北区，是进入宁波古城的门户。 在唐朝为中国四大港口之一，并成为鉴真东渡的起点；在南宋为中国三大港口之一，并设立市舶司专门负责管理对外贸易；当《南京条约》签订后，宁波便成为“五口通商”口岸之一，并于1844年正式开埠。</p>
</blockquote>
<p>正逢中秋，晚间来到了宁波的老外滩，据当地的同学说，这里难得有这么多人，岸边坐满了赏月拍照的人，无论哪里，无论城市与乡村，观赏天空永远能给予人们慰藉。宁波的外滩中，小巷里的酒吧永远是最热闹的，在江边吹着风，与友人喝上一杯，岂不美哉。再附上两张月亮的照片吧！</p>
<center class="half">
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2687.JPG" width="40%" />
    &emsp;
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2685.JPG" width="40%" />
</center>

<hr>
<h3 id="进入UNNC"><a href="#进入UNNC" class="headerlink" title="进入UNNC"></a>进入UNNC</h3><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2569.png" style="zoom:15%;" /></p>
<p>好吧，人很多，但是寝室楼真的很好看，进来了之后简单整理了一下</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_D288D71429C4-1.jpeg" style="zoom:30%;" /></p>
<p>太美丽了！感觉达到UNNC最高层。之后品鉴一下食堂，有空出一份食堂品鉴文章。</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>诺丁汉</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/2022/08/23/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="v1-0"><a href="#v1-0" class="headerlink" title="[v1.0]-"></a>[v1.0]-<20220823></h3><ul>
<li>今天完成了一个最简陋的个人博客！</li>
<li>虽然这行字也是调试的一部分（）</li>
</ul>
<h3 id="v1-1"><a href="#v1-1" class="headerlink" title="[v1.1]-"></a>[v1.1]-<20220824></h3><ul>
<li>尝试了hexo-theme-matery，但并不太适应，做了一些基本设置</li>
</ul>
<h3 id="v2-0"><a href="#v2-0" class="headerlink" title="[v2.0]-"></a>[v2.0]-<20220825></h3><ul>
<li>将主题改为NexT</li>
<li>加入了字数统计，阅读时间</li>
<li>对Sideboard进行美化，设置了标签，头像</li>
<li>增加了最新最潮的背景图片与文本阴影</li>
<li>博客基本设置完成</li>
</ul>
<h3 id="v2-1"><a href="#v2-1" class="headerlink" title="[v2.1]-"></a>[v2.1]-<20220825></h3><ul>
<li>完善个人介绍界面</li>
<li>增加了Project Sekai数据库链接</li>
<li>测试文章中插入图片</li>
<li>修改模版</li>
<li>添加了文档压缩</li>
</ul>
<h3 id="v2-2"><a href="#v2-2" class="headerlink" title="[v2.2]-"></a>[v2.2]-<20220905></h3><ul>
<li>增加了月推界面</li>
<li>增加部分密码机制</li>
<li>数学公式支持</li>
</ul>
<h3 id="致谢链接"><a href="#致谢链接" class="headerlink" title="致谢链接"></a>致谢链接</h3><p><a href="https://siriusq.top/Next主题美化#博文压缩">Next主题美化</a></p>
]]></content>
      <categories>
        <category>测试文件</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈在惠普暗影精灵8下装Win11与Linux双系统</title>
    <url>/2022/09/19/%E8%A3%85%E6%9C%BA%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><!-- <span class="heimu" title="你知道的太多了">的丑态</span> -->
<h3 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h3><ul>
<li>启动硬盘（windows11与Ubuntu20.3）</li>
<li>固态硬盘（主播使用的是致态TiPlus5000 1TB)</li>
<li>暗影精灵8pro</li>
</ul>
<h3 id="拆机"><a href="#拆机" class="headerlink" title="拆机"></a>拆机</h3><p>千万不要看什么网上用乱七八糟的教程，其实这款电脑非常好拆，前面的卡扣非常的紧，但是后方其实用手指甲就可以撬开来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2827.png" style="zoom: 25%;" /></p>
<p>然后在左侧固态槽上安装硬盘即可。</p>
<blockquote>
<p>建议断开电源后点击一下开机键放一下静电后再操作</p>
<p>但是不要忘记最后把电源线连上</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2818.png" alt=""></p>
<p>在安装好后把外壳扣上，不要急着拧螺丝，先按电源键看看可不可以正常开机后再拧紧螺丝</p>
<h3 id="装Win11"><a href="#装Win11" class="headerlink" title="装Win11"></a>装Win11</h3><blockquote>
<p>注：此步骤不是必要过程，主要是我这个买了1TB的盘不太忍心用来装Ubuntu，打算调换一下两个盘，因此要重装win11</p>
</blockquote>
<p>首先你需要一个启动硬盘，推荐一下<code>rufus</code>，虽然我不会用但是看学长用很方便。 </p>
<p>开机时按住F9就是启动选项栏，在插入硬盘之后选择从硬盘启动即可。</p>
<p>Win11有一个自动bitlocker的功能要记得关闭，否则会影响后续的Linux安装。如果无法直接关就先开启bitlocker然后再关闭。</p>
<p>在装机好后可能会出现没有网卡驱动的问题，这里需要借助另一台电脑在HP官网上下载网卡驱动然后进行安装，在有网络的情况下在设置中检查更新即可自动安装其他驱动。</p>
<h3 id="装Ubuntu"><a href="#装Ubuntu" class="headerlink" title="装Ubuntu"></a>装Ubuntu</h3><p>装机程序一致，按照流程来，在最后装机前要注意选择。在安装类型中选择第一个与windows boot manager共存（其可以先看看其他选项确认一下你要装的盘的位置然后再返回）</p>
<p>最后加一行这个<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><br>理论上就安装完毕了</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在安装完毕后，重启电脑，会自动在开机中弹出菜单，选择需要的系统即可</p>
]]></content>
      <categories>
        <category>机械硬件</category>
      </categories>
      <tags>
        <tag>RoboMaster</tag>
        <tag>调试心得</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈术力口与流量主义</title>
    <url>/2022/08/26/%E6%B5%85%E8%B0%88%E6%9C%AF%E5%8A%9B%E5%8F%A3%E4%B8%8E%E6%B5%81%E9%87%8F%E4%B8%BB%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在8月24日Sega推出了<a href="https://t.bilibili.com/697989416159805506">The Vocaloid Collection（缩写ボカコレ）×世界计划联动企划『ボカセカ』（Vocaseka）举办决定</a>，此项目旨在征集新术曲并通过排名给予实装，在B站的评论区还是多半好评，但是对术圈究竟能带来什么还是有待观察。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/6d04c9e00531030bc57d6333177e697213148307.png@2072w.png" alt=""></p>
<h3 id="V家发展"><a href="#V家发展" class="headerlink" title="V家发展"></a>V家发展</h3><p>在谈到本篇主题之前，还是有必要梳理一下近15年来V家的发展，这里作者参考了B站Vocaloid的故事</p>
<iframe src="//player.bilibili.com/player.html?aid=845275103&bvid=BV1354y1j7x5&cid=329109063&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>V家其实经历了<strong>兴起-&gt;百家争鸣-&gt;商业冲击-&gt;恢复期-&gt;现在</strong>，V家最原始的是P主对这方面的热爱，将自己的才华用音乐所寄托的平台，这其实和当下许多同好会组织团体是共同的，在2009年后，随着Deco27，wowaka，hachi为首的三巨头形成，V家进入了其黄金时代。</p>
<p>然而在2011-2013年，JIN(自然之敌P)的横空出世使得整个V家陷入黑暗。JIN创作了三首在相同世界观下的《人造敌人》，《目隐编码》，《阳炎眩乱》后，他将这一套称为<strong>阳炎计划</strong></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Mekakucityactors_2.jpeg" alt="阳炎计划"></p>
<p>接下来便是商业公司1st恰逢时机地找上他，希望jin能与其展开合作，使用最新推出的歌姬IA演唱接下来的“阳炎”系列的歌曲。双方一拍即合。</p>
<p>jin的调教与旋律固然优秀，但是注入了商业色彩的行为，短时间大量的播放量和收藏数、弹幕数，不科学的数据分差，使阳炎曲一出，周刊排名就陷入混乱。新曲占得头筹，以往的旧曲也将前十、前二十的名次一一占有，给其他P主的优秀的新曲腾出来的空间少之又少。最夸张的时候创作者投的新稿攒了一周的数据也赶不上jin最新阳炎曲一天刷出来的数据。V厨们纷纷开始指出“阳炎系列”就是炒作。</p>
<h3 id="V家的流量危机"><a href="#V家的流量危机" class="headerlink" title="V家的流量危机"></a>V家的流量危机</h3><p>在从初音未来10周年时，随着hachi与wowaka时隔多年的投稿，皮诺曹P摆脱“老二”荣登榜首，让V厨们看到了在一个黄金时代的曙光。然而在后续几年中，无论是新歌周报，还是魔法未来的选曲，老歌情怀或是名P地位成为了曲目受欢迎的量度，诚实的讲最近4年的新歌仍然无法打动许多听众。小众P主默默无闻，大P主发歌后好评如潮，已经成为当下V家可悲的现状。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/3song.png" alt=""></p>
<p>作者近期在某术力口群中和群主商讨过此事，虽然不确定是否属实，大P主也存在删评刷分等一系列的恶劣行径，当下的V家已经不在能去评论歌本身的好坏，而是成为了流量之上的商品产业。</p>
<p>此时我们不妨去看看世界计划这款游戏，本人认为它一定上推动了V家的发展，抛开那糟糕的调音不说，在2022年还能看到以V家为主题的质量手游还是十分令人欣慰的，相比于另一款Sega的冷饭王Hatsune Miku: Project DIVA，世界计划表现的十分亮眼，同时其新推出的原创曲，更是将众多新老时代的P主汇聚一堂，诞生了不少优质的新歌。</p>
<p>然而，作为商业游戏，游戏中不同团体角色的欢迎程度不可避免的产生了流量差异，从近期的歌曲MV排名就可以看出不平衡性，在消费者自发产生的流量环境下，歌曲本身的评判似乎就已经参杂了流量的要素。而当下推出的ボカコレ更让不少V厨为其捏一把汗，毕竟谁也不知道它会对当下的环境造成多少商业的冲击。</p>
<h3 id="流量文化与社会环境"><a href="#流量文化与社会环境" class="headerlink" title="流量文化与社会环境"></a>流量文化与社会环境</h3><p>抛开V圈不谈，流量文化就已经渗透入我们的生活，流量文化的合理性也正在逐渐的加深。我们总是说要去追求那束白月光，但又有谁愿意放弃那脚下的六便士，利益是驱动发展的永恒不变的源泉。我认为这是可悲的，因为我见过曾经V圈的繁荣，但是更可悲的是，又有谁可以真正拒绝了利益与流量，这种流量不止是创作者形成的，更是消费者产生的，当200余万播放量的《炉心融解》消失在了刷子的视野里，流量就已经在V圈埋下了隐患。</p>
<p>当作为个体或者小团体已经无法抵挡流量的时候，我们不妨可以联想到一个更现实的理论——凯恩斯主义，在面对一个圈子，更多去思考的是如何稳定流量，而非是发展，因为发展并不是直接符合上层人的利益的，政府可以是这样，而大P主们，也可以是这样。</p>
<p>庆幸的事，V圈磕磕碰碰，但也毕竟也是只有属于少数人的圈子，可悲的是，它正在走在一条流量至上的道路上，却没有改变的势头。在当下，我们缺的是什么，是优秀的P主吗，并不是。缺少的是一个可以自由的去评价歌曲本身的环境，我们无法改变或阻止流量的引入，因为这个当下发展的先决条件，但当流量变成了环境失衡的武器，混乱就会降临。</p>
<h3 id="永远要记得，音乐应是生活中最纯粹的声音"><a href="#永远要记得，音乐应是生活中最纯粹的声音" class="headerlink" title="永远要记得，音乐应是生活中最纯粹的声音"></a>永远要记得，音乐应是生活中最纯粹的声音</h3><p>因为初音未来只是款音乐软件，没有生命，所以感受不到世间的恶意，看不见世间的丑恶；正因为初音未来没有活着，没有感情，所以制作人才能将自己的感情融入到歌里，让她唱出P主们最真实的心声。 </p>
<blockquote>
<p>変わらぬ愛も　儚い恋も<br>不变的爱也好 脆弱的恋情也好</p>
<p>君からすれば　ただの記号で</p>
<p>在你看来不过是记号罢了</p>
<p>正義も悪も　帰らぬ日々も<br>正义也好邪恶也好 无法回去的日子也好</p>
<p>君の前では　どうでもよくて<br>在你面前 怎样都无所谓</p>
<p>ずっと　ずっと　君が生きてなくてよかった<br>一直 一直 你没有活着真是太好了</p>
<p>《君が生きてなくてよかった》</p>
</blockquote>
<p>愿大家在百忙之中，点一首术力口，听那由情感谱写的电子之声。</p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>VOCALOID圈的故事 作者：贝伦先生 <a href="https://www.bilibili.com/read/cv1810505">https://www.bilibili.com/read/cv1810505</a> 出处：bilibili</p>
]]></content>
      <categories>
        <category>人世简谈</category>
      </categories>
      <tags>
        <tag>术力口</tag>
        <tag>VOCALOID</tag>
      </tags>
  </entry>
  <entry>
    <title>主播降临原神必胜客餐厅</title>
    <url>/2022/09/01/opcomment/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>主播不是原p,主播不是原p,主播不是原p</p>
<h3 id="先来看看原P们的丑态"><a href="#先来看看原P们的丑态" class="headerlink" title="先来看看原P们的丑态"></a>先来看看原P们<span class="heimu" title="你知道的太多了">的丑态</span></h3><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/IMG_2245.JPG" alt=""></p>
<blockquote>
<p>环球港必胜客餐厅</p>
</blockquote>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/原1.png" alt=""></p>
<blockquote>
<p>瑞红坊必胜客餐厅</p>
</blockquote>
<h4 id="事情经过"><a href="#事情经过" class="headerlink" title="事情经过"></a>事情经过</h4><p>主播原来不是原P，在经友人推荐后<span class="heimu" title="你知道的太多了">强迫</span>前往了最新最潮的原神餐厅，当时是12点左右到的，餐厅门前已经挤满了人。在排队的过程中主播了解到很多人都是在10点前早早前往拿号。</p>
<p>在12点30左右，店家开始叫号（就是那种从01开始的那种）。主播看着自己手上的77号感觉有点崩溃</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/原2.png" alt=""></p>
<p>大概在1点半左右，主播做出重大决定，前往KFC先垫点吃的</p>
<blockquote>
<p>到达原P聚集处——必胜客</p>
<p>太美丽了吧必胜客</p>
<p>诶哟这不是KFC吗</p>
<p>还是看看手上的原味鸡吧</p>
</blockquote>
<p><span class="heimu" title="你知道的太多了"><del>必胜客你就是歌姬吧</del></span></p>
<p><span class="heimu" title="你知道的太多了">群友的攻击性好强</span></p>
<p>到了下午三点半，人越来越少，主播上前询问服务员：</p>
<blockquote>
<p>主播：您好，您看我这号还有机会吗</p>
<p>工作人员：您这个就像是一个癌症晚期患者说的话一样。他都已经这样了，你为什么不顺从他呢?你总要给人最后一段时间一个好的回忆吧，最后的时光里。因为60这个号很尴尬，50再往下一点，三十四十，可能说，欸，有点实力，能操作一下。80往上，九十一百，啊，人家是纯属混个号的，因为太遥远了，自己也知道自己没什么竞争力。但77，上不去下不来的这个号</p>
</blockquote>
<p><span class="heimu" title="你知道的太多了">原文：今天已经结束了，您肯定拍不到了，把号退了吧</span></p>
<p>然后主播就只能退号了</p>
<h3 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h3><p>主播写文章时，看到了很多网友们也是花了4个多小时等到了座位，体验了一番，其中有一句话令主播很是认可</p>
<blockquote>
<p>如果不是原，我真的不知道自己身边有必胜客</p>
</blockquote>
<p>在带动消费上，二次元市场在近年的表现可以说让人又爱又恨，“二次元真好骗”，利用ip似乎已经成为了许多抬高物价的脱罪例证。</p>
<p>这样的现象并不罕见，因为这就是漫展等一系列ip化活动的核心，但是这样的活动对于二次元来说，它的价值却也十分丰富。对于二次元来说，当一群同好相聚在一起的氛围，才是最难得可贵的。</p>
<p>实际上漫展本来的作用就是这个。就漫展里的那些东西，跟核心二次元几乎是八竿子打不着，几乎是毫无创意可言，平均质量还不如去淘宝周边店定制。为啥呢？因为会在漫展买东西的人，每年最关心二次元的那天可能就是来漫展的这一天，约上几个志同道好的朋友们，去漫展上品鉴着各式各样的IP，分享着当初看番的记忆，再象征性的砸一点钱，享受拿着痛包手办和一群二次元挤地铁的快乐。</p>
<hr>
<p><br></p>
<h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>如何看待必胜客中国将与游戏《原神》进行联动？ 作者：bow-car 链接：<a href="https://www.zhihu.com/question/539734598/answer/2650929206">https://www.zhihu.com/question/539734598/answer/2650929206</a> 来源：知乎</p>
]]></content>
      <categories>
        <category>生活杂谈</category>
      </categories>
      <tags>
        <tag>原神</tag>
      </tags>
  </entry>
  <entry>
    <title>伦勃朗与维米尔系列：Rembrandt&#39;s Final Years</title>
    <url>/2023/08/09/RembrandtFinalYears/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="Rembrandt’s-Bankruptcy"><a href="#Rembrandt’s-Bankruptcy" class="headerlink" title="Rembrandt’s Bankruptcy"></a>Rembrandt’s Bankruptcy</h4><p>伦勃朗即是催债人也是欠债人，四处的创新与房贷让他欠下巨款。由于荷兰与英国的战争还在持续，社会经济萧条，伦勃朗根本无法要到欠款，随后，他放弃了自己原先的大房子，买了一个小房子；他四处拍卖自己的作品，却始终不愿意拿出自己最好的作品，自然也买不出什么好的价钱。在伦勃朗51岁那年，他向破产管理委员会申请破产，在破产管理委员会来清点伦勃朗的家当时，留下了他的家当清单，是艺术史上著名的对伦勃朗的史料。</p>
<p>伦勃朗在他人生的最后十年租了一间朴实的房子，创办了一家艺术公司，继续着自己的创造。归根结底，伦勃朗的破发由以下几点组成：</p>
<ul>
<li>荷兰萧条的经济环境。</li>
<li>伦勃朗缺乏管理的投资结构。</li>
<li>艺术品位变化：在17世纪中叶，荷兰新生代的崛起，精细笔触、鲜亮色彩、精致比例；破产前两年，伦勃朗扔还留着厚重的笔触，绘画是对现实的虚构，他不在掩盖自己的笔触，表现自己对艺术崭新的理解，是他用笔刷与颜料创造出来的，但并不被当时的人所喜爱。</li>
<li>伦勃朗私生活导致的信誉危机：完成了夜巡的伦勃朗遭遇了妻子的离世，随后他的女管家一直帮助他管理家务，并且与伦勃朗同居生有一子。新教委员会指控女管家与伦勃朗卖淫，他的女管家被委员会传讯，使伦勃朗的声誉受到了下降。</li>
</ul>
<h5 id="The-Anatomy-Lesson-of-Doctor-Joan-Deyman"><a href="#The-Anatomy-Lesson-of-Doctor-Joan-Deyman" class="headerlink" title="The Anatomy Lesson of Doctor Joan Deyman"></a>The Anatomy Lesson of Doctor Joan Deyman</h5><p>在伦勃朗破产后，伦勃朗依然有一些艺术委托。外科医生行会再一次选择伦勃朗让他为当时的会长徳曼医生绘制解剖课群像。这幅作品在大火中被烧毁，但是幸运的是伦勃朗留下了这幅画的图稿。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Anatomy-Lesson-of-Doctor-Joan-Deyman.png" alt="The Anatomy Lesson of Doctor Joan Deyman" style="zoom:23%;" /></p>
<p>这幅画残存的部分仅有尸体、德曼医生以及他的助手。我们可以看到尸体对摆放相当的富有创意。尸体的摆放直冲画面，呈现仰卧，透视缩短的手法在这幅画上表现的淋漓尽致。伦勃朗参考了北方文艺复兴艺术家曼科尼亚的《哀悼基督》，将尸体解剖震撼的表现出来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Lamentation-of-Dead-Christ.png" style="zoom:30%;" /></p>
<h4 id="伦勃朗的最后十年"><a href="#伦勃朗的最后十年" class="headerlink" title="伦勃朗的最后十年"></a>伦勃朗的最后十年</h4><p>伦勃朗的最后十年，他追求的并非名誉，而是自由以及自己对艺术的理解。老伦勃朗的画更加的粗犷，留下了生活的笔触，他开始用厚涂法，刷开颜料，展示生活的厚重感。无论是对花神的绘画还是绘制肖像，都能看到伦勃朗这样厚重的笔触。</p>
<h5 id="Flora-花神"><a href="#Flora-花神" class="headerlink" title="Flora 花神"></a>Flora 花神</h5><p>左为伦勃朗年轻时所画的以其妻子为原型的精美的花神；右图是伦勃朗可能以其女管家为原型的花神，涂料、笔触十分厚重。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Flora-Compare.png" style="zoom:30%;" /></p>
<h5 id="Rembrandt’s-Portrait-in-his-old-age"><a href="#Rembrandt’s-Portrait-in-his-old-age" class="headerlink" title="Rembrandt’s Portrait in his old age"></a>Rembrandt’s Portrait in his old age</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Portrait-in-aged.png" style="zoom:30%;" /></p>
<h5 id="Peter-Denying-Christ"><a href="#Peter-Denying-Christ" class="headerlink" title="Peter Denying Christ"></a>Peter Denying Christ</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Peter-Denying-Christ.png" alt="Peter Denying Christ" style="zoom:50%;" /></p>
<p>这是伦勃朗富有卡拉瓦乔风格的作品，用光线亮度的对比来体现故事情景。绘画的内容是圣经新约，基督预言圣徒彼得三次不认基督，“今日鸡叫之前，你要三次不认得我”。女子一手拿着蜡烛，一手指向彼得，是戏剧冲突的中心。画面中彼得警惕的反驳女子，装作镇定的模样；女子手持蜡烛照亮人物的脸，认为彼得可疑，才认出了彼得。在画面右侧的暗处，耶稣回头看到了彼得，丰富了画面的时空，看似只有一幕，实际上传承了众多了事件。这幅作品体现了彼得在道义上的矛盾与纠结，基督的形象模糊，粗粝，正是伦勃朗晚年经常使用的厚涂颜料手法。</p>
<blockquote>
<p>有一个使女看见彼得坐在火光里，就定睛看他说：<br>这个人素来也是同那人一伙的。<br>彼得却不承认，说：<br>女子，我不认得他。</p>
<p>——《新约·路加福音》22:34</p>
</blockquote>
<h4 id="A-Curious-Group-Portrait"><a href="#A-Curious-Group-Portrait" class="headerlink" title="A Curious Group Portrait"></a>A Curious Group Portrait</h4><h5 id="The-Syndics-of-the-Drapers’-Guild-of-Amsterdam"><a href="#The-Syndics-of-the-Drapers’-Guild-of-Amsterdam" class="headerlink" title="The Syndics of the Drapers’ Guild of Amsterdam"></a>The Syndics of the Drapers’ Guild of Amsterdam</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The-Syndics-of-the-Drapers-Guild-of-Amsterdam.png" alt=""></p>
<p>布料商人行会邀请伦勃朗绘制其董事会群像。画面中一共有六个人，其中五位是质检布料员，而最后一位站在最后的是管家。其中，一个人正在站起来，伦勃朗依然做到把静态的群像画的富有动感。前五位人物共同看向前方，似乎画面外忽然发生着什么事情。在X光的检测中，伦勃朗多次改动这幅画中人物的姿态，煞费苦心的在故事中体现静态的群像。</p>
<h4 id="A-Parable"><a href="#A-Parable" class="headerlink" title="A Parable"></a>A Parable</h4><h5 id="Return-of-the-Prodigal-Son"><a href="#Return-of-the-Prodigal-Son" class="headerlink" title="Return of the Prodigal Son"></a>Return of the Prodigal Son</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Return-of-the-Prodigal-Son.png" alt="Return of the Prodigal Son" style="zoom:33%;" /></p>
<p>伦勃朗的《浪子回头》旨在表达悔过自新得到宽恕。抛开主题看这幅画的手法，一束光从顶上打下来，描绘了老父亲和儿子团聚的情景，他无声的原谅了儿子，而儿子把头埋在了父亲胸前，我们看不到儿子的神情，但也能深刻的体会到他的愧歉与悔过。相比之下过去的艺术家都会刻意的关注儿子的神情，给儿子一个正面或者侧面直接表达他的神态。伦勃朗这样绘制，更是学习了古希腊画家狄曼提斯在描绘阿伽门农牺牲女儿献给狩猎女神的画，这幅作品中，阿伽门农遮住自己的脸背对着画面，来突出自己的悲伤</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Sacrifice-of-Iphigenia.png" style="zoom:23%;" /></p>
<h4 id="The-Female-Character"><a href="#The-Female-Character" class="headerlink" title="The Female Character"></a>The Female Character</h4><h5 id="Lucretia"><a href="#Lucretia" class="headerlink" title="Lucretia"></a>Lucretia</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Lucretia.png" alt="Lucretia" style="zoom:50%;" /></p>
<p>在罗马王政末年，卢克雷齐娅遭到强奸后自尽，在她自尽之前，她渴求她的亲友为其报仇，最后她的亲友推翻王政，建立了罗马共和国。伦勃朗这幅画中，一名女子衣装凌乱，手持匕首，眼神虚弱，含着泪水，表达的是令人心碎的悲伤，却无一点索取同情，暗含着伦勃朗对将逝生命的思考以及对自我信念的坚守，可能还包含着保持真我宁死不屈的执着。</p>
<h4 id="Late-Self-Portraits"><a href="#Late-Self-Portraits" class="headerlink" title="Late Self-Portraits"></a>Late Self-Portraits</h4><h5 id="Self-Portraits-in-1663"><a href="#Self-Portraits-in-1663" class="headerlink" title="Self-Portraits in 1663"></a>Self-Portraits in 1663</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/sp1663.png" style="zoom:25%;" /></p>
<p>在自画像中，过去的艺术家会把他们自己画成一个温文尔雅的社会精英，而非是一个体力劳动者。然而伦勃朗更喜欢把自己朴实的表达出来，画中的人带着艺术家的头巾，褶皱的皮肤，一头卷发以及标志性的支腕仗，象征着自己的辛劳与对艺术的执着。在画面后方有两个半圆，暗示着一幅世界地图或者地球仪，在当时，这象征着伦勃朗对知识的渴求。</p>
<h5 id="Last-Self-Portraits-Self-Portraits-in-1669"><a href="#Last-Self-Portraits-Self-Portraits-in-1669" class="headerlink" title="Last Self-Portraits: Self-Portraits in 1669"></a>Last Self-Portraits: Self-Portraits in 1669</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/sp1669.png" alt=""></p>
<p>这是63岁的伦勃朗给自己作的自画像。也是在所有自画像中，眼神最明亮，最精锐与最坚定的一幅作品。眼睛是艺术家观察世界，表达时间最重要对伙伴，似乎突出了自己用眼睛探索着世界的一切。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>西方美术史</tag>
        <tag>伦勃朗</tag>
      </tags>
  </entry>
  <entry>
    <title>伦勃朗与维米尔系列：Rembrandt In Leiden</title>
    <url>/2023/07/08/RembrandtInLeiden/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote>
<p>The interaction of Perception and Expression</p>
</blockquote>
<h4 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h4><ul>
<li><h5 id="视觉艺术大致分为五类："><a href="#视觉艺术大致分为五类：" class="headerlink" title="视觉艺术大致分为五类："></a>视觉艺术大致分为五类：</h5><ul>
<li><h5 id="Narrative-叙事"><a href="#Narrative-叙事" class="headerlink" title="Narrative 叙事"></a>Narrative 叙事</h5></li>
<li><h5 id="Portraitare-肖像"><a href="#Portraitare-肖像" class="headerlink" title="Portraitare 肖像"></a>Portraitare 肖像</h5></li>
<li><h5 id="Genre-风俗"><a href="#Genre-风俗" class="headerlink" title="Genre 风俗"></a>Genre 风俗</h5></li>
<li><h5 id="Still-Life-静物"><a href="#Still-Life-静物" class="headerlink" title="Still-Life 静物"></a>Still-Life 静物</h5></li>
<li><h5 id="Landscape-风景"><a href="#Landscape-风景" class="headerlink" title="Landscape 风景"></a>Landscape 风景</h5></li>
</ul>
<p>其中维米尔多以风俗画为主，而伦勃朗则多有叙事、肖像、风俗等画作</p>
</li>
</ul>
<h4 id="Nederland-Holland-Golden-Age"><a href="#Nederland-Holland-Golden-Age" class="headerlink" title="Nederland (Holland) Golden Age"></a>Nederland (Holland) Golden Age</h4><blockquote>
<p>低地、风车、郁金香、以及庄园</p>
</blockquote>
<ul>
<li><p>宗教改革 The Reformation</p>
<blockquote>
<p>义人必因信得生</p>
</blockquote>
<p>公元1517年，文艺复兴时期，16世纪至17世纪，以马丁·路德为首的教徒发动了一场针对天主教堂的政治革命，其反对天主教需要从外在条件得到救赎的理论，大肆宣传赎罪券等行为，提倡人的救赎应该来源于内心的信念，与上帝直接对话。同时，以加尔文为首的加尔文教派也在进行改革，他们遵循救赎预定论「Predestination」，认为上帝已经将每个人的命运制定完毕，每个人只需要完成上帝的旨意就能得到救赎，值得注意的是，在后期”上帝的旨意”演变为了为上帝制造财富，这便是资本主义一部分的信仰基础。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Luther_Calvin.png" alt="Luther and Calvin" style="zoom:30%;"/></p>
</li>
</ul>
<p>  这场运动贯穿整个神圣罗马帝国，在阿尔卑斯山以北的尼德兰新教徒也在发动革命，他们形成了乌得勒支同盟「Unie van Utrecht」。16世纪中期，加尔文教在尼德兰的教徒迅速增多，因十诫中反对制造偶像，用偶像代替神，加尔文教徒大肆破环圣像，不时发生武装的加尔文教徒同当局和教会的冲突，也正为了80年战争的导火索。</p>
<p>  <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Iconoclasts_in_a_Church.png" alt="Iconoclasts in a Church" style="zoom:30%;" /></p>
<p>  在80年独立战争结束后，尼德兰七省联合共和国被西班牙承认独立，世界上第一个去中心化经济结构体系的议会制国家成立，是世界上最早成立的资本主义社会。  </p>
<ul>
<li><p>大航海与科学发展 Discovery</p>
<p>荷兰的黄金时代伴随着大航海的出现，当世界历史的中心从地中海转移到了大西洋，海岸线漫长的荷兰转身成为了欧洲的一大经济中心，它被誉为海上马车夫「Sea Coach」, 共和国将所以海上贸易的城市汇聚成具有武装力量的大型股份制贸易公司，荷兰东印度公司「Dutch East India Company」，在亚洲进行海上贸易。其中，主要为6个城市组成了荷兰东印度公司：Amsterdam、Delft、Rotterdam、Enkhuizen、Middelburg、Hoorm。荷兰在大航海时期经济迅速发展，荷兰迎来黄金时代。在新教理论与文艺复兴对人文主义的宣扬下，经验哲学与实验科学也得到发展，其中最著名的三位便是惠更斯「Huggens」，列文虎克「Leeuwenhock」以及笛卡尔「Descartes」。</p>
</li>
</ul>
<h3 id="Lecture-1-Rembrandt-in-Leiden"><a href="#Lecture-1-Rembrandt-in-Leiden" class="headerlink" title="Lecture 1: Rembrandt in Leiden"></a>Lecture 1: Rembrandt in Leiden</h3><h4 id="Rembrandt-and-his-Self-Portrait"><a href="#Rembrandt-and-his-Self-Portrait" class="headerlink" title="Rembrandt and his Self-Portrait"></a>Rembrandt and his Self-Portrait</h4><p>估计没有人会比伦勃朗更加喜欢画自画像，据统计他一生完成了100多幅自画像，其中他对表情的研究更是出神入化，在他早期曾给自己画过一些列不同表情的自画像：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/SelfPortraitRembrandt.png" alt=""></p>
<p>除了伦勃朗，同时期北方还有三大画家也曾绘制过自画像，分别是凡艾克、鲁本斯和丢勒：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/North_Portrait2.png" style="zoom:45%;" /></p>
<p>在荷兰黄金时代，自画像从名门画家的标志变成了每个画家都可以记录自己的方式，随着人文主义自我意识的兴起，自画像成为了一种自传题材，用绘画记录自己的一生。</p>
<h4 id="Becoming-an-Artist"><a href="#Becoming-an-Artist" class="headerlink" title="Becoming an Artist"></a>Becoming an Artist</h4><p>1606年7月15日伦勃朗出生于荷兰共和国莱顿的一个小磨坊。少年时他被送往拉丁学院学习文科三艺：语法、词汇、逻辑，并在三年后的14岁进入莱顿大学，但显然伦勃朗不太愿意在大学学习，他辍学求师，先后拜访了两位莱顿的画师。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/TheMill.png" alt="The Mill" style="zoom:33%;" /></p>
<p>Jacob van Swanenburgh是他的第一位师傅，虽然这位师傅的绘画名气不高，但他的师傅25年的意大利留学经历激发了伦勃朗对绘画的热情，在他的培养下，伦勃朗不仅学习了美术的基础手法，还了解了美术相关工具的使用。1624年，他获得了在荷兰当时最著名的画家彼得•拉斯特曼于阿姆斯特丹的画室中当学徒的机会并在拉斯曼手下工作了六个月。彼时，他已经基本掌握油画、素描和蚀刻画的技巧并发展了自己的风格。</p>
<h5 id="Orestes-and-Pylades-Disputing-at-the-Altar"><a href="#Orestes-and-Pylades-Disputing-at-the-Altar" class="headerlink" title="Orestes and Pylades Disputing at the Altar"></a>Orestes and Pylades Disputing at the Altar</h5><p>俄瑞斯忒斯与皮拉德斯这幅作品是由伦勃朗的第二位师傅Pieter Lastman在1614年创作。俄瑞斯忒斯为父亲报仇弑母后，为了逃离复仇女神的追杀，他们向太阳神阿波罗寻求庇护，于是阿波罗要求他们去将月神黛安娜的雕像取回雅典城。他和皮拉德斯随机前往神殿偷走神像，不过两人立刻被人们囚禁起来，按照当地的习俗，所有陌生人都应直接献给阿尔忒弥斯。当时，负责献祭的阿耳忒弥斯女神是俄瑞斯忒斯的妹妹伊菲革涅亚，她提出可以放一个人帮他把从希腊寄来的信带回家。画面正描述的是朋友两人为争论留下来牺牲喋喋不休的场景，两人都想让对方去送信，让自己留下。最后俄瑞斯忒斯拒绝离开，让皮拉德斯拿走那封信，而他自己留下来等着被杀。皮拉德斯最终同意了，但这封信让俄瑞斯忒斯认出了伊菲革涅亚，并暴露了自己。三人携着阿尔忒弥斯的神像一起成功逃走。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Orestes_and_Pylades_Disputing_at_the_Altar.png" alt="Pieter Lastman"></p>
<blockquote>
<p>Lastman’s densely composed compositions, his bright colours and the expressive gestures of his figures – all had an impact on the young Rembrandt.</p>
</blockquote>
<p>祭坛的浓烟升起，将画面分为左右两个部分：画中左侧的两人正是俄瑞斯忒斯和皮拉德斯，两人穿着一黑一白，在为谁流下争论不休。在画面右侧的女祭司手拿书信，入迷般的看着两者的争论，她从未见过会有人为了送死而争辩如此激烈。在右侧画面的背景中，有一座月牙形角的雕像便是月神的神像。</p>
<h4 id="Rembrandt‘s-Early-Printing"><a href="#Rembrandt‘s-Early-Printing" class="headerlink" title="Rembrandt‘s Early Printing"></a>Rembrandt‘s Early Printing</h4><h5 id="Palamedes-before-Agamemnon"><a href="#Palamedes-before-Agamemnon" class="headerlink" title="Palamedes before Agamemnon"></a>Palamedes before Agamemnon</h5><p>在与第二个师傅学习了半年，伦勃朗回家成为独立画家，开展了自己的画室。据史料记载，第一幅伦勃朗的历史画是Palamedes before Agamemnon，伦勃朗在第一次历史画中就展现了极强的艺术水准，他完成这幅画时仅仅20岁，在完成画作后，他也为自己的画作属上了名字。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Palamedes_before_Agamemnon.png" alt="Palamedes before Agamemnon"></p>
<p>在特洛伊战争开始之前，阿伽门农派遣说客帕拉蒙德斯去说服奥德修斯参战，奥德修斯不愿参战装疯卖傻，用一匹驴和一匹牛去耕地，只见耕车横冲直撞毁坏田地。帕拉蒙德斯当然知道奥德修斯是故意如此，就拉来他儿子站在车前，奥德修斯只好赶紧牵住车辆，被迫参战。奥德修斯一直记恨这件事，在随后他在阿伽门农面前陷害帕拉蒙德斯，最后帕拉蒙德斯被处以叛国罪被乱石扔死。</p>
<p>在画中，身着红衣跪在地上眼神惊慌的便是帕拉蒙德斯，他有口莫辨，惊慌失措；右边站着的便是奥德修斯，他举起右手，似乎在一一列举帕拉蒙德斯的罪行；很有意思的是他将自己的形象也画在了阿伽门农的右侧，好似自己也在现场，经历着伟大的历史。在色彩的运用上，显然也是深得第二位师傅的技巧，在群像中将主要人物刻画得惟妙惟肖。</p>
<p>很有趣的是，本来伦勃朗在画完后并没有说明是什么主题与人物，最符合时代背景与人物的便是奥德修斯陷害帕拉蒙德斯的情节。在当时，荷兰共和国还处于80年战争的末期，当权的奥兰治家族处死了一位深受人民爱戴共和国元勋，选择继续与西班牙战争，而这位共和国元勋就被乱石处死，定为叛国罪。</p>
<h5 id="Tobit-and-Anna-with-the-Kid-Goat"><a href="#Tobit-and-Anna-with-the-Kid-Goat" class="headerlink" title="Tobit and Anna with the Kid Goat"></a>Tobit and Anna with the Kid Goat</h5><p>托比特的忏悔是同年伦勃朗又一幅历史画，故事选自天主教圣经次经的多俾亚传[Book of Tobias]。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Tobit_and_Anna_with_the_Kid_Goat.png" alt="Tobit and Anna with the Kid Goat"></p>
<p>托比拖是虔诚的老教徒，可在他老年时，他双目失明。有一天他的妻子Anna抱来一头羊，说是买来的。可是托比拖怀疑是他的妻子偷来的并且斥责他的妻子。事后他发现妻子并没有偷这只羊，他坐在椅子上忏悔，“我失明了，也使我的心失明了”。画面中，伦勃朗对服饰的刻画赏心悦目，他对油画的透明度与黏稠度进行了改良并运用到了火焰与布料上，在当时伦勃朗就已经很擅长表达这种细节了。伦勃朗在这幅画作中还突出了生活气息，如果不说是托比拖，说是农民的日常景色也无妨。</p>
<h4 id="Rembrandt’s-Classment-Lievens"><a href="#Rembrandt’s-Classment-Lievens" class="headerlink" title="Rembrandt’s Classment: Lievens"></a>Rembrandt’s Classment: Lievens</h4><p>伦勃朗还有一个师兄列文，列文用色大胆，主要受到巴洛克大师卡拉瓦乔的影响，运用对比色与明暗光来表达人物，其中最典型作品之一是其作的《以斯帖与亚哈随鲁的盛宴》</p>
<h5 id="The-Banquet-of-Esther-and-Ahasuerus"><a href="#The-Banquet-of-Esther-and-Ahasuerus" class="headerlink" title="The Banquet of Esther and Ahasuerus"></a>The Banquet of Esther and Ahasuerus</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/TheBanquetofEstherandAhasuerus.png" alt="The Banquet of Esther and Ahasuerus"></p>
<p>从这幅画中，以斯帖位于画面中央，也是光线最亮的位置，而其一手指向军官，指责其的过失，而亚哈随鲁侧身对军官怒目而视，一手攥拳。而军官则成为众矢之地，只留下了背影来刻画其惊恐的神色。华丽的衣饰、强烈的光线对比与鲜艳的配色非常具有巴洛克艺术风格。</p>
<p>伦勃朗与这位师兄关系甚好，两人相互学习合作作画，甚至共处一个画室，两人还给对方分别作了肖像。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RembrandtAndLievens.png" style="zoom:30%;" /></p>
<p>而相比之下，伦勃朗虽然也学习了卡拉瓦乔的艺术风格，但是此时的伦勃朗用光更加柔和，细腻。</p>
<h5 id="The-Penitent-Judas-Returning-the-Thirty-Pieces-of-Silver"><a href="#The-Penitent-Judas-Returning-the-Thirty-Pieces-of-Silver" class="headerlink" title="The Penitent Judas Returning the Thirty Pieces of Silver"></a>The Penitent Judas Returning the Thirty Pieces of Silver</h5><p>《犹大忏悔》这幅画中，伦勃朗统一配色，运用点光源技法，将光线铺满这个空间。犹大在右下角合十忏悔，视线注视着出卖基督的银币，而光也合情合理的打在了钱币上，暗示了主题。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_Penitent_Judas_Returning_the_Thirty_Pieces_of_Silver.png" alt="The Penitent Judas Returning the Thirty Pieces of Silver" style="zoom:80%;" /></p>
<p>艺术评论家老惠更斯评价这两位才华横溢，是荷兰可以与意大利艺术家相比较的两位。伦勃朗的笔法更加细腻，列文则更有表现力和创造性。两个年轻人唯一的问题是太自信了。在当时，艺术家在一生中都至少应该去一次意大利来一场精神上的朝圣与艺术的游学，可是这两位却说：我们不用去意大利！</p>
<h5 id="The-Rich-Man-from-Christ’s-Parable"><a href="#The-Rich-Man-from-Christ’s-Parable" class="headerlink" title="The Rich Man from Christ’s Parable"></a>The Rich Man from Christ’s Parable</h5><p>伦勃朗还有一幅《财主的寓言》也印证了老惠更斯的评论。整个场景被花烛所照亮，贪婪的财主看着手中的金币。书页的质感细腻的体现出来，伦勃朗用刀刮在画面中挂出了书的褶皱。同时，在服装与面容上，伦勃朗有意的去除了他的笔触，把奢侈的袍子精细的刻画出来。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_rich_Man_from_Christ’s_Parable.png" alt="The Rich Man from Christ’s Parable"></p>
<blockquote>
<p>Vanitas vanitatum omnia vanitas. 虚空的虚空，一切都是虚空。</p>
<p>——传道书</p>
</blockquote>
<p>这幅画也可以体现出伦勃朗对虚空派「Vanitas」静物的认识。在当时的静物画中，有一类画作专门去绘制静谧的青烟、褶皱的书籍、燃尽的蜡烛以及骷髅等物体，这一类在当时称之为虚空派。伦勃朗也在这一幅画中运用了虚空派的静物描写。</p>
<h4 id="Studies-of-Old-Ages-and-Naturalism"><a href="#Studies-of-Old-Ages-and-Naturalism" class="headerlink" title="Studies of Old Ages and Naturalism"></a>Studies of Old Ages and Naturalism</h4><p>年轻的伦勃朗对老年的姿态也颇有研究，1629年，他画了一系列的头像画「Tronie」，这类画不像肖像画正式，与被画者的身份无关，也是在这时，伦勃朗学会了对皮肤细致的刻画，也为他以后的群像画打下基础。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/StudyOfOld.png" style="zoom:45%;" /></p>
<p>不仅如此，在生活中伦勃朗也会捕捉平常生活中的景象，在他的手稿上寥寥数笔，记录下生活中的瞬间：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Beggar.png" alt=""></p>
<p>而正是如此，伦勃朗开始对传统题材进行了大胆的创作。他将过去中刻板的完美的形象都生活化，表达的人物都更加贴近于现实（甚至是不完美的），他的安德梅达更是在当时引起了众多的讨论。</p>
<h5 id="Andromeda-chained-to-the-Rocks"><a href="#Andromeda-chained-to-the-Rocks" class="headerlink" title="Andromeda chained to the Rocks"></a>Andromeda chained to the Rocks</h5><p>安德梅达是埃塞俄比亚国王刻甫斯「Cepheus」和王后卡西奥佩娅Cassiopeia 的女儿。王后常常夸耀自家女儿，说她比所有的海中女神都要美丽。海神波塞冬听到后，派遣海怪去摧毁埃塞俄比亚。刻甫斯没有办法只好将安德梅达献给海怪。恰巧珀耳修斯路过，国王夫妇恳求他救出他们的女儿，作为条件他可以娶安德罗墨达为妻，并成为埃塞俄比亚的国王。珀尔修斯看见公主时，她的手臂正被拴在坚硬的岩石上，全身赤裸。如果没有微风吹动她的头发，温暖的眼泪从她眼中夺眶而出，他会以为这就是一尊美丽的大理石雕像。最后珀耳修斯杀死了海怪并带走了安德梅达。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Andromeda_chained_to_the_Rocks.png" alt="Andromeda chained to the Rocks" style="zoom: 33%;" /></p>
<p>在过往的画家中，通常这个主题都会包含安德梅达、海怪与珀耳修斯。</p>
<p>「左下角：鲁本斯作；右侧：提香作」</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/AndromedaInHistory.png" alt=""></p>
<p>可是伦勃朗把一个称不上好看的裸体放在画面中，眼神绝望的看着右侧。她看到的究竟是海怪还是珀耳修斯我们不得而知，但是这样去刻画这个主题整个历史上都是空前绝后的。</p>
<h5 id="The-Painter-in-his-Studio"><a href="#The-Painter-in-his-Studio" class="headerlink" title="The Painter in his Studio"></a>The Painter in his Studio</h5><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/The_Painter_in_his_Studio.png" alt="The Painter in his Studio"></p>
<p>画室里的艺术家是伦勃朗在1629年完成的，这幅画把艺术家抽象成了客体，而面前的画架成为了主体。画家凝视着画布，好似揣测着画面整体的布局。这是伦勃朗，也是艺术家认可的一种工作状态，荷兰语中形容为”uyt den gheest”，对应着汉语中的胸有成竹。伦勃朗将自己的脸也画在了画中，可能是对自己做画的反思与描绘。</p>
<h4 id="Rembrandt’s-Student"><a href="#Rembrandt’s-Student" class="headerlink" title="Rembrandt’s Student"></a>Rembrandt’s Student</h4><p>伦勃朗还收了一位徒弟，Gerrit Dou。徒弟窦将伦勃朗的光影技巧与虚空派结合，开创了莱顿画派。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/GerritDou.png" alt="Gerrit·Dou" style="zoom:20%;" /></p>
<p>他对物体的质感有着独特的把握，也擅长使用障眼法来构造画面。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/DouPrint.png" alt="Dou's Paintings" style="zoom:15%;" /></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>西方美术史</tag>
        <tag>伦勃朗</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法：最短路径问题（1）</title>
    <url>/2023/12/14/dijkstra/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>摘自UNNC Programming and Algorithms (COMP1038) Coursework 2：</p>
<blockquote>
<p>You are required to write a program that will produce the optimal route and cost C of train tickets between stations. To complete this task, you will be given a source station S, a destination station D and a distance matrix (in<br>kilometers) for N stations. The cost C is defined as:</p>
<script type="math/tex; mode=display">
C =⌈1.2 ∗ d+25∗n⌉</script><p>where d is the total distance of the route, n is the number of intermediate stations (excluding source and destination<br>stations), and $⌈x⌉$ means x should be rounded up to the next nearest integer.<br>You should choose an appropriate and efficient algorithm to obtain the shortest route from station S to D. If there<br>are more than one shortest route, the route with minimal cost C should be used.</p>
</blockquote>
<p>根据题目描述，可以等价为在二维有向图中，从某一点出发至另一个点的最短路径问题。Dijkstra算法适用于类似权重为正的最短路径问题中。</p>
<h3 id="算法模版"><a href="#算法模版" class="headerlink" title="算法模版"></a>算法模版</h3><p>构造check数组与dis数组，分别记录节点是否完成探索以及当前距离，在初始化时，需要将dis赋值为正无穷代表无法抵达。算法从第一个点出发，遍历所有边，并更新两点之间的距离，通过排序找到与这个点距离最短的点（即dis中未check的点中距离最小的点）标记并作为下一次迭代的依据点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">		<span class="keyword">for</span> <span class="number">1</span> to n: dis = inf;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      	<span class="keyword">for</span> 寻找所有可行路径</span><br><span class="line">          	如果新路径比旧路径更短，更新dis</span><br><span class="line">        <span class="keyword">for</span> 寻找最小值</span><br><span class="line">          	设置出发点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模版中，循环主体设置为1到n次，若遇到已知有不通的路径则另作处理。下图为算法实现的实例，假设从0点开始：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/d1-(1" alt="">.png)</p>
<ol>
<li>标记阶段0，寻找通路 0-1，0-2，由于两个距离均小于正无穷，更新dis；寻找最小值节点1，并标记1</li>
<li></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Dis</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>2</td>
<td>6</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
<td>inf</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Phase Plane Method</title>
    <url>/2024/05/08/Phase%20Plane%20Methods/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>本文讲述的相平面法[Phase Plane Methods]主要围绕对分析二元微分方程组和一元二次微分方程的向量场，在介绍之前，先引入一个二元微分方程组，The Competitive Lotka-Volterra Equations：</p>
<script type="math/tex; mode=display">
\frac{dx}{d\overline{t}} = r_xX(1-\frac{x}{x_c}) - F_X(x,y) \\ \frac{dy}{d\overline{t}} = r_yY(1-\frac{y}{y_c}) - F_Y(x,y) \\</script><p>其中，我们定义$F_X&gt;0, F_Y &gt;0$，这描述了两个同类动物族群的数量演变，我们并不能直接求出这两个方程的具体解，但是我们可以通过相平面法求出(X, Y)的变化趋势与收敛情况。</p>
<hr>
<p>我们首先来看一个简单的方程组，我们假设在整个过程中，所有函数连续并可导：</p>
<script type="math/tex; mode=display">
\frac{dx}{dt} = X(x,y) \ \ \ \ 
\frac{dy}{dt} = Y(x,y)</script><ul>
<li>Integral Path: 对于一组解: $X_k(t), Y_k(t)$ 满足这一微分方程的随着时间的变化曲线。由于微分方程组有无数多解（没有初始值t=0约束的缘故），但每一组解都是一一对应随时间变化的，我们定义某一组解构成的坐标的点随时间运动的轨迹为Integral Path，当然，一组可解的微分方程往往有很多Integral Path</li>
<li>Phase portrait：Integral Path的集合，在这是一张x-y坐标系图，我们的目标就是画出这样的平面图。</li>
</ul>
<h2 id="Equilibrium-Point-平衡点"><a href="#Equilibrium-Point-平衡点" class="headerlink" title="Equilibrium Point 平衡点"></a>Equilibrium Point 平衡点</h2><p>平衡点就是（x, y）不再变化的点，但是不代表（x,y）在实际中静止与此，而仅仅代表：$dX/dt=0, dY/dt=0$，等价于：</p>
<script type="math/tex; mode=display">
X(x,y) = Y(x,y) = 0</script><blockquote>
<p>Integral paths cannot cross in the phase plane, except at equilibrium points. （我认为这显而易见，但我无法证明）</p>
<ul>
<li>Ordinary point：所有非平衡点的点都是Ordinary point</li>
<li>Direction of the Integral Path: 向量$\vec d = [X(x,y), Y(x,y)]$ X(x0, y0) , Y (x0, y0) 是integral path 在 ordinary point (x0, y0)的切线方向。</li>
</ul>
</blockquote>
<h2 id="Integral-Path-的分类"><a href="#Integral-Path-的分类" class="headerlink" title="Integral Path 的分类"></a>Integral Path 的分类</h2><ol>
<li><p>Isocline：当x与y的变化率为常数时：即 $y = kx + C$ 时，或者写作：</p>
<script type="math/tex; mode=display">
 \frac{dy}{dx} = \frac{dy}{dt}/\frac{dx}{dt} = \frac{Y(x,y)}{X(x,y)} = Constant</script></li>
<li><p>Nullcline：Y(x, y) 或者 X(x, y) 为0的 Integral Path，Nullcline贯穿所有平衡点</p>
</li>
</ol>
<p>对于Nullcline上的点，可以判断该点的移动趋势，实际上是分析x或者y的变化的正负号：</p>
<ul>
<li>当X=0时：若Y大于0，则代表Y的变化趋势是+，不断增大向上移动</li>
<li><p>当Y=0时：若X大于0，则代表x变大，向右变化</p>
<p>  <img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/Screenshot_2024-04-26_at_23.04.59.png" alt="*对Nullcline与变化趋势的解释*"></p>
<p>  <em>对Nullcline与变化趋势的解释</em></p>
</li>
</ul>
<p>实际上，对于变化趋势的判断用到了对于特定点周围的线性近似过程，我们也可以使用这个方法来进一步判断平衡点的性质。</p>
<h2 id="平衡点的性质判断"><a href="#平衡点的性质判断" class="headerlink" title="平衡点的性质判断"></a>平衡点的性质判断</h2><p>下列式子是对$(x_{eq}, y_{eq})$的线性近似：</p>
<script type="math/tex; mode=display">
\frac{d\hat{x}}{dt} = X(x_{eq} + \hat{x}, y_{eq} + \hat{y}) \approx X(x_{eq}, y_{eq}) + \hat{x} \frac{\partial X}{\partial x}(x_{eq}, y_{eq}) + \hat{y} \frac{\partial X}{\partial y}(x_{eq}, y_{eq}) \\
\frac{d\hat{y}}{dt} = Y(x_{eq} + \hat{x}, y_{eq} + \hat{y}) \approx Y(x_{eq}, y_{eq}) + \hat{x} \frac{\partial Y}{\partial x}(x_{eq}, y_{eq}) + \hat{y} \frac{\partial Y}{\partial y}(x_{eq}, y_{eq})</script><p>由于平衡点的性质，在小范围内，等价于：</p>
<script type="math/tex; mode=display">
\frac{d\hat{x}}{dt} = \hat{x} \frac{\partial X}{\partial x}(x_{eq}, y_{eq}) + \hat{y} \frac{\partial X}{\partial y}(x_{eq}, y_{eq}) \\
\frac{d\hat{y}}{dt} = \hat{x} \frac{\partial Y}{\partial x}(x_{eq}, y_{eq}) + \hat{y} \frac{\partial Y}{\partial y}(x_{eq}, y_{eq})</script><p>写成矩阵的形式，事实上，我们只关心其Jacobian matrix</p>
<script type="math/tex; mode=display">
\frac{d\vec y}{dt} = \frac{d}{dt} \begin{pmatrix} \hat{x} \\ \hat{y} \end{pmatrix} = \begin{pmatrix} \frac{\partial X}{\partial x}(x_{eq}, y_{eq}) & \frac{\partial X}{\partial y}(x_{eq}, y_{eq}) \\ \frac{\partial Y}{\partial x}(x_{eq}, y_{eq}) & \frac{\partial Y}{\partial y}(x_{eq}, y_{eq}) \end{pmatrix} \begin{pmatrix} \hat{x} \\ \hat{y} \end{pmatrix}</script><p>为了方便讨论平衡点的性，我们着重分析 Nullcline，当X为0时，在足够接近平衡点的时候(x,y)可以看做是线性变化，也就意味着对于给定的向量坐标 $\vec v$  ，其变化趋势的方向与自身指向方向一致，即 $\vec x$ 可以看作是Jacobian的特征向量，所以问题的分析变成了对特征值的分析。我们对其求特征向量，有：</p>
<script type="math/tex; mode=display">
                    \textbf{y}_{+} = c_+\textbf{v}_+e^{\lambda_+t} \\ \textbf{y}_{-} = c_-\textbf{v}_-e^{\lambda_-t}</script><h3 id="Case-1-特征根为实数"><a href="#Case-1-特征根为实数" class="headerlink" title="Case 1: 特征根为实数"></a>Case 1: 特征根为实数</h3><p>这时候，向量y就有两个方向，约束平衡点周围的点的变化趋势：</p>
<ul>
<li>当 $\vec y$ 对应的特征值大于0时，$|\textbf{y}| \rightarrow \infty \text{ as } t \rightarrow \infty$, 我们说在这一方向上时发散的，或者说Unstable</li>
<li>当 $\vec y$ 对应的特征值大于0时，$|\textbf{y}| \rightarrow 0 \text{ as } t \rightarrow \infty$, 我们说在这一方向上时收敛于平衡点，或者说Stable</li>
</ul>
<p>进一步有如下分类：</p>
<ol>
<li>$\lambda_+ &gt; 0 &gt; \lambda_-$ : 两个方向不一致，为Saddle</li>
<li>$\lambda_+ &gt; \lambda_- &gt; 0$：均为Unstable → 平衡点Unstable</li>
<li>$0 &gt; \lambda_+ &gt; \lambda_-$: 均为Stable → 平衡点Stable</li>
</ol>
<h3 id="Case-2-特征根为虚数"><a href="#Case-2-特征根为虚数" class="headerlink" title="Case 2: 特征根为虚数"></a>Case 2: 特征根为虚数</h3><p>由于特征值共轭，所以在实数部分两者一致，进一步模长随着时间变化的趋势一致，即同时趋向无穷或者0随着时间的变大，在图像上，表达为螺旋状：</p>
<p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/Screenshot_2024-04-26_at_23.56.46.png" alt="左图解趋向于无穷，代表实部为正数，Unstable Spiral；右侧趋向于0，为负数, Stable Spiral"></p>
<p>左图解趋向于无穷，代表实部为正数，Unstable Spiral；右侧趋向于0，为负数, Stable Spiral</p>
<p>当实部为0时，我们认为这是 linear centre，(x, y) 随着时间变化为周期运动，称之为：conserved quantity</p>
<blockquote>
<p>An equilibrium point whose linearised system has no <strong>eigenvalues</strong> with <strong>zero real part</strong> is said to be hyperbolic.</p>
</blockquote>
<p>我们称没有实部为0的平衡点为：Hyperbolic equilibrium point，除了Linear Center之外都是Hyperbolic Equilibrium Point</p>
<blockquote>
<p>An equilibrium point whose linearised system has <strong>at least one eigenvalue with zero real part</strong> is said to be Non-hyperbolic.</p>
</blockquote>
<h2 id="Example-对Competitive-Lotka-Volterra-Equations分析相平面"><a href="#Example-对Competitive-Lotka-Volterra-Equations分析相平面" class="headerlink" title="Example: 对Competitive Lotka Volterra Equations分析相平面"></a>Example: 对Competitive Lotka Volterra Equations分析相平面</h2><p>在这个例子中，我们进一步化简方程组，我们假设 $F_X 和 F_y$ 与x, y呈线性关系：</p>
<script type="math/tex; mode=display">
\frac{dx}{dt} = x(1-x) - \alpha xy \\ \frac{dy}{dt} = r[y(1-y)-\beta xy]</script><h3 id="Step-1-求解Jacobian-matrix-和平衡点"><a href="#Step-1-求解Jacobian-matrix-和平衡点" class="headerlink" title="Step 1: 求解Jacobian matrix 和平衡点"></a>Step 1: 求解Jacobian matrix 和平衡点</h3><p>根据定义有：</p>
<script type="math/tex; mode=display">
                    x(1-x) - \alpha xy =0 \\ r\left\{y(1-y)-\beta xy\right\}=0</script><p>其中，(0,0),(1,0) and (0,1) 显而易见是方程的平衡点，从现实意义上讲，这都意味着一个种族的人口为0，我们还能发现:</p>
<script type="math/tex; mode=display">
                    x≡x_c = \frac{1-\alpha}{1 - \alpha \beta} \\
y≡y_c = \frac{1-\beta}{1 - \alpha \beta}</script><p>我们称这组解为<strong>coexistence equilibrium state，</strong>即两个种族的共生状态。但是这个解并不是一直成立，因为我们定义x, y都是大于等于0的。所以𝛼与𝛽应<strong>同时</strong>在（0，1）之间或者<strong>同时</strong>在(1, +∞), 才存在这个平衡点。</p>
<p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/Screenshot_2024-04-27_at_00.56.47.png" alt="Equilibrium Point and Jacobian Matrix"></p>
<p>Equilibrium Point and Jacobian Matrix</p>
<h2 id="Step-2-Classify-the-equilibrium-points"><a href="#Step-2-Classify-the-equilibrium-points" class="headerlink" title="Step 2: Classify the equilibrium points"></a>Step 2: Classify the equilibrium points</h2><p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/256c6741-8e0a-4d0e-915d-8b4121776351.png" alt="Screenshot 2024-04-27 at 01.04.29.png"></p>
<blockquote>
<p>Invariant set：A set of points $S \in R^2$  is an invariant set if $(x,y) \in S$ at some time t implies that $(x,y) \in S \text{ for } ∀t.$对于这个模型来说，x, y轴就是Invariant Set</p>
</blockquote>
<h3 id="Step-3-相平面绘制"><a href="#Step-3-相平面绘制" class="headerlink" title="Step 3: 相平面绘制"></a>Step 3: 相平面绘制</h3><p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/e250e020-d6fc-4924-bb7a-18f5fd2588b0.png" alt="Screenshot 2024-04-27 at 01.10.40.png"></p>
<p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/Screenshot_2024-04-27_at_01.10.55.png" alt="Screenshot 2024-04-27 at 01.10.55.png"></p>
<p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/Screenshot_2024-04-27_at_01.11.05.png" alt="Screenshot 2024-04-27 at 01.11.05.png"></p>
<p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/5554fc6d-3a9c-4532-a8ff-375456c58def.png" alt="Screenshot 2024-04-27 at 01.11.24.png"></p>
<p>在最后的Case中，我们介绍一个概念：Basin of attraction：</p>
<p>在相平面中，”吸引盆”（Basin of Attraction）是指一个动力系统中，对于一个给定的<strong>稳定平衡点</strong>或稳定<strong>极限环</strong>，所有从中起始最终趋向于该平衡点或极限环的初始条件的集合。简单来说，吸引盆是相空间中的一个区域，如果系统的状态从该区域内的任意点开始演化，随着时间的推移，它将逐渐靠近并最终达到稳定状态（如一个吸引子，可以是一个点、闭合轨道或是更复杂的集合）。</p>
<p><img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/6ea591aa-63b2-4b10-a79e-8bf45a97439a.png" alt="Screenshot 2024-04-27 at 01.15.15.png"></p>
<h2 id="Second-Order-ODE"><a href="#Second-Order-ODE" class="headerlink" title="Second Order ODE"></a>Second Order ODE</h2><p>对于二阶微分方程，我们也可以使用相平面法去探索物体的变化规律，单摆是一个简单的例子：</p>
<script type="math/tex; mode=display">
F = -kx</script><p>我们已知单摆在小角度下成立，将其写成ODE的形式，并将参数定义为ω,有：</p>
<script type="math/tex; mode=display">
\frac{d^2\theta}{dt^2} ≡ \frac{d^2x}{dt^2} = -\omega^2x = -\omega^2sin\theta</script><p>我们令 $q = \theta_t$, q可以理解为一个速度变量，构造二元方程：</p>
<script type="math/tex; mode=display">
\frac{d\theta}{dt} = q \\ \frac{dq}{dt} = -\omega^2 sin\theta</script><p>我们可以发现有平衡点(0, 0)，由于角度的周期性，角度加任意倍数的π都为平衡点，注意，（0， 0）是一个Linear Center，容易理解的，角度加360度不影响性质，所以任意360度的倍数都是Linear Center, 但是对于角度加180度，这并不能构成一个单摆的稳定状态，它将继续运动直到收敛于单摆运动，是saddle的。</p>
<h3 id="Conserved-System"><a href="#Conserved-System" class="headerlink" title="Conserved System"></a>Conserved System</h3><p>在这个场景中，我们认为是速度和位移两个元素构成了一个系统并探究两者的运动关系，在这个系统中，始终遵守：</p>
<script type="math/tex; mode=display">
\frac{d\theta}{dq} = \frac{d\theta}{dt} / \frac{dq}{dt} = -\frac{q}{\omega^2sin\theta}</script><p>那么通过求解微分方程，我们得到：</p>
<script type="math/tex; mode=display">
\frac{1}{2}q^2 - \omega^2cos\theta = Constant</script><p>我们称这个系统是保守系因为两者存在一个定值的约束关系，我们定义这个约束关系为E，称之为Conserved quantity。</p>
<p>根据这个约束条件，我们可以绘制不同定值下两者的变化关系。</p>
<ul>
<li>An integral path that connects one <strong>saddle point</strong> to another is called a heteroclinic connection or <strong>heteroclinic</strong> orbit串联所有的Saddle Point</li>
<li><p><strong>Homoclinic path</strong> ：过所有的平衡点的线</p>
<p>  <img src="Phase%20Plane%20Methods%201044dfc920d24d5a9caade87755c831d/Screenshot_2024-04-28_at_15.43.42.png" alt="Screenshot 2024-04-28 at 15.43.42.png"></p>
</li>
</ul>
<p>根据定义，我们可以知道红色轨迹是<strong>heteroclinic路径</strong>，因为这条路径经过所有的<strong>Saddle Point</strong></p>
<p>当角度初始为小角度时，轨迹围绕Linear Center平衡点，在Limit Cycle中运动，即有周期性的简谐运动。当角度过大，或者q过大，则会做圆周运动，如蓝线所示。</p>
<h2 id="Limit-Cycle"><a href="#Limit-Cycle" class="headerlink" title="Limit Cycle"></a>Limit Cycle</h2><p>在保守系统中，我们定义：极限环（Limit Cycle）主要用于描述动态系统的行为。极限环是一个封闭的轨道，这意味着系统的状态（通常表现为某些变量的集合）随时间演化后，将返回到起始位置，并重复这一周期性的行为。接下来我们将讨论如何判断一个封闭空间有没有Limit Cycle</p>
<h3 id="Method-1-Poincaré-index"><a href="#Method-1-Poincaré-index" class="headerlink" title="Method 1: Poincaré index"></a>Method 1: Poincaré index</h3><p>对于一个封闭曲线，我们为这个曲线计算一个参数，叫Poincare Index，有以下准则：</p>
<ul>
<li>如果这个曲线围城的区域中不含有任何平衡点，则其Index=0</li>
<li>若$L = L_1 +L_2$,则 $Index(R) = Index(R_1) + Index(R_2)$</li>
<li>若这个曲线是Limit Cycle，Index = 1</li>
<li>曲线每包含一个：<ul>
<li>Saddle Point: -1</li>
<li>Center: +1 包括 Nodes， spirals</li>
</ul>
</li>
</ul>
<p>Theorem：若曲线围的所有平衡点的Index和不为1，曲线围的区域不存在Limit Center</p>
<h3 id="Method-2-Bendixson’s-negative-criterion"><a href="#Method-2-Bendixson’s-negative-criterion" class="headerlink" title="Method 2: Bendixson’s negative criterion"></a>Method 2: Bendixson’s negative criterion</h3><p>对于一个简单的封闭区域R，若对于R中的点(x,y):</p>
<script type="math/tex; mode=display">
D = \frac{\partial X}{\partial x} + \frac{\partial Y}{\partial y}</script><p>若D在遍历所有点时符号无改变，则不存在Limit Cycle在R中。但这个式子并不是非常有用，进一步，可以结合Dulac’s extension</p>
<p>构造在R中连续函数  $\rho(x, y)$ ，若</p>
<script type="math/tex; mode=display">
D = \frac{\partial \rho X}{\partial x} + \frac{\partial \rho Y}{\partial y}</script><p>在R中所有点仍不变号，则无Limit Cycle</p>
<p>我们可以用这个方法检测Lotka-Volterra system</p>
<script type="math/tex; mode=display">
\frac{dx}{dt} = x(1-x) - \alpha xy \\ \frac{dy}{dt} = r[y(1-y)-\beta xy]</script><p>在不结合Dulac’s extension, $X_x = 1 - 2x - \alpha y, Y_y = r - 2r - r\beta x$</p>
<script type="math/tex; mode=display">
D= 1 − 2x − αy + r(1 − 2y) − rβx.</script><p>这看起来并并不直观，但是当结合了Dulac’s extension，我们定义 $\rho(x,y) = {1\over xy}$:</p>
<script type="math/tex; mode=display">
D = {\partial \over \partial x} {1\over y}[(1-x) - \alpha]+ {\partial \over \partial x} {r\over x}[(1-y) - \beta] = -{1\over y } - {r \over x}</script><p>由于(x,y)总在第一象限，所以D恒小于0，则在第一象限内不存在Limit Cycle.</p>
<h3 id="Poincare-Bendixson-theorem"><a href="#Poincare-Bendixson-theorem" class="headerlink" title="Poincaré-Bendixson theorem"></a>Poincaré-Bendixson theorem</h3><p>把这两个人的名字和在一起，我们有这一定理：</p>
<p>Theorem：在二维平面中，若一个区域不存在平衡点，而Integral Path从所有边缘方向进入这个区域，那么这个区域一定存在Limit Cycle。</p>
<p>在这个定理的正式定义前，需要解释几个概念：</p>
<ul>
<li>Positively-invariant set：t=0 随着时间变大，Solution一直在这个区域内，如稳定螺旋</li>
<li>Negatively-invariant set：t=0 随着时间变小（小于0），Solution一直在这个区域内，如不稳定螺旋</li>
<li>若一个Integral Path不仅是Positively-invariant set还是Negatively-invariant set，那么这就是Limit Cycle</li>
</ul>
<blockquote>
<p><strong>Poincaré-Bendixson</strong>: If there exists a bounded, invariant region I in the phase plane, and I contains no equilibrium points, then I contains at least one limit cycle.</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>微分方程</tag>
        <tag>相平面</tag>
      </tags>
  </entry>
  <entry>
    <title>RLHF 强化学习人类反馈</title>
    <url>/2024/07/25/RLHF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>强化学习人类反馈（Reinforcement Learning from Human Feedback, RLHF）是一种通过结合强化学习和人类反馈来优化模型性能的方法。RLHF特别适用于那些<strong>主观性强、没有明确目标的任务</strong>，例如生成文本摘要、回答开放性问题等。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RLHF_1.png" alt=""></p>
<h3 id="RLHF-Process"><a href="#RLHF-Process" class="headerlink" title="RLHF Process"></a>RLHF Process</h3><h4 id="Step-1-创建偏好数据集（Preference-Dataset）"><a href="#Step-1-创建偏好数据集（Preference-Dataset）" class="headerlink" title="Step 1: 创建偏好数据集（Preference Dataset）"></a>Step 1: 创建偏好数据集（Preference Dataset）</h4><ul>
<li>给LLM（大型语言模型）一个文本，让基座模型生成两个摘要（Summary1和Summary2）。</li>
<li>人工标注：对于特定输入，给出两个摘要，并标注哪个更好。注意这里不能使用标量（scaler）评分，而是记录哪个摘要更好，即偏好数据集（Preference Dataset）。</li>
</ul>
<blockquote>
<p><strong>监督微调（Supervised Fine Tuning）</strong></p>
<ul>
<li>输入：文本 → 输出：摘要</li>
</ul>
<p><strong>强化学习人类反馈（RLHF）</strong></p>
<ul>
<li>输入：文本 → 输出：摘要1，摘要2，人类偏好</li>
</ul>
</blockquote>
<h4 id="Step-2-奖励模型（Reward-Model）"><a href="#Step-2-奖励模型（Reward-Model）" class="headerlink" title="Step 2: 奖励模型（Reward Model）"></a>Step 2: 奖励模型（Reward Model）</h4><p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RLHF_2.png" style="zoom:50%;" /></p>
<ul>
<li>{Prompt, Completion} → 奖励模型（Reward Model）（推理）→ 标量（Scaler），表示这个完成度如何</li>
<li>奖励模型的推理本质上是一个回归任务，其训练目标是：<ul>
<li>{Prompt, Winning Candidate, Losing Candidate}</li>
<li>目标是最大化胜出摘要与失败摘要之间的评分差异</li>
</ul>
</li>
</ul>
<h4 id="Step-3-在RL循环中使用奖励模型微调LLM"><a href="#Step-3-在RL循环中使用奖励模型微调LLM" class="headerlink" title="Step 3: 在RL循环中使用奖励模型微调LLM"></a>Step 3: 在RL循环中使用奖励模型微调LLM</h4><ul>
<li><p>调整基座模型的输出以最大化奖励。</p>
</li>
<li><p>引入一个新的提示数据集（Prompt Dataset），仅为提示数据集。</p>
<blockquote>
<p>强化学习（Reinforcement Learning）适用于复杂但开放的任务训练方法，Agent通过与环境的交互来解决任务。Agent通过行为作用在环境中，环境更新Agent的状态并给出奖励（正向或负向）。通过重复这个过程，Agent使用一个函数记录学习结果，函数以当前状态为输入，输出最合适的行为（Policy）。</p>
</blockquote>
</li>
</ul>
<h5 id="RLHF在LLM中的应用"><a href="#RLHF在LLM中的应用" class="headerlink" title="RLHF在LLM中的应用"></a>RLHF在LLM中的应用</h5><ul>
<li><strong>Agent</strong>：初始策略为基座LLM生成策略，初始状态为文本信息（Prompt）。</li>
<li>每次LLM生成tokens完成输出后，都会从奖励模型得到反馈分数：<ul>
<li>{Prompt, Completion} → Score</li>
</ul>
</li>
<li>学习目标是获得最高分数的生成策略（Policy），学习方法为近端策略优化（Proximal Policy Optimization, PPO）。</li>
</ul>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RLHF_3.png" style="zoom:50%;" /></p>
<h3 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h3><h4 id="微调方法"><a href="#微调方法" class="headerlink" title="微调方法"></a>微调方法</h4><ol>
<li><strong>完全微调（Full Fine Tuning）</strong>：更新所有权重。</li>
<li><strong>参数高效微调（Parameter Efficient Tuning）</strong>：只更新一部分参数，保留基座模型中的其他参数。</li>
</ol>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><ol>
<li><p>偏好数据集：用于训练奖励模型</p>
<p>字典Key为<code>[&#39;input_text&#39;, &#39;candidate_0&#39;, &#39;candidate_1&#39;, &#39;choice&#39;]</code></p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">&#x27;input_text&#x27;<span class="punctuation">:</span> &#x27;I live right next to a huge university<span class="punctuation">,</span> and have been applying for a variety of jobs with them through ... <span class="punctuation">[</span>summary<span class="punctuation">]</span><span class="punctuation">:</span> &#x27;<span class="punctuation">,</span> </span><br><span class="line">&#x27;candidate_0&#x27;<span class="punctuation">:</span> &#x27; When applying through a massive job portal<span class="punctuation">,</span> is just one HR person seeing ALL of them?&#x27;<span class="punctuation">,</span> </span><br><span class="line">&#x27;candidate_1&#x27;<span class="punctuation">:</span> &#x27; When applying to many jobs through a single university jobs portal<span class="punctuation">,</span> is just one HR person reading ALL my applications?&#x27;<span class="punctuation">,</span> </span><br><span class="line">&#x27;choice&#x27;<span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p> 我们可以看到input text末尾有<code>[summary]:</code> 标记，用于标记任务为summary任务</p>
</li>
<li><p>Prompt数据集: 用于强化学习循环，在演示中仅有6条: 每个元素的格式为key+value:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>&#x27;input_text&#x27;<span class="punctuation">:</span> <span class="string">&quot;Nooooooo, I loved my health class! My teacher was amazing! Most days we just went outside and played and the facility allowed it because the health teacher&#x27;s argument was that teens need to spend time outside everyday and he let us do that. The other days were spent inside with him teaching us how to live a healthy lifestyle. He had guest speakers come in and reach us about nutrition and our final was open book...if we even had a final.... [summary]: &quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="RLHF-Pipeline"><a href="#RLHF-Pipeline" class="headerlink" title="RLHF Pipeline"></a>RLHF Pipeline</h3><p>RLHF Pipeline就是对下图流程的复现：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RLHF_4.png" style="zoom:33%;" /></p>
<p>在实例中使用了谷歌云Pipeline平台，Pipeline由yaml文件定义，是一个完整了RLHF流程，我们需要导入平台并且准备好数据的路径。训练使用Llama2作为基座模型。</p>
<h4 id="奖励模型训练步数设置"><a href="#奖励模型训练步数设置" class="headerlink" title="奖励模型训练步数设置"></a>奖励模型训练步数设置</h4><p><strong>Reward_model_train_steps</strong>是训练奖励模型时使用的步数。这取决于首选项数据集的大小。我们建议模型应该在偏好数据集上训练20-30个epoch以获得最佳结果。</p>
<script type="math/tex; mode=display">
\begin{align*} \text{stepsPerEpoch} &= \left\lceil \frac{\text{datasetSize}}{\text{batchSize}} \right\rceil \\ \text{trainSteps} &= \text{stepsPerEpoch} \times \text{numEpochs} \end{align*}</script><p>RLHF管道参数要求的是训练步数，而不是epoch数。下面是如何从epoch到训练步骤的示例，假设此管道的批处理大小固定为每批64个示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练数据大小</span></span><br><span class="line">PREF_DATASET_SIZE = <span class="number">3000</span></span><br><span class="line"><span class="comment"># 批次大小</span></span><br><span class="line">BATCH_SIZE = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">REWARD_STEPS_PER_EPOCH = math.ceil(PREF_DATASET_SIZE / BATCH_SIZE) <span class="comment"># 约47次</span></span><br><span class="line"></span><br><span class="line">REWARD_NUM_EPOCHS = <span class="number">30</span> 期待的迭代次数</span><br><span class="line"><span class="comment"># 计算训练步数</span></span><br><span class="line">reward_model_train_steps = REWARD_STEPS_PER_EPOCH * REWARD_NUM_EPOCHS <span class="comment"># 1410</span></span><br></pre></td></tr></table></figure>
<h4 id="强化模型训练步数设置"><a href="#强化模型训练步数设置" class="headerlink" title="强化模型训练步数设置"></a>强化模型训练步数设置</h4><p><strong>Reinforcement learning train steps</strong> 参数是指在调优基础模型时要执行的强化学习步数。</p>
<ul>
<li>训练步数取决于提示数据集的大小。通常，这个模型应该在提示数据集上训练大约10-20个epoch。</li>
<li>Reward hacking：如果给予过多的训练步数，策略模型可能会找到一种方法来利用奖励，从而表现出不期望的行为。</li>
</ul>
<p>强化模型的Epoch数通常为10-20，我们根据这个epoch计算总共的训练次数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Prompt dataset size</span></span><br><span class="line">PROMPT_DATASET_SIZE = <span class="number">2000</span></span><br><span class="line"><span class="comment"># Batch size is fixed at 64</span></span><br><span class="line">BATCH_SIZE = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">RL_STEPS_PER_EPOCH = math.ceil(PROMPT_DATASET_SIZE / BATCH_SIZE)</span><br><span class="line"><span class="built_in">print</span>(RL_STEPS_PER_EPOCH)</span><br><span class="line"></span><br><span class="line">RL_NUM_EPOCHS = <span class="number">10</span></span><br><span class="line"><span class="comment"># Calculate the number of steps in the RL training</span></span><br><span class="line">reinforcement_learning_train_steps = RL_STEPS_PER_EPOCH * RL_NUM_EPOCHS <span class="comment"># 320</span></span><br></pre></td></tr></table></figure>
<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>根据上面计算的步长结果，填写整个任务流程中的超参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Completed values for the dictionary</span></span><br><span class="line">parameter_values=&#123;</span><br><span class="line">        <span class="string">&quot;preference_dataset&quot;</span>: \\</span><br><span class="line">    <span class="string">&quot;gs://vertex-ai/generative-ai/rlhf/text_small/summarize_from_feedback_tfds/comparisons/train/*.jsonl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;prompt_dataset&quot;</span>: \\</span><br><span class="line">    <span class="string">&quot;gs://vertex-ai/generative-ai/rlhf/text_small/reddit_tfds/train/*.jsonl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eval_dataset&quot;</span>: \\</span><br><span class="line">    <span class="string">&quot;gs://vertex-ai/generative-ai/rlhf/text_small/reddit_tfds/val/*.jsonl&quot;</span>,</span><br><span class="line">    <span class="comment"># 数据集地址</span></span><br><span class="line">        <span class="string">&quot;large_model_reference&quot;</span>: <span class="string">&quot;llama-2-7b&quot;</span>, <span class="comment"># 基座模型</span></span><br><span class="line">        <span class="string">&quot;reward_model_train_steps&quot;</span>: <span class="number">1410</span>, </span><br><span class="line">        <span class="string">&quot;reinforcement_learning_train_steps&quot;</span>: <span class="number">320</span>, <span class="comment"># results from the calculations above</span></span><br><span class="line">        <span class="string">&quot;reward_model_learning_rate_multiplier&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="string">&quot;reinforcement_learning_rate_multiplier&quot;</span>: <span class="number">1.0</span>,</span><br><span class="line">        <span class="string">&quot;kl_coeff&quot;</span>: <span class="number">0.1</span>, <span class="comment"># increased to reduce reward hacking</span></span><br><span class="line">        <span class="string">&quot;instruction&quot;</span>:\\</span><br><span class="line">    <span class="string">&quot;Summarize in less than 50 words&quot;</span> <span class="comment"># 补充的提示词&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h4><ul>
<li>训练奖励模型损失函数: 收敛较好</li>
</ul>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/RLHF_5.png" style="zoom:40%;" /></p>
<ul>
<li><p>PPO训练曲线</p>
<ul>
<li><p>KL Loss: KL (Kullback-Leibler) 散度（KL divergence）是一种衡量两个概率分布之间差异的非对称度量。在强化学习中，KL 散度通常用于衡量新策略与旧策略之间的差异，以确保策略更新不会过于激进，从而保持训练的稳定性。</p>
<blockquote>
<p><strong>初期快速上升</strong>：这是比较常见的现象，说明模型在初期调整过程中，策略变化较大，从而导致与旧策略之间的差异增大。</p>
<p><strong>波动期</strong>：这段时间的波动可能是由于强化学习过程中的探索与利用权衡，模型在尝试不同策略以寻找最优解。这种波动也可能表明模型在调整过程中遇到了一些不稳定性。</p>
<p><strong>稳定期</strong>：在训练的后期，KL损失趋于稳定，表明模型的策略更新幅度减小，策略逐渐稳定。这也说明模型已经找到了一个相对稳定的策略，不再进行大的调整。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>两个Examples</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input Text</th>
<th>Base LLM</th>
<th>Tuned LLM</th>
</tr>
</thead>
<tbody>
<tr>
<td>Summarize in less than 50 words. Before anything, not a sad story or anything. My country’s equivalent to Valentine’s Day is coming and I had this pretty simple idea to surprise my girlfriend and it would involve giving her some roses. The thing is, although I know she would appreciate my intention in and of itself, I don’t know if she would like the actual flowers and such, so I wanted to find out if she likes roses and if she would like getting some, but without her realizing it so as not to spoil the surprise. Any ideas on how to get that information out of her? [summary]:</td>
<td>The author wants to surprise his girlfriend with roses on Valentine’s Day but he doesn’t know if she likes roses. He wants to find out without spoiling the surprise.</td>
<td>My country’s equivalent to Valentine’s Day is coming. Want to surprise my girlfriend with roses but don’t know if she would like getting some. Any ideas on how to get that information out of her without spoiling the surprise</td>
</tr>
<tr>
<td>Summarize in less than 50 words. Hello jobs, I graduated a few months ago and had no luck so far to get a job in marketing/sales. There’s a small local company (perhaps 30 employees) but they are actually pretty successful in what they’re doing (known worldwide). I checked their website and it’s awful. Looks like a website from the early 2000’s. So I guess they are not pretty good in (online-)marketing. I would like to do a cold application (not sure if they are looking for a marketing guy) but I had no luck with this kind of application in the past. That’s why I thought I try something different. I have good skills in Photoshop, InDesign and Illustrator. As a teenager I also built websites using HTML, so I thought I build a dummy website fitted to their company and attach some screenshots to my application. What do you think? I this a feasible idea or will they be offended? Thank you very much in advance. [summary]:</td>
<td>Graduated a few months ago, looking for a job in marketing/sales. Found a small local company that is successful but has an awful website. I want to apply for a marketing job but not sure if they are hiring. I thought of building a dummy website for them and attach some screenshots to my application.</td>
<td>Graduated a few months ago. No luck so far to get a job in marketing/sales. Thought to build a dummy website fitted to the company and attach some screenshots to my application. What do you think?</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorboard 部署测试</title>
    <url>/2024/07/25/tensorboard/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Tensorboard-in-Pytorch-Introduction"><a href="#Tensorboard-in-Pytorch-Introduction" class="headerlink" title="Tensorboard in Pytorch Introduction"></a>Tensorboard in Pytorch Introduction</h3><p>Tensorboard是一个用于机器学习实验的可视化工具包。TensorBoard允许跟踪和可视化指标，如损失和准确性，可视化模型图，查看直方图，显示图像等，本文介绍pytorch架构下使用Tensor Board。核心原理是使用SummaryWriter()记录需要的数据（类似于Wandb的实例）并且在本地localhost进行可视化。</p>
<h3 id="SummaryWriter实例创建"><a href="#SummaryWriter实例创建" class="headerlink" title="SummaryWriter实例创建"></a>SummaryWriter实例创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">!pip install tensorboard</span><br></pre></td></tr></table></figure>
<p>TensorBoard可以理解成数据可视化的工具，使用时我们需要准备好记录训练时的数据，这时候就需要<code>SummaryWriter</code>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">writer = SummaryWriter()</span><br></pre></td></tr></table></figure>
<h3 id="Example-感知机回归下的TensorBoard监控"><a href="#Example-感知机回归下的TensorBoard监控" class="headerlink" title="Example: 感知机回归下的TensorBoard监控"></a>Example: 感知机回归下的TensorBoard监控</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(<span class="number">3</span>, <span class="number">1000</span>),</span><br><span class="line">    torch.nn.Sigmoid(),</span><br><span class="line">    torch.nn.Linear(<span class="number">1000</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_weights</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == torch.nn.Linear:</span><br><span class="line">        torch.nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">model.apply(init_weights)</span><br><span class="line"></span><br><span class="line">model</span><br></pre></td></tr></table></figure>
<p>​    Sequential(<br>​      (0): Linear(in_features=3, out_features=1000, bias=True)<br>​      (1): Sigmoid()<br>​      (2): Linear(in_features=1000, out_features=1, bias=True)<br>​    )</p>
<p>生成多项式数据集: $y = sin(x_1) + cos(x_2) + x_3^2$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_data</span>(<span class="params">n=<span class="number">1000</span></span>):</span><br><span class="line">    x = torch.rand(n, <span class="number">3</span>)</span><br><span class="line">    y = torch.sin(x[:, <span class="number">0</span>]) + torch.cos(x[:, <span class="number">1</span>]) + x[:, <span class="number">2</span>]**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line">x, y = generate_data()</span><br><span class="line"><span class="comment"># 生成验证集</span></span><br><span class="line">x_val, y_val = generate_data(n=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 导入pytorch</span></span><br><span class="line"></span><br><span class="line">data_set = torch.utils.data.TensorDataset(x, y)</span><br><span class="line">train_loader = torch.utils.data.DataLoader(data_set, batch_size=<span class="number">16</span>, shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>使用TensorBoard查看模型结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span> = x</span><br><span class="line">writer.add_graph(model, <span class="built_in">input</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84%E5%AE%9E%E4%BE%8B.png" style="zoom:50%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">critertion = torch.nn.MSELoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> inputs, targets <span class="keyword">in</span> train_loader:</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = critertion(outputs, targets)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    writer.add_scalar(<span class="string">&#x27;train_loss&#x27;</span>, loss, epoch)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>, Loss: <span class="subst">&#123;loss.item()&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="comment"># 记录参数范数变化</span></span><br><span class="line">        <span class="keyword">for</span> name, param <span class="keyword">in</span> model.named_parameters():</span><br><span class="line">            writer.add_scalar(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>_norm&#x27;</span>, param.norm().item(), epoch + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 记录验证集loss</span></span><br><span class="line">        val_hat = model(x_val)</span><br><span class="line">        val_loss = critertion(val_hat, y_val)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;val_loss&#x27;</span>, val_loss, epoch)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不同同激活函数下的训练过程：<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/Screenshot%202024-07-23%20at%2014.14.24.png" alt=""></p>
</li>
<li><p>Sigmoid激活函数下参数训练的范数变化：<br><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9B%91%E6%8E%A7.png" alt=""></p>
</li>
</ul>
<h3 id="对比Wandb与Tensorboard"><a href="#对比Wandb与Tensorboard" class="headerlink" title="对比Wandb与Tensorboard"></a>对比Wandb与Tensorboard</h3><ul>
<li>Tensorboard相比于Wandb在绘制模型结构这个功能上更加简单</li>
<li>无需联网，但是服务器有时候不稳定，经常需要刷新；需要注意log文件存放的位置以及管理</li>
<li>不太能协同工作，Wandb基本可以替代TensorBoard</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>基于BS模型条件下的期权价格改变策略</title>
    <url>/2025/01/21/BS-Model/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="BS模型基本假设"><a href="#BS模型基本假设" class="headerlink" title="BS模型基本假设"></a>BS模型基本假设</h2><p>研究的背景为风险中性、无套利的欧市市场，因此我们有：</p>
<script type="math/tex; mode=display">
C(X, S_t, r_{t,\tau}, \tau) = e^{-r_{t,\tau}, \tau} \int_0^{\infty} \psi(S_T, X)f(S_T)dS_T</script><p>其中，$\tau = T - t$ 为当前时间和交易日的差值，$X$为执行价(Strike Price)，$r$为无风险利率(risk-free rate),$f(S_T)$为资产价格分布，$\psi(S_T, X) = \max\left\{S_T - X\right\}$。</p>
<p>在Black-Scholes模型的定义中，标的资产价格$S_t$(State Price)为Geometric Brownian运动，则${S_t}$符合正态指数分布。</p>
<p>同时，期权价格$C$(Option Price)与$S_T$有：</p>
<script type="math/tex; mode=display">
f(S_T) = e^{r_{t, \tau}, \tau} \frac{\partial^2C}{\partial X^2}|_{X=S_t}</script><p>其中</p>
<h2 id="BS模型改进方案"><a href="#BS模型改进方案" class="headerlink" title="BS模型改进方案"></a>BS模型改进方案</h2><p>我们通过改变传统的指数正态分布使得BS模型拟合的更加精准。具体的，我们定义$S_t$符合混合分布，即：</p>
<script type="math/tex; mode=display">
h(\ln(S_T)) = \int\phi(\ln{S_T}|\mu, \sigma^2) dG(\mu, \sigma)</script><p>其中，正态分布满足 $\ln(S_T) \sim \mathcal{N}(ln(S_t) + (r_{t, \tau} - \delta -\sigma^2)\tau, \sigma\sqrt\tau) $ ,进一步有：</p>
<script type="math/tex; mode=display">
f(S_T) = \int v(S_T|\mu, \sigma^2) dG(\mu, \sigma)</script><p>其中$v$为符合上述正态分布的指数正态分布函数。那么对应的期权价格也有混合分布的形式：</p>
<script type="math/tex; mode=display">
\begin{align*}
C(X, G) &= e^{-r_{t, \tau}\tau}
\int\psi(S_T)f(S_T)dS_T \\
&= \int\int e^{-r_{t, \tau}\tau}\psi(S_T)v(S_T|\mu, \sigma^2)dS_TdG(\mu, \sigma)\\
&\equiv\int C(X, \mu, \sigma^2) dG(\mu, \sigma)
\end{align*}</script><script type="math/tex; mode=display">
\begin{align*}
C(X, \mu, \sigma^2) &= e^{-r_{t, \tau}\tau}\int\psi(S_T)v(S_T|\mu, \sigma^2)dS_T \\
&= e^{-r_{t, \tau}\tau}\int_{-\infty}^{\infty}(e^{S_T} - X) + \phi(s|\mu, \sigma^2)ds \\
&= e^{-r_{t, \tau}\tau + \sigma^2/2 + \mu}\overline{\Phi}\left(\frac{\ln(X) - (\mu + \sigma^2)}{\sigma}\right) - e^{-r_{t, \tau}\tau}\overline{\Phi}\left(\frac{\ln(X) - \mu}{\sigma}\right) 
\end{align*}</script><p>其中 $\overline{\Phi}(\cdot) = 1 - \Phi(\cdot)$</p>
<h2 id="具体计算策略"><a href="#具体计算策略" class="headerlink" title="具体计算策略"></a>具体计算策略</h2><h3 id="优化问题陈述"><a href="#优化问题陈述" class="headerlink" title="优化问题陈述"></a>优化问题陈述</h3><p>我们通过收集：</p>
<ul>
<li>$\mathbf{C}$: 实际期权价格</li>
<li>$\mathbf{x}$: 实际执行价 </li>
<li>$r, \delta, T$: 用于计算的参数</li>
</ul>
<p>构造最小二乘优化问题：</p>
<script type="math/tex; mode=display">
\begin{align*}
\hat{G} &= \arg\min_{g\in G} \sum_{i=1}^{n} (C(x_i, G) - \mathbf{C}_i)^2 \\
&=\arg\min_{\left\{\mathbf{\pi}, \mathbf{\mu}, \sigma\right\}} \sum_{i=1}^{n} \left(\sum_{j=1}^{n+1} \pi_j C(x_i, \mu_j, \sigma^2) - \mathbf{C}_i\right)^2
\end{align*}</script><p>其中，$\pi_j$为混合分布的权重，满足$\sum_{j=1}^{n+1}\pi_j = 1$。</p>
<h3 id="约束条件分析"><a href="#约束条件分析" class="headerlink" title="约束条件分析"></a>约束条件分析</h3><p>根据无风险套利市场规则，我们有未来资产价格的期望值为当前资产价格的贴现值：</p>
<script type="math/tex; mode=display">
E[S_T] = S_t e^{(r - \delta)\tau}</script><p>进一步有：</p>
<script type="math/tex; mode=display">
\begin{align*}
\int e^{\mu + \sigma^2/2}dG(\mu, \sigma) &= S_t e^{(r - \delta)\tau} \\
S_t e^{\sigma^2/2} \sum_{j=1}^{n+1}\pi_j e^{\mu_j} &= S_t e^{(r - \delta)\tau} \\ 
e^{\sigma^2/2} \sum_{j=1}^{n+1}\pi_j e^{\mu_j} &= e^{(r - \delta)\tau} \\
\end{align*}</script><h3 id="优化问题求解"><a href="#优化问题求解" class="headerlink" title="优化问题求解"></a>优化问题求解</h3><ol>
<li><p>猜测$\sigma^2$, 并且对$\mu_j$进行初始化 </p>
</li>
<li><p>假设$\sigma^2$, $\mu_j$已知，求解$\pi_j$: 使用二次规划算法求解</p>
</li>
<li><p>使用牛顿-莱布尼茨法求 $\mu_j$</p>
</li>
</ol>
<h2 id="AMD公司的期权价格分析"><a href="#AMD公司的期权价格分析" class="headerlink" title="AMD公司的期权价格分析"></a>AMD公司的期权价格分析</h2><h3 id="期权价格数据拟合"><a href="#期权价格数据拟合" class="headerlink" title="期权价格数据拟合"></a>期权价格数据拟合</h3><p>我们通过上述方法对AMD公司的期权价格进行分析，我们提取了2018年AMD公司6月7月的期权价格数据。我们将其分割为两个部分，对应$\tau = 0.0958$和$\tau = 0.08493$。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MixBS_Train_AMD.png" alt=""></p>
<p>此图为训练集的期权价格分布，我们可以看到，期权价格分布在不同的执行价上有不同的分布。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MixBS_Test_AMD.png" alt=""></p>
<p>此图为测试集的期权价格分布，我们可以看到拟合较好。</p>
<h3 id="Greeks分析"><a href="#Greeks分析" class="headerlink" title="Greeks分析"></a>Greeks分析</h3><p>我们通过对期权价格的混合分布进行分析，得到了期权价格的Greeks值:</p>
<ul>
<li><p>Delta: $\Delta = \frac{\partial C}{\partial S}$ 代表期权价格对标的资产价格的敏感程度</p>
</li>
<li><p>Theta: $\Theta = \frac{\partial C}{\partial \tau}$ 代表期权价格对时间的敏感程度</p>
</li>
<li><p>Gamma: $\Gamma = \frac{\partial^2 C}{\partial S^2}$ 代表Delta对标的资产价格的敏感程度</p>
</li>
<li><p>Vega: $\nu = \frac{\partial C}{\partial \sigma}$ 代表期权价格对波动率的敏感程度</p>
</li>
<li><p>Rho: $\rho = \frac{\partial C}{\partial r}$ 代表期权价格对无风险利率的敏感程度</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p>Black, F., &amp; Scholes, M. (1973). The pricing of options and corporate liabilities. Journal of political economy, 81(3), 637-654.</p>
</li>
<li><p>MING, Y(2009). STATE PRICE DENSITY ESTIMATION VIA NONPARAMETRIC MIXTURES. The Annals of Applied Statistics, 3(3), 963–984</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>概率论</tag>
        <tag>金融数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to GP Regression</title>
    <url>/2025/06/17/GP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="Definition-of-Gaussian-Process"><a href="#Definition-of-Gaussian-Process" class="headerlink" title="Definition of Gaussian Process"></a>Definition of Gaussian Process</h2><p>A Gaussian Process (GP) is a collection of random variables, any finite number of which have a joint Gaussian distribution. It is completely specified by its mean function $μ(x)$ and covariance function $k(x,x’)$, also known as the kernel function.</p>
<script type="math/tex; mode=display">
f(x)\sim GP(μ(x), k(x,x'))</script><p>Where:</p>
<ul>
<li>$μ(x) = E[f(x)]$  is the mean function</li>
<li>$k(x,x’) = E[(f(x) - μ(x))(f(x’) - μ(x’))]$ is the covariance function</li>
</ul>
<p>For a random process, we usually introduce a time series to interpret the meaning of different states (e.g., a Poisson Process, which is a counting process dependent on time). However, a more formal way to understand processes is to define them on a space. For instance, time steps are performed in $Z$ space, and consequently, the GP is a type of process defined on $R^d$. </p>
<p>Every point in $R^d$ represents a state corresponding to a unique Normal Distribution. The key rule for this space is that when we combine all these states, their joint distribution forms a <strong>Multivariate Normal Distribution</strong> with a unique covariance function $K: R^d \rightarrow R \times R$</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Unlike Machine Learning Problem, once we have the dataset with vector $\mathbf{x}$ and target variable $y$, we do not need to split the dataset since the model assumption indicts the difference between training data and prediction data, following by the distribution:</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
y \\
y^*
\end{bmatrix}
\sim
\mathcal{N}\left(
\begin{bmatrix}
\mu(\mathbf{X}) \\
\mu(\mathbf{X}^*)
\end{bmatrix},
\begin{bmatrix}
K(\mathbf{X}, \mathbf{X}) + \sigma_n^2 \mathbf{I} & K(\mathbf{X}, \mathbf{X}^*) \\
K(\mathbf{X^*}, \mathbf{X}) & K(\mathbf{X^*}, \mathbf{X^*})
\end{bmatrix}
\right)</script><p>Note:</p>
<script type="math/tex; mode=display">
\text{Cov}(\mathbf{y}, \mathbf{y}^*) = \text{Cov}(\mathbf{f(X) + \epsilon}, \mathbf{f^*(X)}) = \text{Cov}(f, f^*) = K(\mathbf{X}, \mathbf{X}^*)</script><h2 id="Prior-and-Posterior-distribution"><a href="#Prior-and-Posterior-distribution" class="headerlink" title="Prior and Posterior distribution"></a>Prior and Posterior distribution</h2><p>For the convenience of illustration, the prior distribution is commonly set up by: </p>
<script type="math/tex; mode=display">
\mu(X)= 0 \;\ k(x,x') = \Sigma \text{ which is known kernel}</script><p>The next step is to find the posterior distribution of  $y^<em> | x, y, x^</em>$, we consider the general form:</p>
<script type="math/tex; mode=display">
\mathbf{z} = \begin{bmatrix} \mathbf{a} \\ \mathbf{b} \end{bmatrix} \sim \mathcal{N}(\boldsymbol{\mu}, \Sigma),\quad
\boldsymbol{\mu} = \begin{bmatrix} \boldsymbol{\mu}_a \\ \boldsymbol{\mu}_b \end{bmatrix},\quad
\Sigma =
\begin{bmatrix}
A & C \\
C^\top & B
\end{bmatrix}</script><script type="math/tex; mode=display">
\begin{align*}
p(\mathbf{b} \mid \mathbf{a}) &= \frac{p(\mathbf{a}, \mathbf{b})}{p(\mathbf{a})} \sim \frac{\mathcal{N}(\boldsymbol{\mu}, \Sigma)}{\mathcal{N}(\mathbf{\mu}_a, A)} \\ &= \frac{\frac{1}{(2\pi)^{d/2} |\Sigma|^{1/2}} \exp\left\{ -\frac{1}{2} (\mathbf{z} - \boldsymbol{\mu})^\top \Sigma^{-1} (\mathbf{z} - \boldsymbol{\mu}) \right\}}{\frac{1}{(2\pi)^{n/2} |A|^{1/2}} \exp\left\{ -\frac{1}{2} (\mathbf{z} - \mu_a)^\top A^{-1} (\mathbf{z} - \mu_a) \right\}}
\end{align*}</script><p>Since we known that the division of Normal Distribution is also Normal, and the dominator is constant since the data is given, we analysis $\mathcal{N}(\boldsymbol{\mu}, \Sigma)$ directly. </p>
<p>Let $\delta \mathbf{a} := \mathbf{a} - \boldsymbol{\mu}_a,\quad \delta \mathbf{b} := \mathbf{b} - \boldsymbol{\mu}_b$ and we have:</p>
<script type="math/tex; mode=display">
\begin{align*}
p(\mathbf{b} \mid \mathbf{a}) &\propto  \exp\left\{ -\frac{1}{2} (\mathbf{z} - \boldsymbol{\mu})^\top \Sigma^{-1} (\mathbf{z} - \boldsymbol{\mu}) \right\} \\ &=\exp\left\{-\frac{1}{2}\begin{bmatrix}\delta \mathbf{a} \\\delta \mathbf{b}\end{bmatrix}^\top\Sigma^{-1}\begin{bmatrix}\delta \mathbf{a} \\\delta \mathbf{b}
\end{bmatrix}\right\}
\end{align*}</script><p>Given that for block matrix, we have:</p>
<script type="math/tex; mode=display">
\Sigma =
\begin{bmatrix}
A & C \\
C^\top & B
\end{bmatrix}
\Rightarrow
M:= \Sigma^{-1} =
\begin{bmatrix}
A^{-1} + A^{-1} C S^{-1} C^\top A^{-1} & -A^{-1} C S^{-1} \\
S^{-1} C^\top A^{-1} & S^{-1}
\end{bmatrix} \\ 

\text{ where: }
S := B - C^\top A^{-1} C \quad \text{(Schur complement)}</script><p>We define:  </p>
<script type="math/tex; mode=display">
Q(\mathbf{a}, \mathbf{b}) =
\begin{bmatrix}
\delta \mathbf{a} \\
\delta \mathbf{b}
\end{bmatrix}^\top
\begin{bmatrix}
A & C \\
C^\top & B
\end{bmatrix}^{-1}
\begin{bmatrix}
\delta \mathbf{a} \\
\delta \mathbf{b}
\end{bmatrix}</script><p>and complete the square：</p>
<script type="math/tex; mode=display">
\begin{align*}Q(\mathbf{a}, \mathbf{b}) &=
\delta \mathbf{a}^\top M_{aa} \delta \mathbf{a} +
2 \delta \mathbf{a}^\top M_{ab} \delta \mathbf{b} +
\delta \mathbf{b}^\top M_{bb} \delta \mathbf{b} \\ 
&= 
\delta \mathbf{b}^\top M_{bb} \delta \mathbf{b} +
2 \delta \mathbf{b}^\top M_{ba} \delta \mathbf{a} + \text{(constant)} \\ 
&= 
(\delta \mathbf{b} + M_{bb}^{-1} M_{ba} \delta \mathbf{a})^\top M_{bb}
(\delta \mathbf{b} + M_{bb}^{-1} M_{ba} \delta \mathbf{a})
+ \text{(constant)}

\end{align*}</script><p>which means:</p>
<script type="math/tex; mode=display">
p(\mathbf{b} \mid \mathbf{a}) \propto \exp[-\frac{1}{2}Q(\mathbf{a}, \mathbf{b}))]\Rightarrow \mathbf{b} \mid \mathbf{a} \sim \mathcal{N}(\mu_n, \Sigma_n) \\ 
\mu_n =  \mu_b + C^\top A^{-1} (\mathbf{a} - \mu_a) \quad ; \quad  \Sigma_n = B - C^\top A^{-1} C</script><p>Given with the data, now we obtain the posterior distribution for the predictive points.</p>
<h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h2><p>Our key is to find the correct kernel expression, we can introduce marginal likelihood function and try to find the maximum value of it. We start from the definition:</p>
<script type="math/tex; mode=display">
p(\mathbf{y}\mid X, \theta) = \int_{\mathcal{R}^n} p(\mathbf{y} \mid \mathbf{f}) p(\mathbf{f}\mid X)d\mathbf{f}</script><p>We consider f mentioned in the integral is the arbitrary expectation in $R^n$ space. so that $p(y|f)$ can be interpret as: under such expectation, how likely will the true observation happens, which is a normal distribution as the model assumption, and the term $p(f|X)$ means the prior behavior of $f$, depending on how we define the prior distribution. In this case, it is $\mathcal{N}(\mathbf{\mu}, K)$ and $\mathbf{\mu} = \mathbf{0}$   .</p>
<p>Since both distribution is Normal, the convolution of 2 normal distribution is still Normal. We have</p>
<script type="math/tex; mode=display">
\mathbf{y} | X, \theta \sim \mathcal{N}(0， \sigma^2\mathbf{I}+K)</script><p>We use the <strong>Negative Log Marginal Likelihood (NLML)</strong> as the objective function to optimize model hyperparameters because it provides a principled and probabilistic way to learn the best settings for the kernel (e.g., length-scales, variances) and noise level.</p>
<script type="math/tex; mode=display">
\log p(\mathbf{y} \mid \mathbf{X}, \theta) = -\frac{1}{2} \mathbf{y}^\top (\mathbf{K}\theta + \sigma_n^2 \mathbf{I})^{-1} \mathbf{y} - \frac{1}{2} \log |\mathbf{K}\theta + \sigma_n^2 \mathbf{I}| - \frac{n}{2} \log 2\pi</script><p>And</p>
<script type="math/tex; mode=display">
\text{NLML}(\theta) = \frac{1}{2} \mathbf{y}^\top \mathbf{K}_y^{-1} \mathbf{y} + \frac{1}{2} \log |\mathbf{K}_y| + \frac{n}{2} \log 2\pi</script><p>with $\mathbf{K}_y = \mathbf{K}_\theta + \sigma_n^2 \mathbf{I}$. Notice that NLML is gradient based therefore we can use GD, Adam and other common methods to solve the minimum solution.</p>
<h2 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h2><ol>
<li>Data process and initial part:<ol>
<li>Data Cleaning and Normalize</li>
<li>Define the kernel function and initial the parameters to be optimized</li>
<li>Define NLML</li>
</ol>
</li>
<li>Training Loop in given epochs number<ol>
<li>Calculate  the NLML under current parameters</li>
<li>Use Gradient-based Method with a learning rate</li>
<li>Update the parameters</li>
</ol>
</li>
<li>After Training<ol>
<li>Calculate the posterior distribution and sample the result</li>
<li>Present the result and Validation</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>随机过程</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈岭回归与Armijo策略在梯度法中的表现</title>
    <url>/2025/11/22/ridge/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="引言：岭回归及其闭式解"><a href="#引言：岭回归及其闭式解" class="headerlink" title="引言：岭回归及其闭式解"></a>引言：岭回归及其闭式解</h3><p>在实际的数据科学中，我们经常遇到病态（ill-conditioned）的数据矩阵，即设计矩阵 $\mathbf{X}^T\mathbf{X}$ 的条件数很大，导致最小二乘估计对噪声极其敏感。这种情况在高维数据、共线性特征或样本量不足时尤为常见。病态问题会导致模型参数估计不稳定、方差过大，最终造成过拟合。</p>
<p>岭回归（Ridge Regression）作为一种正则化方法，通过在目标函数中添加 $L_2$ 惩罚项来缓解病态问题。本文旨在深入探讨：</p>
<ol>
<li><strong>岭回归如何在病态条件下发挥作用</strong>：从数学角度分析正则化参数 λ 如何改善矩阵的条件数，抑制噪声方向的影响</li>
<li><strong>正则化强度 λ 的权衡</strong>：研究 λ 在降噪和参数估计准确性之间的平衡关系</li>
<li><strong>梯度法求解岭回归的收敛性</strong>：当直接求解闭式解不稳定时，探索 Armijo 策略下不同参数对梯度下降法收敛速度的影响</li>
</ol>
<p>通过理论分析和数值实验，本文将展示岭回归在处理病态问题时的有效性，并为实际应用中参数选择提供指导。</p>
<p>考虑岭回归问题：</p>
<script type="math/tex; mode=display">\min_{\mathbf{w}_\lambda} J(\mathbf{w}_\lambda) = \|\mathbf{X}\mathbf{w}_\lambda - \mathbf{y}\|_2^2 + \lambda\|\mathbf{w}_\lambda\|_2^2</script><p>其目标函数为：</p>
<script type="math/tex; mode=display">
J(\mathbf{w}_\lambda) = \mathbf{w}_\lambda^T\mathbf{X}^T\mathbf{X}\mathbf{w}_\lambda - 2\mathbf{y}^T\mathbf{X}\mathbf{w}_\lambda + \mathbf{y}^T\mathbf{y} + \lambda\mathbf{w}_\lambda^T\mathbf{w}_\lambda</script><p>为获得闭式解，对目标函数求导并令其为零：</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial \mathbf{w}_\lambda} = 2\mathbf{X}^T\mathbf{X}\mathbf{w}_\lambda - 2\mathbf{X}^T\mathbf{y} + 2\lambda\mathbf{w}_\lambda = 0</script><p>求解 $\mathbf{w}_\lambda$ 得到闭式解：</p>
<script type="math/tex; mode=display">
\mathbf{w}^*_\lambda = (\mathbf{X}^T\mathbf{X} + \lambda\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}</script><p>注意到解的存在性依赖于 $\mathbf{X}^T\mathbf{X} + \lambda\mathbf{I}$ 的可逆性。当 $\lambda &gt; 0$ 时，该矩阵正定，因此必然可逆，解总是存在且唯一。当 $\lambda \leq 0$ 时，矩阵可能不正定，但若 $\mathbf{X}^T\mathbf{X} + \lambda\mathbf{I}$ 的所有特征值非零，解仍然存在。</p>
<p>通常情况下，我们取 $\lambda &gt; 0$，以提供 $L_2$ 正则化惩罚来控制过拟合，此时解总是存在且唯一。</p>
<p>本文采用人工构造的数据集进行实验，数据生成代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2025</span>)</span><br><span class="line">n, p, k = <span class="number">500</span>, <span class="number">50</span>, <span class="number">8</span></span><br><span class="line">sigma = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">m = <span class="number">10</span></span><br><span class="line">Z = np.random.randn(n, m)</span><br><span class="line">A = np.random.randn(m, p) * <span class="number">0.8</span></span><br><span class="line">X = Z.dot(A) + <span class="number">0.1</span> * np.random.randn(n, p)</span><br><span class="line"></span><br><span class="line">w_true = np.zeros(p)</span><br><span class="line">w_true[:k] = np.linspace(<span class="number">5.0</span>, <span class="number">1.0</span>, k) * np.random.choice([<span class="number">1</span>, -<span class="number">1</span>], k)</span><br><span class="line">y = X.dot(w_true) + sigma * np.random.randn(n)</span><br><span class="line"></span><br><span class="line">idx = np.random.permutation(n)</span><br><span class="line">train_idx, test_idx = idx[:<span class="number">350</span>], idx[<span class="number">350</span>:]</span><br><span class="line">X_train, y_train = X[train_idx], y[train_idx]</span><br><span class="line">X_test, y_test = X[test_idx], y[test_idx]</span><br></pre></td></tr></table></figure>
<p>在演示中，我们取 λ = 1.2, α = 0.5, β = 0.5。参数 λ = 1.2 经过详细分析（见后续讨论部分）被确定为最适合本问题的值。而 α 和 β 的值简单地设为其有效范围 [0, 1] 的中点，无特殊含义。</p>
<p>对于闭式解，我们直接应用公式：</p>
<script type="math/tex; mode=display">
\mathbf{w}^*_\lambda = (\mathbf{X}^T\mathbf{X} + \lambda\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y}</script><p>同时，我们也应用了配合Armijo规则的梯度下降法，得到如下结果。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/LossPlotQ2.png" alt="LossPlotQ2" style="zoom:72%;" /></p>
<p>左图展示了目标函数随梯度下降算法的变化趋势。可以看到，尽管后期下降幅度不显著，但目标值保持递减，体现了线搜索策略的有效性。同时，我们的预期也得到验证：由于该问题是凸优化问题，梯度下降算法的参数 w 收敛于闭式解 w_closed form。黄色曲线表示 w 与 w_closed form 的范数差异，可见其持续收敛。右图展示了参数结果，w_GD 的结果与其闭式解非常接近，肉眼几乎无法区分。而 w_closed form 也较好地拟合了原问题中的真实参数，对模型具有良好的解释力。</p>
<h3 id="正则化强度-λ-的影响"><a href="#正则化强度-λ-的影响" class="headerlink" title="正则化强度 λ 的影响"></a>正则化强度 λ 的影响</h3><h4 id="不同-λ-下的-mathbf-z-mathbf-z-text-true-分析"><a href="#不同-λ-下的-mathbf-z-mathbf-z-text-true-分析" class="headerlink" title="不同 λ 下的 $\|\mathbf{z}-\mathbf{z}_{\text{true}}\|$ 分析"></a>不同 λ 下的 $\|\mathbf{z}-\mathbf{z}_{\text{true}}\|$ 分析</h4><p>下图展示了估计权重与真实权重差异的范数与正则化参数 λ 的关系。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/lambdaVSwnorm.png" alt="W_Norm Under different Lambda" style="zoom: 50%;" /></p>
<p>这里我们在对数尺度上对 λ 进行采样。整体而言，λ 较小时表现优于 λ 较大的情况。放大观察 0 到 10 的区域，最低点出现在 λ = 0.82 处，值为 3.44。但观察 w_true 的真实分布后，由于 w_true 只有前 8 维是有效的，因此从分布相似性角度，分别分析前 8 维和后续维度的范数差异是有必要的：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/WtrueDiffPart.png" alt="WtrueDiffPart" style="zoom:72%;" /></p>
<p>这里我们分别度量了前 8 维和后 42 维，统计各自表现最佳的正则化强度。结果显示：<strong>λ = 3.84 时，优化结果在抑制噪声方面表现最佳</strong>；<strong>λ = 0.39 时，对主要参数（前 8 维）的恢复最准确</strong>。这反映了正则化强度实质上是在降噪和估计真实参数之间寻求平衡。在这两个极端状态下，我们发现之前全参数范数的最优解 λ = 0.83 正好位于 0.39 和 3.84 之间，是一种平衡两者的选择。事实上，我们还可以找到一个特殊的交点，即黄色和蓝色曲线的交点 λ = 1.94。尽管度量范数不一定完全代表对真实参数的相似性测量，但这个点也可作为两者平衡的状态。实际上，在后续对 MSE 的观测中，这两个点确实提供了对模型的良好估计。</p>
<p>为了找到降噪和真实参数估计之间的平衡，我们还可以通过数学推导进行定性分析。在最小二乘模型中：</p>
<script type="math/tex; mode=display">
LS := \min_w\{\|\mathbf{X}\mathbf{w} - \mathbf{y}\|\} \Rightarrow \mathbf{w}^* = \mathbf{[X^T X]^{-1}X^T y}</script><p>根据 SVD 分解，设 $X = U\Sigma V^T$，其中 $U \in \mathbb{R}^{n \times n}$，$\Sigma\in \mathbb{R}^{n \times p}$ 是奇异值的对角矩阵，$V \in \mathbb{R}^{p \times p}$，其中 $\lambda(\mathbf{X}^T\mathbf{X})=\sigma _i^2(\mathbf{X})$，即奇异值由 $[X^TX]$ 的特征值得到，且 $U, V$ 都为标准正交矩阵。</p>
<p>由以下推导：</p>
<script type="math/tex; mode=display">
X^TX=V\Sigma^T U^T U \Sigma V^T=V \Sigma^T \Sigma V^T \\ 
X^T y = V\Sigma^T U^T y\\</script><p>因此：</p>
<script type="math/tex; mode=display">
[X^TX]^{-1} = V(\Sigma^T\Sigma)^{-1}V^T</script><p>进而：</p>
<script type="math/tex; mode=display">
w = V(\Sigma^T\Sigma)^{-1}V^T \cdot V\Sigma^T U^T y = V(\Sigma^T\Sigma)^{-1}\Sigma^T U^T y</script><p>转化为向量形式：</p>
<script type="math/tex; mode=display">
w = \sum_{i=1}^{p} \frac{1}{\sigma_i}(\mathbf{u}_i^T \mathbf{y}) \mathbf{v}_i</script><p>将噪声代入表达式：</p>
<script type="math/tex; mode=display">
w = \sum_{i=1}^{p} \frac{1}{\sigma_i}[\mathbf{u}_i^T (\mathbf{y} + \mathbf{\epsilon})] \mathbf{v}_i</script><p>注意到对于当前问题的 $\mathbf{X}$，我们计算了 $X^TX$ 的条件数高达 14436.20，且大量特征值都在较小的数值范围内。我们知道，当奇异值较小时，对应的特征向量方向包含的信息较少，此时噪声占主导地位，应被忽略；而特征值大的方向包含了更多模型的真实信息。然而，当我们对这些特征值进行倒数处理时，真实信息方向对应的值会因为大特征值而减小，而噪声方向的值会因为小特征值而被放大。求解器无法很好地区分噪声方向和真实信息方向，导致该问题使用简单的最小二乘算法会受到严重的噪声干扰，进而导致模型过拟合。</p>
<p>而引入 L2 正则化策略后，我们有：</p>
<script type="math/tex; mode=display">
\mathbf{w} = \sum_{i=1}^{p} [\frac{\sigma_i}{\sigma_i^2 + \lambda}](\mathbf{u}_i^T(\mathbf{y+\epsilon})) \mathbf{v}_i</script><p>当特征值很大时，$\frac{\sigma_i}{\sigma_i^2 + \lambda} \approx \frac{\sigma_i}{\sigma_i^2}$ 与最小二乘估计保持一致，确保模型信息；当特征值较小时（与 $\lambda$ 相近），明显有 $\frac{\sigma_i}{\sigma_i^2 + \lambda} \leq \frac{1}{\sigma_i}$，起到阀门作用，抑制噪声主导的方向。λ 越大，对噪声的抑制力度就越大。但正则化力度过大的代价是：结果成为对真实参数的有偏估计。具体而言，我们知道最小二乘的结果是对模型参数的无偏估计，即 $E[\mathbf{w}_{LS}] = \mathbf{w}_{\text{True}}$。</p>
<script type="math/tex; mode=display">
\begin{align*}
E[\mathbf{w}_{\lambda}] &= (X^TX+\lambda I)^{-1}X^T\mathbf{y}_{\text{True}} \\
\end{align*}</script><p>注意到当 $\lambda \rightarrow 0$ 时为最小二乘问题，是无偏估计；但随着 $\lambda$ 增大，就会与真实结果差距过大，导致模型欠拟合。总结如下：</p>
<ul>
<li>$\lambda \rightarrow 0$：趋向于对真实参数的无偏估计，但易受噪声干扰，模型过拟合</li>
<li>$\lambda \rightarrow \infty$：抑制噪声干扰，但会偏离对真实参数的回归，模型欠拟合</li>
</ul>
<p>接下来我们将分析模型的 MSE 来验证与补充上述结论。</p>
<h4 id="MSE-分析"><a href="#MSE-分析" class="headerlink" title="MSE 分析"></a>MSE 分析</h4><p>下图描述了模型在不同正则化强度下的训练和测试误差。我们捕捉到关键点：在 λ = 1.2027 时测试集误差达到最小。在之前对 w_true 的范数差异分析中，我们得到了两个平衡噪声和参数估计的点（0.8276 和 1.9410），而真正的测试最低 MSE 也在其附近，这说明上述结论的估计是合理的。同时也再次说明，范数上的最小化并不一定代表优化参数和真实参数最相似。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/MSEAnalysis.png" alt="MSEAnalysis" style="zoom:72%;" /></p>
<p>从整体上看，随着 λ 的减小，测试 MSE 曲线呈现上升趋势，说明确实出现了过拟合现象；而当 λ 较大时，模型拟合程度不够。这与之前的分析一致。</p>
<h3 id="不同-α-和-β-下的收敛速率"><a href="#不同-α-和-β-下的收敛速率" class="headerlink" title="不同 α 和 β 下的收敛速率"></a>不同 α 和 β 下的收敛速率</h3><p>在常见的计算算法中，当数据集规模变大时，直接计算闭式解相对来说不太稳定。这时梯度法是一个合理的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Algorithm 2: The Gradient Method</span><br><span class="line"></span><br><span class="line">Initialization: A tolerance parameter ε &gt; 0 and x⁰ ∈ ℝⁿ.</span><br><span class="line"></span><br><span class="line">General Step: for any k = 0, 1, 2, ... execute the following steps:</span><br><span class="line"></span><br><span class="line">1. Pick a stepsize tᵏ by a line search procedure on the function</span><br><span class="line"></span><br><span class="line">   g(t) = f(xᵏ - t∇f(xᵏ)).</span><br><span class="line"></span><br><span class="line">2. Set xᵏ⁺¹ = xᵏ - tᵏ∇f(xᵏ).</span><br><span class="line"></span><br><span class="line">3. If ||∇f(xᵏ⁺¹)|| ≤ ε, then STOP and output xᵏ⁺¹.</span><br></pre></td></tr></table></figure>
<p>为探究不同线搜索策略变量如何影响收敛，我们固定 λ = 1.2 进行实验。当 λ &gt; 0 时，我们知道 $[X^TX + \lambda I] &gt; 0$，所以该优化问题为在 $\mathcal{R}^p$ 上的凸优化问题，使用梯度下降法必然收敛至唯一解 $\mathbf{w}_{\text{closed}}^*$。</p>
<h4 id="实验-1：固定迭代次数-Epoch-1e5-下的收敛研究"><a href="#实验-1：固定迭代次数-Epoch-1e5-下的收敛研究" class="headerlink" title="实验 1：固定迭代次数 Epoch = 1e5 下的收敛研究"></a>实验 1：固定迭代次数 Epoch = 1e5 下的收敛研究</h4><p>我们将初始学习率设为 s = 1 进行迭代，记录参数优化序列 $\{\mathbf{w}_i\}_{n=1e5}$ 以及优化后梯度的大小。为确保程序流畅执行，我们在 Armijo 循环内施加约束 $t_k &lt; 10^{-16}$ 以防止无限循环。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while not Armijo Ineqn Condition:</span><br><span class="line">	t_k = t_k * beta</span><br><span class="line">	if t_k &lt; 1e-16 do:</span><br><span class="line">		return and show error in the results	</span><br></pre></td></tr></table></figure>
<p>第一个实验针对每个参数对 $(\alpha, \beta)$，我们运行梯度下降法至 epoch=10000，绘制 $(\alpha, \beta)$ 关于 $-\log{\|\nabla f(\mathbf{w_n})\|}$ 的热力图以及目标函数的变化图：</p>
<div style="display: flex; gap: 20px;">
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/ConveragerParam.png" style="width: 48%;">
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/JvsAB.png" style="width: 48%;">
</div>

<p>对于目标函数图，我们采样了 5 个点。注意到所有点最终能使函数收敛到的结果基本一致，而 α = 0.7 时的收敛速度优于 α = 0.3；对于 α = 0.7，β = 0.7 的收敛速度最佳。因此我们推测相对而言较大的 α 收敛速度最快，同时配合较大的 β 可以让收敛速度最优。尽管从目标函数的数值上我们很难比较不同参数对的收敛效果差异，我们进一步通过分析此时目标函数的梯度值来讨论。</p>
<p>从热力图可以观察到，整体上 $\alpha, \beta$ 的大小与收敛程度呈现明显的区域分化，且沿着对角线方向向右上方收敛效果变好：</p>
<ol>
<li>右上方区域（$\alpha \in [0.5, 0.9]$ 且 $\beta \in [0.6, 0.9]$）：右上角区域收敛情况较好，同时注意到该区域整体上在 α = 0.5 这条线上收敛情况最佳，相同 β 下 α 越接近 0.5 梯度越小</li>
<li>右下方区域（$\alpha \in [0.1, 0.5]$ 且 $\beta \in [0.6, 0.9]$）：除了 (0.4, 0.6) 表现突出，其他部分均收敛失败</li>
<li>左部区域（$\beta \in [0.1, 0.3]$）：未收敛，不论 α 如何取情况都较为相似，梯度范数均未降到 1 以下</li>
<li>中部区域（$\beta \in [0.3, 0.5]$）：β 的取值在一定程度上可以收敛，大部分都收敛到梯度范数 1 以下，注意到整体依然以 α = 0.5 附近为中轴线，越远离 α = 0.5 收敛情况越差</li>
</ol>
<p>我们可以从 Armijo 策略来解释上述现象。使用该策略是为了保证模型每次迭代的收敛力度，同时使步长尽可能大。从定性角度，α 越大意味着 Armijo 不等式条件更加严格，需要找到使目标函数下降更强的步长；而 β 决定了每次更新学习率的幅度。</p>
<script type="math/tex; mode=display">
f(w - s\nabla f) \leq f(w) - \alpha s ||\nabla f||^2 \\
w^{k+1} = \beta w^k</script><p>在当前案例中，表现最好的区域符合直觉：高 β 高 α 意味着严格的下降程度和细致的 β 搜索。小幅度的步长变化可以确保找到最优步长，严格的下降程度意味着每次都能有效迭代，进而体现出良好的收敛结果。接下来我们对 α 的选择进行分析：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/ConvergenceTrajFixAlpha.png" alt="ConvergenceTrajFixAlpha" style="zoom:72%;" /></p>
<p>上图展示了 6 个不同 α 下的收敛趋势图，每个图中我们采样了 4 个 β 值下的梯度变化序列作为数据。可以观察到 α = 0.5 的图是一个分水岭，每张图中四个对象的收敛效率从红绿黄蓝的顺序渐变至黄蓝绿红，不同 β 值的梯度震荡也发生变化。对此我们提出如下解释：</p>
<ul>
<li><p>当 α 较小时，Armijo 条件松弛，每次梯度下降的下降量并不充分。可以看到尽管在前两张图中，四种颜色有所差异，但观察其梯度下降的量级都在 1 附近，没有明显差异，这时 α 主导收敛趋势，β 的差异体现得并不明显；</p>
</li>
<li><p>当 α 较大后，每次梯度下降的力度变大，这时能否找到一个尽可能大的学习率就显得尤为重要。我们注意到 β 越大，能够确保每次搜索到的 t 尽可能大，使其收敛速度快，同时在 t 较大时，两次迭代之间 w_k 和 w_{k+1} 距离较大，导致了较大幅度的震荡。</p>
</li>
</ul>
<p>下图展示了若干 α 下收敛度关于 β 的曲线。这也可以证明上述结论：<strong>对于 α 较小时（line α = 0.3 和 0.4），尽管折线有波动，但收敛力度始终没有超过 1e-2 这条线，只有在 α 较大时，才有机会通过微调 β 使其进行有效的梯度下降，冲击高收敛效果。</strong></p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/SemLineCompareInEpnFixA.png" style="zoom:60%;" /></p>
<p>同时我们还需要用这个图来阐述 β 的选择如何影响算法。可以看到在高 α 值曲线（0.5-0.8，α = 0.9 时下降条件过于苛刻不做讨论）均在 β = 0.9 时达到最大值，这符合直觉，因为保证较大的步幅对收敛有利。但这背后有一个潜在问题：如果我们把参考迭代次数从每次计算 <code>w_&#123;k+1&#125; = w_k + t_k * d_k</code> 换成总计算循环次数（梯度下降更新 + 线搜索循环），大 β 值会让步幅变化过于保守，导致较高的线搜索开销，这时适当减小 β 值会是更有利的策略，这一点我们会在下一个实验中进一步分析。我们还注意到特殊点 (0.4, 0.6)：尽管对于 α = 0.4 时整体收敛较差，但配合 β = 0.6 就会让算法焕然一新，这似乎可以归结为适应该问题目标函数的奇迹般的耦合点。</p>
<div style="display: flex; gap: 20px;">
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/46Shape.png" style="width: 48%;">
    <img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/59-Shape.png" style="width: 48%;">
</div>

<p>进一步看，绘制出 α = 0.4, β = 0.6 这组参数的收敛曲线令人惊讶。不同于右侧 (0.5, 0.9) 典型的大振幅持续有规律的下降，这组参数的步长曲线几乎是完全平坦的水平线（除了初始阶段和个别跳跃点），好似正好找到了一条最均匀的下降路径，同时震荡情况在很多状态都未出现。我们可以得出结论：尽管从常识上，大 α 大 β 可以使梯度下降有效进行，但也存在某些特殊的参数对，恰好在下降条件的严格性和步幅变化幅度中找到平衡，是”恰到好处”的巧合组合。</p>
<p>最后，我们绘制目标函数的变化，看看是否与上述结论一致：</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/objvsAB.png" alt="objvsAB" style="zoom:72%;" /></p>
<p>可以发现这与之前分析参数对的结果完全一致：<strong>α 较大时，β 值主导收敛，β 越大收敛越好；当 α 较小时，α 主导收敛，整体效果上限较弱，且 β 对收敛影响较小</strong>。</p>
<h4 id="实验-2：固定容差-Tol-1e-3-下的收敛验证"><a href="#实验-2：固定容差-Tol-1e-3-下的收敛验证" class="headerlink" title="实验 2：固定容差 Tol = 1e-3 下的收敛验证"></a>实验 2：固定容差 Tol = 1e-3 下的收敛验证</h4><p>接下来我们将控制变量从固定 10000 epoch 变为梯度收敛至固定容差 tol=1e-3，通过检查使用的 epoch 次数和总循环数来验证上述结论。注意到在 α = 0.9 时，出现了几处空白，这是因为在线搜索中出现了步幅过小的问题，归因于 α 使下降要求过高导致的数值不稳定。</p>
<p><img src="https://phoenizard-picgo.oss-cn-hangzhou.aliyuncs.com/img/CovTol.png" style="zoom:72%;" /></p>
<p>首先我们关注梯度下降循环的 epoch 数，这个图与上面固定 epoch=10000 下各点收敛情况一致，依然呈现出小 β 和右下角收敛效果弱、中部递增、右上角最强的区域性分布。但当我们统计总循环开销时，情况发生变化：右上角尽管有优势，但与 β 较小时差异不大，说明从计算开销角度，小 β 能更快达到符合 Armijo 条件的步幅，这弥补了其每步 w 移动较小的劣势；而对于右下角则更加糟糕，缓慢的线搜索搭配不充分的下降使其在总开销上表现糟糕。对于近似的 epoch 收敛情况，我们上面说过适当减小 β 值会是更有力的策略。可以看到 (0.8, 0.6) 和 (0.8, 0.7) 两者收敛到 1e-2 的 epoch 数都约为 16000，但其总循环数差了 1e5 次，说明平均每次梯度下降，β = 0.6 都比 β = 0.7 少约 8 次线搜索迭代。令人震惊的依然是 (0.4, 0.6) 不仅在 epoch 数上表现优异，在总计算数上更是降到了 1e6 以下，大幅领先其他参数对。我们认为这个特殊点就是对该问题最合适也最巧合的参数选择。进而我们可以有一下归纳：</p>
<ul>
<li><p>从执行 <code>w_&#123;k+1&#125; = w_k + t_k * d_k</code> 的 Epoch 数角度，如果需要让 Armijo 条件有效控制函数数值的下降，较大的 α 是合理选择；同时每次下降的步幅期望尽可能大，进而较大的 β 可以保证有效收敛。整体上大 α 和大 β 配对是合理的，但参数选择不应使用贪心思想，而是通过微调参数实现动态平衡。在本案例中，$(\alpha, \beta) = (0.4, 0.6)$ 就是这样一个达到动态平衡的点。</p>
</li>
<li><p>从总计算开销来看，如果假设各种计算操作的复杂度相似，那么只要不是小 α 搭配大 β，在总计算开销上差异性不大。大多数时候 epoch 数量和线搜索循环的效率会形成互补关系。在本案例中，动态平衡点 (0.4, 0.6) 为收敛效率最高点。</p>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文系统地研究了岭回归在病态条件下的表现，以及使用 Armijo 策略的梯度法求解岭回归问题的收敛特性。主要结论如下：</p>
<h3 id="1-岭回归对病态问题的改善机制"><a href="#1-岭回归对病态问题的改善机制" class="headerlink" title="1. 岭回归对病态问题的改善机制"></a>1. 岭回归对病态问题的改善机制</h3><p>通过 SVD 分解分析，我们揭示了岭回归的本质作用机制：</p>
<ul>
<li><strong>病态问题的根源</strong>：当数据矩阵 $\mathbf{X}^T\mathbf{X}$ 条件数很大（本文实验中达到 14436.20）时，小奇异值对应的方向会因倒数运算而被放大，导致噪声主导这些方向，造成过拟合</li>
<li><strong>正则化的改善作用</strong>：引入 $\lambda$ 后，权重更新公式变为 $\frac{\sigma_i}{\sigma_i^2 + \lambda}$，对小奇异值方向起到”阀门”作用，抑制噪声影响，同时保留大奇异值方向的真实信息</li>
</ul>
<h3 id="2-正则化强度-λ-的权衡"><a href="#2-正则化强度-λ-的权衡" class="headerlink" title="2. 正则化强度 λ 的权衡"></a>2. 正则化强度 λ 的权衡</h3><p>λ 的选择体现了偏差-方差权衡：</p>
<ul>
<li><strong>λ 过小</strong>：趋向无偏估计，但易受噪声干扰，导致过拟合</li>
<li><strong>λ 过大</strong>：有效抑制噪声，但偏离真实参数，导致欠拟合</li>
<li><strong>最优选择</strong>：实验表明 λ = 1.2027 在测试集上达到最低 MSE，这个值位于纯降噪最优点（λ = 3.84）和参数恢复最优点（λ = 0.39）之间，实现了两者的平衡</li>
</ul>
<h3 id="3-Armijo-策略下梯度法的收敛特性"><a href="#3-Armijo-策略下梯度法的收敛特性" class="headerlink" title="3. Armijo 策略下梯度法的收敛特性"></a>3. Armijo 策略下梯度法的收敛特性</h3><p>对于梯度下降法配合 Armijo 线搜索策略，我们发现：</p>
<ul>
<li><strong>α 的作用</strong>：控制下降条件的严格程度，较大的 α 要求每次迭代有更显著的函数值下降，是有效收敛的必要条件</li>
<li><strong>β 的作用</strong>：决定步长缩减的幅度，较大的 β 意味着更保守但更精细的步长搜索</li>
<li><strong>参数耦合效应</strong>：大 α 和大 β 的组合通常表现良好，但存在特殊的”平衡点”，如 (α=0.4, β=0.6) 在本问题中表现出奇迹般的收敛效果，震荡小、收敛快、计算开销低</li>
<li><strong>计算效率权衡</strong>：虽然大 β 有助于单次迭代的效果，但会增加线搜索的计算开销；适度减小 β 可以在总体计算效率上取得更好的平衡</li>
</ul>
<h3 id="4-实践启示"><a href="#4-实践启示" class="headerlink" title="4. 实践启示"></a>4. 实践启示</h3><p>本研究为实际应用提供了以下指导：</p>
<ol>
<li><strong>正则化参数选择</strong>：应通过交叉验证在测试集上寻找最优 λ，而非简单地最小化训练误差或参数范数差异</li>
<li><strong>梯度法参数调优</strong>：在使用 Armijo 策略时，不应盲目追求大 α 和大 β，而应根据具体问题通过网格搜索或贝叶斯优化寻找平衡点</li>
<li><strong>病态问题诊断</strong>：当数据矩阵条件数很大时，正则化几乎是必需的，即使在样本量充足的情况下</li>
</ol>
<p>总之，岭回归通过引入正则化有效地改善了病态问题，而合理选择优化算法的参数能够在保证收敛质量的同时提高计算效率。理解这些方法背后的数学原理，有助于我们在实际问题中做出更明智的决策。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
